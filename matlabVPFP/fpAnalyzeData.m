%fp data analysis 
%1/20/20
clear
clc
close all

% Make sure the figPath is correct!

figPath = 'C:\Users\capn1\Desktop\testFigs\'; %location for output figures to be saved

% %% Load struct containing data organized by subject
disp('***select a .mat file generated by fpExtractData.m')

load(uigetfile('*.mat')); %choose the subjData file to open for your experiment %by default only show .mat files

profile on; %For optimization/tracking performance of the code- this starts the Matlab profiler

subjects= fieldnames(subjData); %access subjData struct with dynamic fieldnames; these are determined by fpExtractData and the metadata.xlsx

figureCount= 1 ; %keep track of figure # throughout to prevent overwriting

fs= 40; %This is important- if you change sampling frequency of photometry recordings for some reason, change this too! TODO: just save this in subjData as more metadata

%% Remove excluded subjects

excludedSubjs= {'rat20', 'rat16','rat10'}; %cell array with strings of excluded subj fieldnames

subjData= rmfield(subjData,excludedSubjs);

subjects= fieldnames(subjData); %get an updated list of included subjs

subjIncluded= subjects;

%% ~~~Fix DS TTL pulses from variable reward identity stages  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %for stages with variable reward identity (3 pumps, 3 rewards)
    %indicated by 1, 2, or 3 DS TTL pulses in rapid succession (because
    %hardware limits the # of TTL types we can record)
    
    ttlWindow= 2; %time window within which to look for DS TTL pulse bursts ... %2s should be enough
    
    %TODO: consider moving this to fpextractdata.m
    
 for subj= 1:numel(subjects) %for each subject
       for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
           currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
                      
           if ~isnan(currentSubj(session).pump2) %make sure this is a valid stage with multiple rewards %could also define this by trainStage
               
                %first lets save reward identity for each pump
               subjDataAnalyzed.(subjects{subj})(session).reward.pump1= currentSubj(session).pump1;
               subjDataAnalyzed.(subjects{subj})(session).reward.pump2= currentSubj(session).pump2;
               subjDataAnalyzed.(subjects{subj})(session).reward.pump3= currentSubj(session).pump3;
               
               %now we've got to classify DS trials as either pump1,2,or 3
               %based on ttl pulses in short succession
                              
               DScount = 1; %keep track of the actual ds trial count (because we'll have a bunch of extra TTL pulses simply denoting reward identity)
               
               ttlCount= 1; %use this to skip over TTL pulses in the same trial (because 1 trial can have 1,2, or 3 pulses)
              
               for cue= 1:numel(currentSubj(session).DS) %for each DS TTL pulse
                   
                   if ttlCount < numel(currentSubj(session).DS) %since we are adding to ttlCount this just prevents us from going beyond the max index
                   
                       ttlWindowStartTime= currentSubj(session).DS(ttlCount)-ttlWindow;
                       ttlWindowEndTime= currentSubj(session).DS(ttlCount)+ttlWindow;

                       ttlPump= currentSubj(session).DS(currentSubj(session).DS > ttlWindowStartTime & currentSubj(session).DS < ttlWindowEndTime);

                       %save the DS onset as the first TTL pulse in this window (the minimum timestamp)
                       subjDataAnalyzed.(subjects{subj})(session).reward.DS(DScount,1)= min(ttlPump); 
                       
                       %get this shifted timestamp too (because its used in timelocking)
                       subjDataAnalyzed.(subjects{subj})(session).reward.DSshifted(DScount,1)= subjData.(subjects{subj})(session).DSshifted(ttlCount);


                       %save the pump identity based on the # of TTL pulses in this window (numel)

                        if numel(ttlPump) == 1
                            subjDataAnalyzed.(subjects{subj})(session).reward.DSreward(DScount,1)= 1;                                                       
                            DScount= DScount+1;
                            ttlCount= ttlCount+1;
                        elseif numel(ttlPump) ==2
                            subjDataAnalyzed.(subjects{subj})(session).reward.DSreward(DScount,1)= 2;
                            DScount= DScount+1;
                            ttlCount = ttlCount+2; %skip over the next cue ttl pulse because it is in the same trial
                        elseif numel(ttlPump) ==3
                            subjDataAnalyzed.(subjects{subj})(session).reward.DSreward(DScount,1)= 3;
                            DScount= DScount+1;
                            ttlCount = ttlCount+3; %skip over the next two cue ttl pulses because these are in the same trial 
                        end
                                               
                   end %end ttlCount conditional
               end %end cue loop
          
                  
               %for simplicity let's overwrite the original DS trial record with
               %the updated one
               subjData.(subjects{subj})(session).DS= subjDataAnalyzed.(subjects{subj})(session).reward.DS;
               subjData.(subjects{subj})(session).DSreward= subjDataAnalyzed.(subjects{subj})(session).reward.DSreward;
               subjData.(subjects{subj})(session).DSshifted= subjDataAnalyzed.(subjects{subj})(session).reward.DSshifted;
               
            else %if there's no variable reward in this session, make empty
                       
                subjDataAnalyzed.(subjects{subj})(session).reward= [];              
               
            end %end if pump 2 isnan conditional (alternative to stage conditional)
            
       end %end session loop      
end %end subject loop

    %% Fix errors associated with DS TTL pulses (added 10/22/2020)
        %Stage 8 DS code used sequential IF statements that introduced compounding delays before 1) pump on and 2) DS TTL
        %DS TTL is easy to adjust, simply subtract the delay from the
        %recorded TTL pulse (though we have to know the pump identity on
        %that trial to get the correct delay so it has to be done on a
        %trial-by-trial basis)
        
           %TODO: ADD DATE CONDITIONAL HERE AFTER STAGE 8 CODE FIX

        
    for subj= 1:numel(subjects)
        currentSubj= subjData.(subjects{subj});
        currentSubjAnalyzed= subjDataAnalyzed.(subjects{subj});
        
        for session= 1:numel(currentSubj)
            
            if currentSubj(session).trainStage>=8 %error was on on stage 8 code (I'm using >= 8 here temporarily because I am using some numbers greater than 8 as excel metadata labels for some stage 8 sessions) 
                for cue = 1:numel(currentSubj(session).DS)
                    if currentSubjAnalyzed(session).reward.DSreward(cue)==1 %if pump1 trial, DS ttl delay was 10 miliseconds
                        currentSubj(session).DS(cue)=currentSubj(session).DS(cue)-0.010; 
                    end
                    
                    if currentSubjAnalyzed(session).reward.DSreward(cue)==2 %if pump2 trial, DS ttl delay was 20 miliseconds
                        currentSubj(session).DS(cue)=currentSubj(session).DS(cue)-0.020; 
                    end
                        
                    if currentSubjAnalyzed(session).reward.DSreward(cue)==3 %if pump2 trial, DS ttl delay was 20 miliseconds
                        currentSubj(session).DS(cue)=currentSubj(session).DS(cue)-0.030; 
                    end
                end
            end
            
        end%end session loop
        
    end % end subj loop

%% ~~~Photometry plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% Within-subjects raw photometry plots - all in 1 figure
% In this section, we'll plot the "raw" (it's been preprocessed and
% downsampled) 405nm and 465nm photometry traces from each session. This makes 
% one figure per subject with all session traces subplotted so may be slow if you have a lot of sessions
% useful if you have a few sessions, but too unwieldy with >10sessions
%  
% for subj= 1:numel(subjects) %for each subject
%     
%     currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%     
%     disp(strcat('plotting photometry data for_', subjects{subj}));
%     
%     figure(figureCount) %one figure per subject, with all sessions subplotted
%     figureCount= figureCount+1;
%     
%    sgtitle(strcat(subjData.(subjects{subj})(1).experiment, subjects{subj}, 'downsampled photometry traces')); %add big title above all subplots
%     
%    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
%        
%        currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
%       
%        
%      
%        
%        % Raw session plots- within subjects
% %         subplot(numel(subjData.(subjects{subj})),1,session); %one subplot per session
% %         hold on
% %         plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
% %         plot(currentSubj(session).cutTime, currentSubj(session).repurple,'m'); %plot 405nm trace
% %         title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
% %         xlabel('time (s)');
% %         ylabel('mV');
% %         legend('blue (465)',' purple (405)');
% %         
%         % Fitted session plots (so that 2 signals overlap)
%         fitPurple= controlFit(currentSubj(session).reblue, currentSubj(session).repurple);
%         
%         subplot(numel                             (subjData.(subjects{subj})),1,session);
%         
%         subplot(numel(subjData.(subjects{subj})),1,session); %one subplot per session
%         hold on
%         plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
%         plot(currentSubj(session).cutTime, fitPurple,'m'); %plot 405nm trace
%         title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
%         xlabel('time (s)');
%         ylabel('mV');
%         legend('blue (465)',' fitted purple (405)');
%         
%         
%    end  
%         %make figure full screen, save, and close this figure
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% %         saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'_downsampled_session_traces','.fig'));
% %         close; %close 
% end1


% %% Within-subjects raw photometry plots- separate figures
% for subj= 1:numel(subjects) %for each subject
%     
%     currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%     
%     disp(strcat('plotting photometry data for_', subjects{subj}));
%            
%    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
%        
%        
%         figure(figureCount) %one figure per SESSION
%         figureCount= figureCount+1;
%        
%        
%        currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
%       
%        
%       
%        
%        % Raw session plots
% %         hold on;
% %         plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
% %         plot(currentSubj(session).cutTime, currentSubj(session).repurple,'m'); %plot 405nm trace
% %         title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
% %         xlabel('time (s)');
% %         ylabel('mV');
% %         legend('blue (465)',' purple (405)');
% 
%        % Fitted session plots
%         fitPurple= controlFit(currentSubj(session).reblue, currentSubj(session).repurple);
%         
%         hold on;
%         plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
%         plot(currentSubj(session).cutTime, fitPurple,'m'); %plot 405nm trace
%         title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
%         xlabel('time (s)');
%         ylabel('mV');
%         legend('blue (465)',' fitted purple (405)');
%         
%         
%         
%          %make figure full screen, save, and close this figure
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% % %         waitforbuttonpress();
%         saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'session',num2str(currentSubj(session).trainDay),'_downsampled_trace','.fig'));
%         close; %close
%    end  
%     
% end


%% ~~~Photometry Signal processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Photobleach correction
 %Going for something like (Patel et al 2019 bioRxiv)
for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       clear cutTime reblue repurple
       
       cutTime= currentSubj(session).cutTime;
       reblue= currentSubj(session).reblue;
       repurple= currentSubj(session).repurple;
       
       
%        
     %let's fit an exponential function to the blue and purple signals

     %First order exponential fit
% ft=fittype('exp1');
% currentSubj(session).blueFit=fit(cutTime',reblue,ft);
% currentSubj(session).purpleFit=fit(cutTime',repurple,ft);

    %matlab's built in detrend function 
% detrendblue= detrend(reblue, 2);
% detrendpurple= detrend(repurple, 2);
%      
%      figure(figureCount);
%      figureCount=figureCount+1;
%      subplot(2,1,1);
%      plot(currentSubj(session).blueFit, cutTime, reblue)
%      hold on;
% %      plot(cutTime,detrendblue,'k');
%      subplot(2,1,2);
%      plot(currentSubj(session).purpleFit, 'k', cutTime, repurple, 'm')
%      hold on;
% %      plot(cutTime,detrendpurple,'k');
%      
%      set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving/closing
%      
% %      waitforbuttonpress;
%      close;

     
         %matlab's built in moving median function
         %inspired by(Patel, McAlinden, Matheison, &
         %Sakata, 2019 BioRxiv) but not really what they did
    medianblue= movmedian(reblue,800);
    medianpurple= movmedian(repurple, 800); %40=1s %800 = 20s
    
    dffblue= (reblue-medianblue)./medianblue;
    dffpurple= (repurple-medianpurple)./medianpurple;
    
    figure(figureCount);
    figureCount= figureCount+1;
    subplot(4,1,1);
    title('blue moving median')
    hold on;
    plot(cutTime,reblue);
    plot(cutTime,medianblue, 'k');
    subplot(4,1,2);
    hold on;
    title('blue dF/F (value-median/median)');
    plot(cutTime,dffblue);
    subplot(4,1,3);
    title('purple moving median')
    hold on;
    plot(cutTime, repurple, 'm');
    plot(cutTime, medianpurple, 'k');
    subplot(4,1,4);
    hold on;
    title('purple dF/F (value-median/median)');
    plot(cutTime,dffpurple, 'm');
    
    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving/closing
    
%     waitforbuttonpress;
    close;
    
          
    subjDataAnalyzed.(subjects{subj})(session).photometry.bluedff= dffblue;
    subjDataAnalyzed.(subjects{subj})(session).photometry.purpledff= dffpurple;
   end %end session loop
end %end subject loop
 
 
%% ~~~Photometry Analysis ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% CROSS CORRELATION OF PHOTOMETRY SIGNALS

%For a given session, let's get a correlation coefficient of Blue & Purple
%signal over time
for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   
%    figure(figureCount); %1 fig per subject
%    figureCount= figureCount+1;
   
   for session = 1:numel(currentSubj) %for each training session this subject completed

%        currentSubj(session).signalCorrelation= xcorr(currentSubj(session).reblue,currentSubj(session).repurple,0,'coeff');
        
        cutTime = currentSubj(session).cutTime;
        r= [];
        p= [];

        
        %Try sliding corrcoef calc
%         slideFrames= 10*fs;
%         for ts = 1:numel(cutTime) %for each timestamp
%             
%             if ts-slideFrames> 0 && ts+slideFrames<numel(cutTime)
%                 startTime= ts-slideFrames;
%                 endTime= ts+slideFrames;
% 
%                 [R,P] = corrcoef(currentSubj(session).reblue(startTime:endTime), currentSubj(session).repurple(startTime:endTime));
%                 r(ts)= R(2);
%                 p(ts)= P(2);
%             end
%         end
%         
%         plot(r);
% figure;

%         currentSubj(session).signalCorrelation= corrcoef(currentSubj(session).reblue,currentSubj(session).repurple);
%         [r, lags]= xcorr(currentSubj(session).reblue, currentSubj(session).repurple, 'unbiased');
%         hold on;
%         
%         [r, lags]= xcorr(currentSubj(session).reblue, currentSubj(session).repurple, 'coeff');


        %xcorr on the raw signals returns a triangle shaped plot with a
        %peak at 0, possibly due to DC offset component in signals... Will
        %try to remove this by subtracting mean

        
%         [r, lags]= xcorr(currentSubj(session).reblue-nanmean(currentSubj(session).reblue), currentSubj(session).repurple-nanmean(currentSubj(session).repurple), 'coeff');
%         stem(lags, r);

        %still getting a weird shape, let's try this on a rolling z score?
               
% %trying movcorr function
% r2= [];
% p2=[];
%     [r2, p2, n]=movcorr(currentSubj(session).reblue, currentSubj(session).repurple, 400); %sliding 10s pearson
% 
%     subplot(4,1,1);
%     plot(cutTime, currentSubj(session).reblue, 'b');
%     subplot(4,1,2);
%     plot(cutTime, currentSubj(session).repurple, 'm');
%     subplot(4,1,3);
%     plot(cutTime, r2, 'k');
%     title('sliding r')
%     hold on
%     plot([1, cutTime(end)], [0, 0], 'k--');
%     hold off
%     subplot(4,1,4);
%     plot(cutTime,p2, 'r');
%     title('p value');
%     hold on
%     plot([1, cutTime(end)], [0.05, 0.05], 'k--');
%     hold off
%            
%     figure;
%     plot(r2);
%        scatter(currentSubj(session).trainDay,currentSubj(session).signalCorrelation(2));
   end %end session loop
end %end subject loop


%% Trying correlation with dff calculated in previous section
for subj= 1:numel(subjects)
    for session= 1:numel(subjDataAnalyzed.(subjects{subj}))
        
        cutTime= subjData.(subjects{subj})(session).cutTime;
        currentSubj= subjDataAnalyzed.(subjects{subj}); %easy indexing into subject
              %going to try on dff calculated by previous section
%         [r, lags]= xcorr(currentSubj(session).photometry.bluedff,currentSubj(session).photometry.purpledff, 'coeff');
%         stem(lags, r);
        
       
        
%         %trying movcorr function
%     [r, p, n]=movcorr(currentSubj(session).photometry.bluedff, currentSubj(session).photometry.purpledff, 400); %sliding 10s pearson
% 
%     figure(figureCount);
%     figureCount= figureCount+1;
%     
%     subplot(4,1,1);
%     plot(cutTime, currentSubj(session).photometry.bluedff, 'b');
%     hold on;
%     title('blue dff');
%     subplot(4,1,2);
%     plot(cutTime, currentSubj(session).photometry.purpledff, 'm');
%     hold on;
%     title('purple dff');
%     subplot(4,1,3);
%     plot(cutTime, r, 'k');
%     title('sliding r')
%     hold on
%     plot([1, cutTime(end)], [0, 0], 'k--');
%     hold off
%     subplot(4,1,4);
%     plot(cutTime,p, 'r');
%     title('p value');
%     hold on
%     plot([1, cutTime(end)], [0.05, 0.05], 'k--');
%     hold off
%     
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving/closing
%     waitforbuttonpress;
%     close;

    end %end session loop
end %end subj loop


%% Create subjDataAnalyzed struct to hold analyzed data
%In this section, we'll initialize a subjDataAnalyzed struct to hold any
%relevant analyzed data separately from raw data. We will populate it with
%some metadata before doing any analyses. This metadata all originates from
%the metadata.xlsx file and the subjData struct generated by
%fpExtractData.m

%Fill with metadata
 for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       experimentName= currentSubj(session).experiment; 
       
       subjDataAnalyzed.(subjects{subj})(session).experiment= currentSubj(session).experiment;
       
       subjDataAnalyzed.(subjects{subj})(session).date= currentSubj(session).date;
       
       subjDataAnalyzed.(subjects{subj})(session).rat= currentSubj(session).rat;
       subjDataAnalyzed.(subjects{subj})(session).fileName= currentSubj(session).fileName;
       subjDataAnalyzed.(subjects{subj})(session).trainDay= currentSubj(session).trainDay;
       subjDataAnalyzed.(subjects{subj})(session).trainStage= currentSubj(session).trainStage;
       subjDataAnalyzed.(subjects{subj})(session).box= currentSubj(session).box;     
       
       %saving raw data here probably makes variable too big/slows things
       %save raw event timestamps too- will be useful for deconvolution later
       subjDataAnalyzed.(subjects{subj})(session).raw.pox= currentSubj(session).pox;
       subjDataAnalyzed.(subjects{subj})(session).raw.out= currentSubj(session).out;
       subjDataAnalyzed.(subjects{subj})(session).raw.lox= currentSubj(session).lox;
       
       %save photometry signals- will be useful for deconvolution later
       subjDataAnalyzed.(subjects{subj})(session).raw.cutTime= currentSubj(session).cutTime;
       subjDataAnalyzed.(subjects{subj})(session).raw.reblue= currentSubj(session).reblue;
       subjDataAnalyzed.(subjects{subj})(session).raw.repurple= currentSubj(session).repurple;

       
   end %end session loop
end %end subject loop




%% ~~~Behavioral Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


%% Lick bout classification

%In this section, we will loop through all licks for each session and
%define lick bouts based on the parameters below. We will use lickInd as a
%counter to keep track of which lick we should be on as we loop through,
%since bout size differs. We will look for licks within a certain interlick
%interval (ILI) of each lick. If we find any, they'll be saved to the bout
%array. We will then keep looking for licks within the ILI of the final
%lick in the bout until we don't find any more, at which point we'll change
%the boutDone conditional to finish evaluating this bout. If this bout
%meets some criteria (e.g. has at least 3 bouts), we will save it and
%advance onto the next bout.

%first let's define some parameters 
interLickThreshold = 1.0; %threshold in seconds between licks beyond which = new bout
licksPerBoutThreshold= 3; %need this many licks to be called a bout

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
      
   
   for session = 1:numel(currentSubj) %for each training session this subject completed
     
      boutCount=1; %counter for bouts
      lickInd= 1; %counter used to skip over licks in the current bout

      bout= []; %array containing licks for the current bout
      lickBouts= {}; %cell array containing lick bouts
       
      boutDone= 0; %logic gate between bouts
      
       for lick = 1:numel(currentSubj(session).lox)
           
           if lickInd< numel(currentSubj(session).lox) %make sure the index is valid (since we're adding to lickInd)
            
               if boutDone ==0 %if we are still filling the current bout
               
             
                       if isempty(bout) %start assigning licks to this bout if bout is empty
                           boutStart= currentSubj(session).lox(lickInd); %-interBoutThreshold;
                           boutEnd= currentSubj(session).lox(lickInd)+interLickThreshold;

                           %extract licks that occur between the bout start and end
                           %because we are using >= boutStart, there will
                           %always be at least 1 lick (the first one at boutStart)
                           %included in the bout... that is why we'll be
                           %using numel(bout>1) as a logic gate instead of
                           %~isempty
                           bout= currentSubj(session).lox(currentSubj(session).lox >=boutStart & currentSubj(session).lox <boutEnd);
                       end
                       
                       if  numel(bout>1) %if the bout has already been started and licks were found beyond the initial lick, continue filling the bout with licks
                           %now use bout(end) to see if there are more
                           %licks within the desired interlick interval
                           %(ili) threshold of the final lick in the bout
                           boutStart= bout(end);
                           boutEnd= bout(end)+interLickThreshold;
                           
                           bout= cat(1, bout,currentSubj(session).lox(currentSubj(session).lox>boutStart & currentSubj(session).lox<boutEnd)); 
                           lickInd = find(currentSubj(session).lox==bout(end)); %as the loop continues, skip over licks already assigned to a bout


                            %if there are no more licks within the desired
                            %ILI, make the bout complete
                            if isempty(currentSubj(session).lox(currentSubj(session).lox>boutStart & currentSubj(session).lox<boutEnd))
                                boutDone=1; 
                            end
                       end
                       
                       if numel(bout)==1 %if there aren't any licks except for the first one in this bout time window, advance lickInd by 1 and make the bout complete
                           lickInd=lickInd+1;
                           boutDone=1;
                       end                      
               end %end boutDone=0 conditional
               
               if boutDone==1 %if this bout is complete, let's save it and advance the boutCount
                   
                       if numel(bout) > licksPerBoutThreshold %Only if this 'bout' contains at least the number of licks required, call it a bout and save it
                          lickBouts{boutCount}= bout;
                          boutCount=boutCount+1;
                          bout=[];
                       
                       else %if there aren't enough licks to consider this a real bout, make bout empty again for the next loop
                           bout=[];
                       end
                       
                       boutDone=0; %reset the boutDone conditional
               end %end boutDone conditional
           end %end index check conditional
       end %end lick loop
       
       currentSubj(session).lickBouts= lickBouts;
     
       %save the lick bout data
       subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts= currentSubj(session).lickBouts;


%       % %    %visualization -- takes long time bc looping thru cell array
%        figure(figureCount);
%        figureCount= figureCount+1;
% 
%        for currentBout = 1:numel(currentSubj(session).lickBouts)
%            hold on;
%            title('lick bout # over time');
%            scatter(currentSubj(session).lickBouts{currentBout},ones(size(currentSubj(session).lickBouts{currentBout}))*currentBout);
%        end

   end %end session loop

end %end subject loop





%% Identify PEs and licks occuring during the DS 

% Here, we'll loop through every cue in every session, finding the cue
% onset time and the cue's duration. Then, we'll check for PEs and licks
% that occur during this duration and assign them to that cue.

%TODO: for licks, maybe not the best way to see licks for a particular reward
%since it's only getting licks in the cue duration... May be better to
%collect all licks between the current cue onset and the next cue's onset

%Parameters
preCueTime= 5; %t in seconds to examine before cue
postCueTime= 10; %t in seconds to examine after cue

preCueFrames= preCueTime*fs;
postCueFrames= postCueTime*fs;

periCueFrames= preCueFrames+postCueFrames;

slideTime = 400; %define time window before cue onset to get baseline mean/stdDev for calculating sliding z scores- 400 for 10s (remember 400/40hz ~10s)


disp('classifying events during cue epoch');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
  
   for session = 1:numel(currentSubj) %for each training session this subject completed    
  
        clear cutTime poxDS loxDS outDS %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

           %initialize cell arrays, so they're all the same size for
            %convenience
            currentSubj(session).behavior.poxDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.poxDSrel= cell(1, numel(currentSubj(session).DS));
            currentSubj(session).behavior.outDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.outDSrel= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.loxDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.loxDSrel= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.lickBoutsDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.lickBoutsDSrel= cell(1,numel(currentSubj(session).DS));

        %First, let's establish the cue duration based on training stage
        if currentSubj(session).trainStage == 1
            cueLength= 60*fs; %60s on stage 1, multiply by fs to get #frames
        elseif currentSubj(session).trainStage ==2
            cueLength= 30*fs;
        elseif currentSubj(session).trainStage ==3
            cueLength= 20*fs;
        else %on subsequent stages, cueLength is 10s
            cueLength =10*fs; 
        end
        
        for cue=1:length(currentSubj(session).DS) %for each DS cue in this session

            %each entry in DS is a timestamp of the DS onset, let's get its
            %corresponding index from cutTime and use that to pull
            %surrounding data
            DSonset = find(cutTime==currentSubj(session).DSshifted(cue,1));
                     
          if DSonset + cueLength < numel(cutTime) %make sure cue isn't too close to the end of session  
                %find an save pox during the cue duration
                poxDScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).pox) % for every port entry logged during this session
                   if (cutTime(DSonset)<currentSubj(session).pox(i)) && (currentSubj(session).pox(i)<cutTime(DSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.poxDS{1,cue}(poxDScount,1)= currentSubj(session).pox(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        %save timestamps of lick relative to cue onset
                        currentSubj(session).behavior.poxDSrel{1,cue}(poxDScount,1)= currentSubj(session).pox(i)-cutTime(DSonset);
                        poxDScount=poxDScount+1; %iterate the counter
                   end
                end


                %find and save port exits during the cue 
                outDScount= 1;
                for i = 1:numel(currentSubj(session).out) % for every port entry logged during this session
                   if (cutTime(DSonset)<currentSubj(session).out(i)) && (currentSubj(session).out(i)<cutTime(DSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.outDS{1,cue}(outDScount,1)= currentSubj(session).out(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        currentSubj(session).behavior.outDSrel{1,cue}(outDScount,1)= currentSubj(session).out(i)-cutTime(DSonset);
                        outDScount=outDScount+1; %iterate the counter
                   end
                end


                %find and save licks during the cue duration
                loxDScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).lox) % for every port entry logged during this session %cue onset + cueLength if within cue ; cueonset + periCueFrames if within the heatplot window
                   if (cutTime(DSonset)<currentSubj(session).lox(i)) && (currentSubj(session).lox(i)<cutTime(DSonset+postCueFrames)) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                       %save absolute timestamps  
                       currentSubj(session).behavior.loxDS{1,cue}(loxDScount,1)= currentSubj(session).lox(i); %cell array containing all pox during the cue, empty [] if no licks during the cue
                        
                       %save timestamps of lick relative to cue onset
                       currentSubj(session).behavior.loxDSrel{1,cue}(loxDScount,1)= currentSubj(session).lox(i)-cutTime(DSonset);
                       
                       loxDScount=loxDScount+1; %iterate the counter
                   end
                end
                
                
                  %find and save lickBouts during the cue duration
                  %looping a bit different because lickBouts organized in cell array
                lickBoutDScount= 1; %counter for indexing
                    
                for i = 1:numel(subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts) % for every port entry logged during this session %cue onset + cueLength if within cue ; cueonset + periCueFrames if within the heatplot window
                    lickBoutsDS= subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts{i}(subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts{i}>cutTime(DSonset)& subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts{i} < cutTime(DSonset+postCueFrames));
                    if (cutTime(DSonset)<subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts{i}) & subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts{i}<cutTime(DSonset+postCueFrames) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                       %save absolute timestamps  
                       currentSubj(session).behavior.lickBoutsDS{1,cue}= lickBoutsDS; %cell array containing all pox during the cue, empty [] if no licks during the cue
                        
                       %save timestamps of lick relative to cue onset
                       currentSubj(session).behavior.lickBoutsDSrel{1,cue}= subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts{i}-cutTime(DSonset);
                       
                       lickBoutDScount=lickBoutDScount+1; %iterate the counter
                   end
                end
                
                               
          end %end cue too close to end conditional
        end %end cue loop
               
            subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS= currentSubj(session).behavior.poxDS;
            subjDataAnalyzed.(subjects{subj})(session).behavior.poxDSrel= currentSubj(session).behavior.poxDSrel;
            subjDataAnalyzed.(subjects{subj})(session).behavior.outDS= currentSubj(session).behavior.outDS;
            subjDataAnalyzed.(subjects{subj})(session).behavior.outDSrel= currentSubj(session).behavior.outDSrel;
            subjDataAnalyzed.(subjects{subj})(session).behavior.loxDS= currentSubj(session).behavior.loxDS;
            subjDataAnalyzed.(subjects{subj})(session).behavior.loxDSrel= currentSubj(session).behavior.loxDSrel;
            
            subjDataAnalyzed.(subjects{subj})(session).behavior.lickBoutsDS= currentSubj(session).behavior.lickBoutsDS;
            subjDataAnalyzed.(subjects{subj})(session).behavior.lickBoutsDSrel= currentSubj(session).behavior.lickBoutsDSrel;


   end %end session loop
     
end %end subject loop


%% Identify PEs and licks occuring during the NS 

% Here, we'll loop through every cue in every session, finding the cue
% onset time and the cue's duration. Then, we'll check for PEs and licks
% that occur during this duration and assign them to that cue.

disp('classifying events during NS cue epoch');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
  
   for session = 1:numel(currentSubj) %for each training session this subject completed    
  
        clear cutTime poxNS loxNS outNS %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

           %initialize cell arrays, so they're all the same size for
            %convenience
            currentSubj(session).behavior.poxNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.poxNSrel= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.outNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.outNSrel= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.loxNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.loxNSrel= cell(1,numel(currentSubj(session).NS));

        %First, let's establish the cue duration based on training stage
        if currentSubj(session).trainStage == 1
            cueLength= 60*fs; %60s on stage 1, multiply by fs to get #frames
        elseif currentSubj(session).trainStage ==2
            cueLength= 30*fs;
        elseif currentSubj(session).trainStage ==3
            cueLength= 20*fs;
        else %on subsequent stages, cueLength is 10s
            cueLength =10*fs; 
        end
        
        if ~isnan(currentSubj(session).NS) %can only run if NS data is present in session        
        
            for cue=1:length(currentSubj(session).NS) %for each NS cue in this session

                %each entry in NS is a timestamp of the NS onset, let's get its
                %corresponding index from cutTime and use that to pull
                %surrounding data
                NSonset = find(cutTime==currentSubj(session).NSshifted(cue,1));


                %find an save pox during the cue duration
                poxNScount= 1; %counter for indexing
                for i = 1:numel(currentSubj(session).pox) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).pox(i)) && (currentSubj(session).pox(i)<cutTime(NSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.poxNS{1,cue}(poxNScount,1)= currentSubj(session).pox(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        
                        %pox timestamp relative to cue onset
                        currentSubj(session).behavior.poxNSrel{1,cue}(poxNScount,1)= currentSubj(session).pox(i)-cutTime(NSonset);
                        poxNScount=poxNScount+1; %iterate the counter
                   end
                end


                %find and save port exits during the cue
                outNScount= 1;
                for i = 1:numel(currentSubj(session).out) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).out(i)) && (currentSubj(session).out(i)<cutTime(NSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.outNS{1,cue}(outNScount,1)= currentSubj(session).out(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        
                        %out timestamp relative to cue onset
                        currentSubj(session).behavior.outNSrel{1,cue}(outNScount,1)= currentSubj(session).out(i)-cutTime(NSonset);
                        outNScount=outNScount+1; %iterate the counter
                   end
                end


                %find and save licks during the cue duration
                loxNScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).lox) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).lox(i)) && (currentSubj(session).lox(i)<cutTime(NSonset+postCueFrames)) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                       %absolute lick timestamps 
                       currentSubj(session).behavior.loxNS{1,cue}(loxNScount,1)= currentSubj(session).lox(i); %cell array containing all pox during the cue, empty [] if no licks during the cue
                        
                       %lick timestamp relative to cue onset
                       currentSubj(session).behavior.loxNSrel{1,cue}(loxNScount,1)= currentSubj(session).lox(i)-cutTime(NSonset);
                       loxNScount=loxNScount+1; %iterate the counter
                   end
                end

            end %end cue loop            
        end %end NS conditional

        %save the results
        subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS= currentSubj(session).behavior.poxNS';
        subjDataAnalyzed.(subjects{subj})(session).behavior.poxNSrel= currentSubj(session).behavior.poxNSrel;
        subjDataAnalyzed.(subjects{subj})(session).behavior.outNS= currentSubj(session).behavior.outNS;
        subjDataAnalyzed.(subjects{subj})(session).behavior.outNSrel= currentSubj(session).behavior.outNSrel;
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS= currentSubj(session).behavior.loxNS;   
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNSrel= currentSubj(session).behavior.loxNSrel;
        
        %debugging - view these side by side to verify pox during NS epoch
        %are being assigned
%         openvar('currentSubj(session).NS')
%         openvar('currentSubj(session).pox')
%         openvar('subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS')

        
   end %end session loop
     
end %end subject loop


%% Identify trials where animal was waiting in port at cue onset

%here, we'll go through all cues from each session, finding the difference
%between the cue onset time and every logged port entry and port exit
%timestamp. We'll find the port entry and port exit that is closest (minimum difference) to the
%cue onset, then we'll compare these two. We will only look in one
%direction (after the cue onset time) by turning any negative differences
%into large positive differences. If the closest Out pulse is closer to the cue onset
%than the closest port entry pulse, then the animal was already in the port
%on that trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       clear poxDiffDS outDiffDS poxDiffNS outDiffNS
       
       %loop through DS cues
        for cue = 1:numel(currentSubj(session).DS) %for each DS
            %for each pox timestamp, get the difference between the pox and this DS cue's onset
            for i = 1:numel(currentSubj(session).pox) 
                poxDiffDS(i) = currentSubj(session).pox(i)- currentSubj(session).DS(cue,1);
            end
            
            %get rid of negative values by making them very large
            %this way we're only looking at TTLs after cue onset
            poxDiffDS(poxDiffDS<0) = 99999; 
            
            [~,minPoxInd] = min(poxDiffDS);
                           
            currentSubj(session).pox(minPoxInd);

            for i= 1:numel(currentSubj(session).out)
                outDiffDS(i)= currentSubj(session).out(i)- currentSubj(session).DS(cue,1);
            end

            outDiffDS(outDiffDS<0)= 99999; %make any negative differences very large
            
            %if the closest TTL pulse to cue onset was an out, the animal was in the port already
            if min(outDiffDS)<min(poxDiffDS)
                
                currentSubj(session).inPortDS(1,cue)= cue; %animal was in port on this trial
%                 disp(strcat(subjects{subj}, 'session', num2str(session), '_DS_', num2str(cue), ' inPortDS '));

            else
                currentSubj(session).inPortDS(1,cue)= NaN; %animal was not in port on this trial
            end
            
       end %end DS loop
       
   %Repeat for NS
   
        for cue = 1:numel(currentSubj(session).NS) %for each NS
            
            %for each pox timestamp, get the difference between the pox and this NS cue's onset
            for i = 1:numel(currentSubj(session).pox) 
                poxDiffNS(i) = currentSubj(session).pox(i)- currentSubj(session).NS(cue,1);
            end
            
            %get rid of negative values by making them very large
            %this way we're only looking at TTLs after cue onset
            poxDiffNS(poxDiffNS<0) = 99999; 
            
            [~,minPoxInd] = min(poxDiffNS);
                           
            currentSubj(session).pox(minPoxInd);

            for i= 1:numel(currentSubj(session).out)
                outDiffNS(i)= currentSubj(session).out(i)- currentSubj(session).NS(cue,1);
            end

            outDiffNS(outDiffNS<0)= 99999; %make any negative differences very large
            
            %if the closest TTL pulse to cue onset was an out, the animal was in the port already
            if min(outDiffNS)<min(poxDiffNS)
                
                currentSubj(session).inPortNS(1,cue)= cue;
%                 disp(strcat(subjects{subj}, 'session', num2str(session), '_NS_', num2str(cue), ' inPortNS '));

            else
                currentSubj(session).inPortNS(1,cue)= NaN;
            end
            
       end %end NS loop
       
       
       subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS= currentSubj(session).inPortDS;
       subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS= currentSubj(session).inPortNS;
       
   end %end session loop
end %end subject loop

%% Classify trials by PE outcome
% There are 3 potential outcomes of a trial during the cue epoch we are interested in: 1) rat
% makes a PE 2) rat does not make a PE 3) rat was already in the port

% An animal who was in the port at cue onset can still make PEs afterward,
% so it would be best to classify each trial based on the outcome ahead of
% time and then use this to to index trials based on their PE outcome
% instead of checking each time we want to do it
for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    
    for session= 1:numel(currentSubj)
        DSinPort= []; DSnoPE= []; DSPE= []; %reset between sessions
        NSinPort= []; NSnoPE= []; NSPE= [];

              %Identify trials where animal was in port at trial start,
              %trials with no PE, and trials with a valid PE. For each
              %trial type, loop through trials and get mean
              %cue-elicited response 

                %First, let's get trials where animal was already in port
                DSinPort= find(~isnan(currentSubj(session).behavior.inPortDS));

                %Then, let's get trials where animal did not make a PE during the cue epoch. (cellfun('isempty'))
                DSnoPE = find(cellfun('isempty', currentSubj(session).behavior.poxDS));
                 %additional check here to make sure animal was not in the
                %port at trial start even if a valid PE exists
                 for inPortTrial= DSinPort
                    DSnoPE(DSnoPE==inPortTrial)=[]; %eliminate trials where animal was in port
                 end
                 
             %lastly, get trials with valid PE
             DSPE= find(~cellfun('isempty', currentSubj(session).behavior.poxDS));
              %additional check here to make sure animal was not in the
                %port at trial start even if a valid PE exists
             for inPortTrial= DSinPort
                 DSPE(DSPE==inPortTrial)=[]; %eliminate trials where animal was in port
             end
             
                %Make sure the trial types are all mutually exclusive to prevent errors (intersect() should return empty because no trials should be the same) 
             if ~isempty(intersect(DSinPort,DSnoPE)) || ~isempty(intersect(DSinPort, DSPE)) || ~isempty(intersect(DSnoPE, DSPE))
                disp('~~~~~~~~error: trial types not mutually exclusive');
             end
             
             %Repeat for NS trials
             
             %only run for stages with NS
             if currentSubj(session).trainStage >=5
                 %First, let's get trials where animal was already in port
                    NSinPort= find(~isnan(currentSubj(session).behavior.inPortNS));

                    %Then, let's get trials where animal did not make a PE during the cue epoch. (cellfun('isempty'))
                    NSnoPE = find(cellfun('isempty', currentSubj(session).behavior.poxNS))'; %transpose ' due to shape
                     %additional check here to make sure animal was not in the
                    %port at trial start even if a valid PE exists
                     for inPortTrial= NSinPort
                        NSnoPE(NSnoPE==inPortTrial)=[]; %eliminate trials where animal was in port
                     end

                 %lastly, get trials with valid PE
                 NSPE= find(~cellfun('isempty', currentSubj(session).behavior.poxNS))'; %transpose ' due to shape
                  %additional check here to make sure animal was not in the
                    %port at trial start even if a valid PE exists
                 for inPortTrial= NSinPort
                     NSPE(NSPE==inPortTrial)=[]; %eliminate trials where animal was in port
                 end

                    %Make sure the trial types are all mutually exclusive to prevent errors (intersect() should return empty because no trials should be the same) 
                 if ~isempty(intersect(NSinPort,NSnoPE)) || ~isempty(intersect(NSinPort, NSPE)) || ~isempty(intersect(NSnoPE, NSPE))
                    disp('~~~~~~~~error: trial types not mutually exclusive');
                 end
             end
             
             
             %now save these into the subjDataAnalzyed struct so we can use them later
             %Outcome code: 1= PE during cue epoch, 2= no PE during cue
             %epoch, 3= in port at cue onset
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSoutcome= nan(size(subjData.(subjects{subj})(session).DS));
             
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSoutcome(DSPE)=1;
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSoutcome(DSnoPE)=2;
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSoutcome(DSinPort)= 3;
             
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSoutcome= nan(size(subjData.(subjects{subj})(session).NS));
             
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSoutcome(NSPE)=1;
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSoutcome(NSnoPE)=2;
             subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSoutcome(NSinPort)= 3;
% 
%              subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSinPort= DSinPort';
%              subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSnoPE= DSnoPE';
%              subjDataAnalyzed.(subjects{subj})(session).trialOutcome.DSPE= DSPE';
%              
%              subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSinPort= NSinPort';
%              subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSnoPE= NSnoPE';
%              subjDataAnalyzed.(subjects{subj})(session).trialOutcome.NSPE= NSPE';

             
    end %end session loop
end% end subj loop

%% Calculate pump onset times (reward delivery)
% While we don't have TTL pulses for pump on, we know when the animal
% enters the port and we know the delay between PE and pump oon, so we can
% calculate pump onset

%This section relies on coding of subjDataAnalyzed.trialOutcome
%1= PE , 2= no PE, 3= in port at cue onset

%   However, we don't have a TTL for pump on. I think the most simple
    %way to address this is to create a new event type in Matlab for
    %Pump on and calculate it on a trial by trial basis in this script.
    %Then, we can go to the stage 8 data specifically and subtract
    %the artificial delays
    
    
    for subj = 1:numel(subjects)
        currentSubj= subjData.(subjects{subj});
        currentSubjAnalyzed= subjDataAnalyzed.(subjects{subj});
        
        for session= 1:numel(currentSubj)

            peTrial= []; noPEtrial= []; inPortTrial= []; %clear between sessions
            currentSubjAnalyzed(session).reward.pumpOnTime= nan(size(currentSubj(session).DS));
            
           if currentSubj(session).trainStage<=5 %for stages 1:5, no delay between first PE and pump o     
                PEtrial=find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==1); %if this is a PE trial, reward delivered @ first PE
                for thisTrial= 1:numel(PEtrial) %have to loop through this because subjDataAnalyzed.behavior.poxDS is cell array and there doesn't seem to be an easier way to get the 1st value from each cell vectorized
                    currentSubjAnalyzed(session).reward.pumpOnTime(PEtrial(thisTrial))= currentSubjAnalyzed(session).behavior.poxDS{PEtrial(thisTrial)}(1); %pump onset = first port entry during DS
                end
                
                noPEtrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==2);%if there was no PE, make nan
                currentSubjAnalyzed(session).reward.pumpOnTime(noPEtrial)= nan; 
                
                inPortTrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==3); %if rat was in port, pump on = cue onset
                currentSubjAnalyzed(session).reward.pumpOnTime(inPortTrial)= currentSubj(session).DS(inPortTrial);           
           end %end stage 1:5 
           
             if currentSubj(session).trainStage==6 %for stage 6, 500ms delay between first PE and pump on     
                PEtrial=find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==1); %if this is a PE trial, reward delivered @ first PE
                for thisTrial= 1:numel(PEtrial) %have to loop through this because subjDataAnalyzed.behavior.poxDS is cell array and there doesn't seem to be an easier way to get the 1st value from each cell vectorized
                    currentSubjAnalyzed(session).reward.pumpOnTime(PEtrial(thisTrial))= currentSubjAnalyzed(session).behavior.poxDS{PEtrial(thisTrial)}(1)+0.5; %pump onset = first port entry during DS + 500ms
                end
                
                noPEtrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==2);%if there was no PE, make nan
                currentSubjAnalyzed(session).reward.pumpOnTime(noPEtrial)= nan; 
                
                inPortTrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==3); %if rat was in port, pump on = cue onset
                currentSubjAnalyzed(session).reward.pumpOnTime(inPortTrial)= currentSubj(session).DS(inPortTrial)+0.5;           
            end %end stage 6
           
            if currentSubj(session).trainStage==7 %for stage 7, 1s delay between first PE and pump on     
                PEtrial=find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==1); %if this is a PE trial, reward delivered @ first PE
                for thisTrial= 1:numel(PEtrial) %have to loop through this because subjDataAnalyzed.behavior.poxDS is cell array and there doesn't seem to be an easier way to get the 1st value from each cell vectorized
                    currentSubjAnalyzed(session).reward.pumpOnTime(PEtrial(thisTrial))= currentSubjAnalyzed(session).behavior.poxDS{PEtrial(thisTrial)}(1)+1; %pump onset = first port entry during DS + 1s
                end
                
                noPEtrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==2);%if there was no PE, make nan
                currentSubjAnalyzed(session).reward.pumpOnTime(noPEtrial)= nan; 
                
                inPortTrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==3); %if rat was in port, pump on = cue onset + 1s
                currentSubjAnalyzed(session).reward.pumpOnTime(inPortTrial)= currentSubj(session).DS(inPortTrial)+1;           
           end %end stage 7
           
           %TODO: ADD DATE CONDITIONAL HERE AFTER STAGE 8 CODE FIX
           %For stage 8 sessions with compounding delays due to sequential
           %IF statements, delay between PE and pump on varies by pump
            if currentSubj(session).trainStage>=8 %for stage 8+,     

                PEtrial=find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==1); %if this is a PE trial, reward delivered @ first PE
                for thisTrial= 1:numel(PEtrial) %have to loop through this because subjDataAnalyzed.behavior.poxDS is cell array and there doesn't seem to be an easier way to get the 1st value from each cell vectorized
                    if currentSubjAnalyzed(session).reward.DSreward(PEtrial(thisTrial))==1 %if pump 1 stage 8 w errors, delay was 1s + 100ms
                       currentSubjAnalyzed(session).reward.pumpOnTime(PEtrial(thisTrial))= currentSubjAnalyzed(session).behavior.poxDS{PEtrial(thisTrial)}(1)+1+0.1; %pump onset = first port entry during DS + delay
                       
                    elseif currentSubjAnalyzed(session).reward.DSreward(PEtrial(thisTrial))==2 %if pump 2 stage 8 w errors, delay was 1s + 200ms
                           currentSubjAnalyzed(session).reward.pumpOnTime(PEtrial(thisTrial))= currentSubjAnalyzed(session).behavior.poxDS{PEtrial(thisTrial)}(1)+1+0.2; %pump onset = first port entry during DS + delay
                    
                    
                    elseif currentSubjAnalyzed(session).reward.DSreward(PEtrial(thisTrial))==3 %if pump 1 stage 8 w errors, delay was 1s + 300ms
                           currentSubjAnalyzed(session).reward.pumpOnTime(PEtrial(thisTrial))= currentSubjAnalyzed(session).behavior.poxDS{PEtrial(thisTrial)}(1)+1+0.3; %pump onset = first port entry during DS + delay
                    end
                   
                end
                
                
                noPEtrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==2);%if there was no PE, make nan
                currentSubjAnalyzed(session).reward.pumpOnTime(noPEtrial)= nan; 
                    
                    %Again, stage 8 with errors here pump on will be cue
                    %onset+delay depending on pump
                    
               inPortTrial= find(currentSubjAnalyzed(session).trialOutcome.DSoutcome==3); %if rat was in port, pump on = cue onset + delay
               for thisTrial= 1:numel(inPortTrial) %have to loop through this because subjDataAnalyzed.behavior.poxDS is cell array and there doesn't seem to be an easier way to get the 1st value from each cell vectorized
                    if currentSubjAnalyzed(session).reward.DSreward(inPortTrial(thisTrial))==1 %if pump 1 stage 8 w errors, delay was 1s + 100ms
                       currentSubjAnalyzed(session).reward.pumpOnTime(inPortTrial(thisTrial))= currentSubj(session).DS(inPortTrial(thisTrial))+1+0.1; %pump onset = first port entry during DS + delay
                    
                    elseif currentSubjAnalyzed(session).reward.DSreward(inPortTrial(thisTrial))==2 %if pump 2 stage 8 w errors, delay was 1s + 200ms
                           currentSubjAnalyzed(session).reward.pumpOnTime(inPortTrial(thisTrial))= currentSubj(session).DS(inPortTrial(thisTrial))+1+0.2; %pump onset = first port entry during DS + delay
                    
                    
                    elseif currentSubjAnalyzed(session).reward.DSreward(inPortTrial(thisTrial))==3 %if pump 1 stage 8 w errors, delay was 1s + 300ms
                           currentSubjAnalyzed(session).reward.pumpOnTime(inPortTrial(thisTrial))= currentSubj(session).DS(inPortTrial(thisTrial))+1+0.3; %pump onset = first port entry during DS + delay
                    end
                   
               end                
           end %end stage 8+
           %Now, let's calculate pump onset relative to cue onset and first PE for each trial (so we can easily plot it later)
           for cue= 1:numel(currentSubj(session).DS)
               currentSubjAnalyzed(session).reward.pumpOnDSrel(cue,1)= currentSubjAnalyzed(session).reward.pumpOnTime(cue)-currentSubj(session).DS(cue);
               if ~isempty(currentSubjAnalyzed(session).behavior.poxDS{cue})
                  currentSubjAnalyzed(session).reward.pumpOnFirstPErel(cue,1)= currentSubjAnalyzed(session).reward.pumpOnTime(cue)-currentSubjAnalyzed(session).behavior.poxDS{cue}(1);
               else 
                   currentSubjAnalyzed(session).reward.pumpOnFirstPErel(cue,1)= nan;
               end
           end %end DS loop
           
           %now save these calculations into subjDataAnalyzed struct
           subjDataAnalyzed.(subjects{subj})(session).reward.pumpOnTime= currentSubjAnalyzed(session).reward.pumpOnTime;
           subjDataAnalyzed.(subjects{subj})(session).reward.pumpOnDSrel= currentSubjAnalyzed(session).reward.pumpOnDSrel;
           subjDataAnalyzed.(subjects{subj})(session).reward.pumpOnFirstPErel= currentSubjAnalyzed(session).reward.pumpOnFirstPErel;
           
        end %end session loop
    end %end subj loop
    
%% Calculate DS PE latency
%relies on previous behavioral analyses sections
%here, we will calculate latency to enter port on every DS trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       %First, let's exclude trials where there was 1) no PE in the cue
       %epoch or 2) animal was already in the port at cue onset
        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
       
       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
                DSonset= DSselected(cue);
                firstPox = min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS{cue}); %min of poxDS= first PE after DS onset
                
                currentSubj(session).DSpeLatency(1,cue)= firstPox-DSonset;
%                  if currentSubj(session).DSpeLatency(1,cue)== 0 || currentSubj(session).DSpeLatency(1,cue)<0
%                     disp(currentSubj(session).DSpeLatency(1,cue) ) %Flag abnomal latency values
%                  end
           else %else if we want to skip over this cue, make latency nan
               currentSubj(session).DSpeLatency(1,cue) = nan;
           end               
       end %end DSselected loop
          
       subjDataAnalyzed.(subjects{subj})(session).behavior.DSpeLatency= currentSubj(session).DSpeLatency;
       
   end %end session loop
     
end %end subject loop


%% Calculate NS PE latency
%relies on previous behavioral analyses sections
%here, we will calculate latency to enter port on every NS trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       %First, let's exclude trials where there was 1) no PE in the cue
       %epoch or 2) animal was already in the port at cue onset
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that NS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
       
       
       for cue = 1:numel(NSselected)
            
           if ~isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
                NSonset= NSselected(cue);
                firstPox = min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS{cue}); %min of poxNS= first PE after NS onset
                
                currentSubj(session).NSpeLatency(1,cue)= firstPox-NSonset;
                
           else %else if we want to skip over this cue, make latency nan
               currentSubj(session).NSpeLatency(1,cue) = nan;
           end               
       end %end NSselected loop
          
       subjDataAnalyzed.(subjects{subj})(session).behavior.NSpeLatency= currentSubj(session).NSpeLatency;

   end %end session loop
     
end %end subject loop

%% Calculate DS PE ratio
%relies on previous behavioral analyses sections
%here, we will calculate DS pe ratio

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
        DSselected= currentSubj(session).DS;  

       
        %We could exclude trials where animal was already in port, but
        %won't due this because they still receive a reward and MEDPC still
        %counts it toward the ratio
%         DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        currentSubj(session).DSpeRatio= numel(DSselected(~isnan(DSselected)))/numel(currentSubj(session).DS);       
        
        
       subjDataAnalyzed.(subjects{subj})(session).behavior.DSpeRatio= currentSubj(session).DSpeRatio;

   end %end session loop
      
end %end subj loop

%% Calculate NS PE ratio
%relies on previous behavioral analyses sections
%here, we will calculate NS pe ratio

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
        NSselected= currentSubj(session).NS;  
       
        %We could exclude trials where animal was already in port, but
        %won't due this because they still receive a reward and MEDPC still
        %counts it toward the ratio
%         NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that NS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
        
   if ~isnan(currentSubj(session).NS) %if there's NS data present, calculate ratio
            currentSubj(session).NSpeRatio= numel(NSselected(~isnan(NSselected)))/numel(currentSubj(session).NS);
        else % if no NS data present, make ratio nan
            currentSubj(session).NSpeRatio= nan;
        end %end ns conditional
        
       subjDataAnalyzed.(subjects{subj})(session).behavior.NSpeRatio= currentSubj(session).NSpeRatio;
       disp(currentSubj(session).NSpeRatio);
        
   end %end session loop
      
end %end subj loop

%% ~~~Event-Triggered Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%In these sections, we will do an event-triggered analyses by extracting data 
%from the photometry traces immediately surrounding relevant behavioral events (e.g. cue onset, port entry, lick)
%To do so, we'll find the onset timestamp for each event (eventTime) and use this
%timestamp to extract photometry data surrounding it
%(preEventTime:postEventTime). This will be saved to the subjDataAnalyzed
%struct. 


%here we are establishing some variables for our event triggered-analysis
%TODO: putting this in the pox/lox id earlier also, be sure to
%remove/change that too
% periCueTime = 20;% t in seconds to examine before/after cue (e.g. 20 will get data 20s both before and after the cue) %TODO: use cue length to taper window cueLength/fs+10; %20;        
% periCueFrames = periCueTime*fs; %translate this time in seconds to a number of 'frames' or datapoints  

% % % preCueTime= 5; %t in seconds to examine before cue
% % % postCueTime=10; %t in seconds to examine after cue
% % % 
% % % preCueFrames= preCueTime*fs;
% % % postCueFrames= postCueTime*fs;
% % % 
% % % periCueFrames= preCueFrames+postCueFrames;
% % % 
% % % slideTime = 400; %define time window before cue onset to get baseline mean/stdDev for calculating sliding z scores- 400 for 10s (remember 400/40hz ~10s)


%% TIMELOCK TO DS
for subj= 1:numel(subjects) %for each subject

    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct

    %In this section, go cue-by-cue examining how fluorescence intensity changes in response to cue onset (either DS or NS)
    %Use an event-triggered sort of approach viewing data before and after cue onset where time 0 = cue onset time
    %Also, a sliding z-score will be calculated for each timepoint like in (Richard et al., 2018)- using data comprising 10s prior to that timepoint as a baseline  
    
    disp(strcat('running DS-triggered analysis subject_',  subjects{subj}));

        
    for session = 1:numel(currentSubj) %for each training session this subject completed              
        clear cutTime  %this is cleared between sessions to prevent spillover
       
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

        for cue=1:length(currentSubj(session).DS) %DS CUES %For each DS cue, conduct event-triggered analysis of data surrounding that cue's onset

            %each entry in DS is a timestamp of the DS onset 
            DSonset = find(cutTime==currentSubj(session).DSshifted(cue,1));

            %define the frames (datapoints) around each cue to analyze
            preEventTimeDS = DSonset-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTimeDS = DSonset+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTimeDS< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to beginning, continuing'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTimeDS> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to end, continuing'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %blueA
            baselineMeanblue=nanmean(currentSubj(session).reblue((DSonset-slideTime):DSonset)); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue=std(currentSubj(session).reblue((DSonset-slideTime):DSonset)); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple=nanmean(currentSubj(session).repurple((DSonset-slideTime):DSonset)); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple=std(currentSubj(session).repurple((DSonset-slideTime):DSonset)); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDS.DS(cue) = currentSubj(session).DS(cue); %this way only included cues are saved

            subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeDS:postEventTimeDS);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeDS:postEventTimeDS))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeDS:postEventTimeDS))- baselineMeanpurple))/(baselineStdpurple);

            
            %dff - *******Relies upon previous photobleaching/baseline section
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSbluedff(:,:,cue)= subjDataAnalyzed.(subjects{subj})(session).photometry.bluedff(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurpledff(:,:,cue)= subjDataAnalyzed.(subjects{subj})(session).photometry.purpledff(preEventTimeDS:postEventTimeDS);

% %%~~~~~~~~~~~~~~~~exclude VP-VTA-FP08 session 21 DS cue 17 (came unplugged, big outlier)~~~~~!!!
%     
%             if subj == 1 && session==21 && cue == 17
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue(:,:,cue) = nan;
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple(:,:,cue) = nan;
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue(:,:,cue) = nan;
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple(:,:,cue) = nan;
%             end
            
        
            %lets save the baseline mean and std used for z score calc- so
            %that we can use this same baseline for other analyses
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue)= baselineMeanblue;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue)= baselineStdblue;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue)= baselineMeanpurple;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue)= baselineStdpurple;

            %save timeLock time axis
            subjDataAnalyzed.(subjects{subj})(session).periDS.timeLock= [-preCueFrames:postCueFrames]/fs;

            
        end %end DS cue loop
        
                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple, 3);
                        
        
   end %end session loop
end %end subject loop
        
%% TIMELOCK TO NS
    %Same approach as above, but for NS; done a bit differently because not every session will have the NS
        disp(strcat('running NS-triggered analysis subject_',  subjects{subj}));

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct

       clear cutTime  %this is cleared between sessions to prevent spillover
       
       cutTime= currentSubj(session).cutTime; %save this as an array, immensely speeds things up because we have to go through each timestamp to find the closest one to the cues

  
      NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

%       disp(strcat('running NS-triggered analysis subject ', num2str(subj), '/', num2str(numel(subjects)), ' session ', num2str(session), '/', num2str(numel(currentSubj))));

      if isnan(currentSubj(session).NS)  %If there's no NS present, save data as empty arrays
          
        subjDataAnalyzed.(subjects{subj})(session).periNS.NS = [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple=[]; 

        %get the mean response to the DS for this session
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean= [];
        
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSbluedff= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpledff= [];


      else %if the NS is present on this session, do the analysis and save results

            for cue=1:length(currentSubj(session).NS) %NS CUES %For each NS cue, conduct event-triggered analysis of data surrounding that cue's onset
                
                NSonset = find(cutTime==currentSubj(session).NSshifted(cue,1)); %get the corresponding cutTime index of the NS timestamp


                %define the frames (datapoints) around each cue to analyze
                preEventTimeNS = NSonset-preCueFrames; %earliest timepoint to examine is the shifted NS onset time - the # of frames we defined as periCueFrames (now this is equivalent to 20s before the shifted cue onset)
                postEventTimeNS = NSonset+postCueFrames; %latest timepoint to examine is the shifted NS onset time + the # of frames we defined as periCueFrames (now this is equivalent to 20s after the shifted cue onset)

               if NSonset-slideTime< 1 %If cue is too close to beginning, skip over it
                  disp(strcat('****NS cue ', num2str(cue), ' too close to beginning, continuing'));
                  NSskipped= NSskipped+1;%iterate the counter for skipped NS cues
                  continue%continue out of the loop and move onto the next NS cue
                end

               if postEventTimeNS> length(currentSubj(session).cutTime)-slideTime %if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                  disp(strcat('****NS cue ', num2str(cue), ' too close to end, continuing'));
                  NSskipped= NSskipped+1;  %iterate the counter for skipped NS cues
                  continue %continue out of the loop and move onto the next NS cue
               end

                % Calculate average baseline mean&stdDev 10s prior to DS for z-score
                %blueA
                baselineMeanblue=nanmean(currentSubj(session).reblue((NSonset-slideTime):NSonset)); %baseline mean blue 10s prior to DS onset for boxA
                baselineStdblue=std(currentSubj(session).reblue((NSonset-slideTime):NSonset)); %baseline stdDev blue 10s prior to DS onset for boxA
                %purpleA
                baselineMeanpurple=nanmean(currentSubj(session).repurple((NSonset-slideTime):NSonset)); %baseline mean purple 10s prior to DS onset for boxA
                baselineStdpurple=std(currentSubj(session).repurple((NSonset-slideTime):NSonset)); %baseline stdDev purple 10s prior to DS onset for boxA

                %save the data in the subjDataAnalyzed struct under the periNS field
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NS(cue)= currentSubj(session).NS(cue); %this way only analyzed cues are included
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeNS:postEventTimeNS);
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeNS:postEventTimeNS);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeNS:postEventTimeNS);
                    %z score calculation
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeNS:postEventTimeNS))-baselineMeanblue))/(baselineStdblue);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeNS:postEventTimeNS))- baselineMeanpurple))/(baselineStdpurple);

                     %dff - *******Relies upon previous photobleaching/baseline section
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSbluedff(:,:,cue)= (subjDataAnalyzed.(subjects{subj})(session).photometry.bluedff(preEventTimeNS:postEventTimeNS));
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpledff(:,:,cue)= (subjDataAnalyzed.(subjects{subj})(session).photometry.purpledff(preEventTimeNS:postEventTimeNS));

                %lets save the baseline mean and std used for z score calc- so
                %that we can use this same baseline for other analyses
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue)= baselineMeanblue;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue)= baselineStdblue;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue)= baselineMeanpurple;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue)= baselineStdpurple;
                
                
            end % end NS cue loop
            
      end %end if NS ~nan conditional 
      
                %get the mean response to the NS for this session
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue, 3);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple, 3);
              

      
   end %end session loop
end %end subject loop


%% Calculate shifted timestamps for licks relative to PE (for timelocking to PE)
% Since we know the PE latency for each trial and have timestamps for licks
% relative to cue onset, we calculate timestamps for licks relative to PE
% as loxRel-PElatency

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj}); 
    for session= 1:numel(currentSubj)
        DSloxCount=0; %counter to tell if licks happened during any cues- if not, make empty
        NSloxCount= 0;

        
        for cue = 1:numel(currentSubj(session).behavior.loxDSrel) %for each DS trial in this session
                       
            if ~isempty(currentSubj(session).behavior.loxDSrel{cue}) %only run if valid data present
               currentSubj(session).behavior.loxDSpoxRel{cue}= currentSubj(session).behavior.loxDSrel{cue}-currentSubj(session).behavior.DSpeLatency(cue); %loxDSpoxRel = timestamp of lick relative to PE 
               DSloxCount=DSloxCount+1;
            end
        end
    
        for cue = 1:numel(currentSubj(session).behavior.loxNSrel) %for each NS trial in this session
            if ~isempty(currentSubj(session).behavior.loxNSrel{cue}) %only run if valid data present
               currentSubj(session).behavior.loxNSpoxRel{cue}= currentSubj(session).behavior.loxNSrel{cue}-currentSubj(session).behavior.NSpeLatency(cue); %loxNSpoxRel = timestamp of lick relative to PE 
               NSloxCount= NSloxCount+1;
            end
        end
        
        %save the data
        if DSloxCount >0
                subjDataAnalyzed.(subjects{subj})(session).behavior.loxDSpoxRel= currentSubj(session).behavior.loxDSpoxRel;
        else 
            subjDataAnalyzed.(subjects{subj})(session).behavior.loxDSpoxRel= [];
        end
        
        if NSloxCount >0
            subjDataAnalyzed.(subjects{subj})(session).behavior.loxNSpoxRel= currentSubj(session).behavior.loxNSpoxRel;
        else
            subjDataAnalyzed.(subjects{subj})(session).behavior.loxNSpoxRel=[];
        end
    end % end session loop

end% end subj loop


%% TIMELOCK TO FIRST PE AFTER DS (when sucrose should be dispensed)
%DS trials where animal was in port at cue onset are excluded

disp('conducting peri-DSpox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
               
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstPox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstPox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstPox = interp1(cutTime,cutTime, firstPox, 'nearest');

                %get the index of this timestamp in cutTime
                firstPoxind= find(cutTime==firstPox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstPoxind-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstPoxind+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstPoxdS ', num2str(cue), ' too close to beginning, continueing out'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****firstPoxDS cue ', num2str(cue), ' too close to end, continueing out'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                DSselected(cue)= nan; %make this cue nan so that it's skipped in subsequent analysis
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSselected= DSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);
 
           elseif isnan(DSselected(cue)) %if there are no valid licks this session(e.g. on extinction days), make nan (otherwise might skip & fill in with 0s)
               subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSselected(cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue(1:periCueFrames+1,1,cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple(1:periCueFrames+1,1,cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue(1:periCueFrames+1,1,cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple(1:periCueFrames+1,1,cue)= nan;
           end
       
        end%end DSselected loop
            %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple, 3);
                      
   end %end session loop
end %end subject loop


%% TIMELOCK TO FIRST PE AFTER NS (no sucrose)


disp('conducting peri-NSpox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

       if ~isempty(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS) %can only run for sessions that have NS data
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(NSselected)
            
           if isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch, but save empty arrays
               
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue(1:periCueFrames+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple(1:periCueFrames+1,1,cue)= nan;

                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue(1:periCueFrames+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple(1:periCueFrames+1,1,cue)= nan;
% 
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSselected= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple= [];
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblueMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurpleMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblueMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurpleMean(1:periCueFrames+1,1,cue) = nan;
                
           else %if this is a selected NS
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstPox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstPox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstPox = interp1(cutTime,cutTime, firstPox, 'nearest');

                %get the index of this timestamp in cutTime
                firstPoxind= find(cutTime==firstPox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstPoxind-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstPoxind+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstPoxNS ', num2str(cue), ' too close to beginning, continueing out'));
                NSskipped= NSskipped+1;
            continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
            disp(strcat('****firstPoxDS cue ', num2str(cue), ' too close to end, continueing out'));
            NSskipped= NSskipped+1;  %iterate the counter for skipped DS cues
            continue %continue out of the loop and move onto the next DS cue
            end

              % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periNS field

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSselected= NSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);
 
           end
       
       end %end NSselected loop
       end %end NS conditional
       
                 %get the mean response to the NS for this session
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple, 3);
       
   end %end session loop
end %end subject loop


%% TIMELOCK TO FIRST LICK AFTER DS 
%DS trials where animal was in port at cue onset are excluded

disp('conducting peri-DS first lox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.loxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.loxDS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
               
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstLox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.loxDS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstLox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstLox = interp1(cutTime,cutTime, firstLox, 'nearest');

                %get the index of this timestamp in cutTime
                firstLoxind= find(cutTime==firstLox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstLoxind-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstLoxind+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstLoxdS ', num2str(cue), ' too close to beginning, continueing out'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****firstLoxDS cue ', num2str(cue), ' too close to end, continueing out'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSselected= DSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);
             
           
           
           elseif isnan(DSselected(cue)) %if there are no valid licks this session(e.g. on extinction days), make nan (otherwise might skip & fill in with 0s)
               subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSselected(cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxblue(1:periCueFrames+1,1,cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxpurple(1:periCueFrames+1,1,cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxblue(1:periCueFrames+1,1,cue)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxpurple(1:periCueFrames+1,1,cue)= nan;
           end
            
        end %end DSselected loop

            %get the mean response to the DS for this session
        subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

        subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSloxpurple, 3); 

        subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxblue, 3);

        subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDSlox.DSzloxpurple, 3);

       
   end %end session loop
end %end subject loop

%% TIMELOCK TO FIRST LICK AFTER NS (no sucrose)


disp('conducting peri-NS lox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

       if ~isempty(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS) %can only run for sessions that have NS data
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.loxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(NSselected)
            
           if isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch, but save empty arrays
               
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxblue(1:periCueFrames+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxpurple(1:periCueFrames+1,1,cue)= nan;

                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxblue(1:periCueFrames+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxpurple(1:periCueFrames+1,1,cue)= nan;
% 
%                 subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSselected= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxpurple= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxpurple= [];
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxblueMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxpurpleMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxblueMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxpurpleMean(1:periCueFrames+1,1,cue) = nan;
                
           else %if this is a selected NS
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstLox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstLox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstLox = interp1(cutTime,cutTime, firstLox, 'nearest');

                %get the index of this timestamp in cutTime
                firstLoxind= find(cutTime==firstLox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstLoxind-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstLoxind+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstLoxNS ', num2str(cue), ' too close to beginning, continueing out'));
                NSskipped= NSskipped+1;
            continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
            disp(strcat('****firstLoxDS cue ', num2str(cue), ' too close to end, continueing out'));
            NSskipped= NSskipped+1;  %iterate the counter for skipped DS cues
            continue %continue out of the loop and move onto the next DS cue
            end

              % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periNS field

            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSselected= NSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);
 
           end
       
       end %end NSselected loop
       end %end NS conditional
       
                 %get the mean response to the NS for this session
            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSloxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSlox.NSzloxpurple, 3);
       
   end %end session loop
end %end subject loop

%% Create arbitrary trial start times (helps deconvolution)
% we want to introduce some variability into cue onset on a trial-by-trial basis
% to do so, let's sample trial start times from a normal distribution of
% time before cue and then shift the cue/PE/lick event timestamps
% accordingly... we'll need to timelock to the trial start time (done in next section) in order to
% get correct photometry signals

%create a distribution of times to sample from
trialStartDistro= makedist('Normal', 'mu', 0, 'sigma', 1); %time in seconds

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
   for session = 1:numel(currentSubj)
       trialStart= [];
       trialTimeShift= [];
       cutTime= subjData.(subjects{subj})(session).cutTime;
       for cue = 1:numel(currentSubj(session).periDS.DS)
           %randomly sample trialStart ; abs() so only + values... these
           %will be subtracted from cue onset time to give trialStart time
           %& this shift will also be applied to events during trial to
           %match up timestamps of photometry signal accordingly
           trialTimeShift(:,cue)= abs(random(trialStartDistro,1));%random(trialStartDistro,1);
           
           %subtract trialStart from actual cue onset timestamp
           trialStart(:,cue)= currentSubj(session).periDS.DS(cue)- trialTimeShift(:,cue);
       end
            %match trial start timestamp to a valid timestamp in cutTime
            trialStart = interp1(cutTime,cutTime, trialStart, 'nearest');


%       hist(trialStart); %visualize sampling from distro
      subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialTimeShift= trialTimeShift;%+ amount of time shifted
      subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialStart= trialStart;%timestamp of trial start (randomly sampled from trialStartDistro defined above)
          
   end
end


%% TIMELOCK TO TRIAL START
%get photometry signals timelocked to trialStart to correctly map shifted
%event timestamps 

 for subj= 1:numel(subjects) %for each subject

    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
    currentSubjAnalyzed= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing into the curret subject within the struct

    
    disp(strcat('running trialStart-triggered analysis subject_',  subjects{subj}));
        
    for session = 1:numel(currentSubj) %for each training session this subject completed              
        clear cutTime  %this is cleared between sessions to prevent spillover
       
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

        for trial=1:length(currentSubjAnalyzed(session).periDS.trialShift.trialStart) %loop through DS trials
                       
            %each entry in DS is a timestamp of the DS onset 
            trialStartInd = find(cutTime==currentSubjAnalyzed(session).periDS.trialShift.trialStart(trial));

            %define the frames (datapoints) around each cue to analyze
            preEventTimeDS = trialStartInd-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTimeDS = trialStartInd+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTimeDS< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****DS trial ', num2str(trial), ' too close to beginning, continuing'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTimeDS> length(cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****DS trial ', num2str(trial), ' too close to end, continuing'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

             % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity %TODO: maybe baseline& std for z score
            %should be based off of trialStart?
            %blueA
            baselineMeanblue= currentSubjAnalyzed(session).periDS.baselineMeanblue(1,trial); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= currentSubjAnalyzed(session).periDS.baselineStdblue(1,trial); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= currentSubjAnalyzed(session).periDS.baselineMeanpurple(1,trial); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= currentSubjAnalyzed(session).periDS.baselineStdpurple(1,trial); %baseline stdDev purple 10s prior to DS onset for boxA
            
            %calculate shifted timestamps for events during trial so that
            %they match up with photometry signals
            %save all of the following data in the subjDataAnalyzed struct under the periDS.trislShift field

            %shift cue timestamp
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.DSrelShifted(trial) = abs(currentSubjAnalyzed(session).periDS.trialShift.trialTimeShift(trial)); %0 + amount shifted; this is cue onset relative to trial start
 

            %shift behavior event timestamps according to trialShift
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.poxDSrelTrialShifted{trial}= currentSubjAnalyzed(session).behavior.poxDSrel{trial} + currentSubjAnalyzed(session).periDS.trialShift.trialTimeShift(trial);
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.loxDSrelTrialShifted{trial}= currentSubjAnalyzed(session).behavior.loxDSrel{trial} + currentSubjAnalyzed(session).periDS.trialShift.trialTimeShift(trial);

%  currentSubjAnalyzed(session).behavior.poxDS{trial}
%             currentSubjAnalyzed(session).periDS.trialShift.poxDSshifted{trial}= currentSubjAnalyzed(session).behavior.poxDS{trial} - currentSubjAnalyzed(session).periDS.trialShift.trialTimeShift(trial); %~ may want to do abs pox/lox instead of rel
%  currentSubjAnalyzed(session).periDS.trialShift.poxDSshifted{trial}
%             
%             currentSubjAnalyzed(session).periDS.trialShift.poxDSrelTrialShifted{trial}= currentSubjAnalyzed(session).periDS.trialShift.poxDSshifted{trial} - currentSubjAnalyzed(session).periDS.trialShift.DSshifted(trial);
%  
% %             currentSubjAnalyzed(session).periDS.trialShift.poxDSrelTrialShifted{trial}= currentSubjAnalyzed(session).behavior.poxDSrel{trial} - currentSubjAnalyzed(session).periDS.trialShift.trialTimeShift(trial); %~ may want to do abs pox/lox instead of rel
%             currentSubjAnalyzed(session).periDS.trialShift.loxDSrelTrialShifted{trial}= currentSubjAnalyzed(session).behavior.loxDSrel{trial} - currentSubjAnalyzed(session).periDS.trialShift.trialTimeShift(trial);
%             
%                 %match to nearest valid timestamp in cutTime      
% %                 currentSubjAnalyzed(session).periDS.trialShift.poxDSshifted{trial}= interp1(cutTime,cutTime, currentSubjAnalyzed(session).periDS.trialShift.poxDSshifted{trial}, 'nearest');
% currentSubjAnalyzed(session).periDS.trialShift.poxDSshifted{trial}

%                 currentSubjAnalyzed(session).periDS.trialShift.poxDSrelTrialShifted{trial}= interp1(cutTime,cutTime, currentSubjAnalyzed(session).periDS.trialShift.poxDSrelTrialShifted{trial}, 'nearest');
%                 currentSubjAnalyzed(session).periDS.trialShift.loxDSrelTrialShifted{trial} = interp1(cutTime,cutTime, currentSubjAnalyzed(session).periDS.trialShift.loxDSrelTrialShifted{trial}, 'nearest');
            
            %photometry signals
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftWindow(:,:,trial)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftDSblue(:,:,trial)= currentSubj(session).reblue(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftDSpurple(:,:,trial)= currentSubj(session).repurple(preEventTimeDS:postEventTimeDS);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
           subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftDSzblue(:,:,trial)= (((currentSubj(session).reblue(preEventTimeDS:postEventTimeDS))-baselineMeanblue))/(baselineStdblue); 
           subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftDSzpurple(:,:,trial)= (((currentSubj(session).repurple(preEventTimeDS:postEventTimeDS))- baselineMeanpurple))/(baselineStdpurple);

            
            %dff - *******Relies upon previous photobleaching/baseline section
           subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftDSbluedff(:,:,trial)= currentSubjAnalyzed(session).photometry.bluedff(preEventTimeDS:postEventTimeDS);
           subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftDSpurpledff(:,:,trial)= currentSubjAnalyzed(session).photometry.purpledff(preEventTimeDS:postEventTimeDS);


            %save timeLock time axis
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.trialShiftTimeLock= [-preCueFrames:postCueFrames]/fs;
            
            %Flag event timestmap shifts that have too large of a difference (>1/fs)... 
            % if the difference is smaller than this then the timstamp will be the same (due to downsampling)
            if subjDataAnalyzed.(subjects{subj})(session).behavior.poxDSrel{trial}-subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.poxDSrelTrialShifted{trial} > 1/fs
               disp(strcat(' ~~~~~warning, pox trialShift too big: subj_',num2str(subj),';session_', num2str(session), ';trial_', num2str(trial))); 
            end

            if subjDataAnalyzed.(subjects{subj})(session).behavior.loxDSrel{trial}-subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.loxDSrelTrialShifted{trial} > 1/fs
               disp(strcat(' ~~~~~warning, lox trialShift too big: subj_',num2str(subj),';session_', num2str(session), ';trial_', num2str(trial))); 
            end

        end %end DS cue loop
        
                %get the mean response during DS trial for this session
            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.DSblueMean = nanmean(currentSubjAnalyzed(session).periDS.DSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.DSpurpleMean = nanmean(currentSubjAnalyzed(session).periDS.DSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.DSzblueMean = nanmean(currentSubjAnalyzed(session).periDS.DSzblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.DSzpurpleMean = nanmean(currentSubjAnalyzed(session).periDS.DSzpurple, 3);     
        
   end %end session loop
end %end subject loop
        

% %% visualize side by side timelock to cue,pe,lick, trial
% for subj= 1:numel(subjects)
%     timeLock= [-preCueFrames:postCueFrames]/fs;
%     currentSubj= subjDataAnalyzed.(subjects{subj});
%     for session= 1:numel(currentSubj)
%         if currentSubj(session).trainStage== 7 %plot only certain sessions
%         figure; sgtitle(strcat('subj_',subjects{subj}))
%         subplot(4,1,1); hold on; title('timelock to CUE');
% %         plot(timeLock, squeeze(currentSubj(session).periDS.DSzblue), 'b');
%         plot(timeLock, currentSubj(session).periDS.DSzblueMean, 'b');
%         subplot(4,1,2); hold on; title('timelock to first PE');
% %         plot(timeLock,squeeze(currentSubj(session).periDSpox.DSzpoxblue), 'b');
%         plot(timeLock, currentSubj(session).periDSpox.DSzpoxblueMean, 'b');
%         subplot(4,1,3); hold on; title('timelock to first lick');
% %         plot(timeLock,squeeze(currentSubj(session).periDSpox.DSzpoxblue), 'b');
%         plot(timeLock, currentSubj(session).periDSlox.DSzloxblueMean, 'b');
%         subplot(4,1,4); hold on; title('timelock to trial start');
%         plot(timeLock, currentSubj(session).periDS.trialShift.DSzblueMean, 'b');
%         end
%     end% end session loop
% end%end subj loop

 subjectsAnalyzed = fieldnames(subjDataAnalyzed); %now, let's save an array containing all of the analyzed subject IDs (may be useful later if we decide to exclude subjects from analysis)
%% ~~~Individual subjects peri-event plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Establish common date axis across subjects
%since training day may vary between subjects, we want to eventually arrange
%all these data by the actual recording date. If a subject did not run a
%session on a date we should be able to make values on this date nan later 

%this section will simply collect all of the unique recording dates from
%all subjects into an array (allDates)

for subj= 1:numel(subjectsAnalyzed) %for each subject analyzed
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

    for session = 1:numel(currentSubj) %for each training session this subject completed
       
%       So save the dates in a cell array
        allDates(session,subj) = currentSubj(session).date;
%         allDates(session)= currentSubj(session).date;
%                 
    end %end session loop
   
end

    %remove invalid dates (empty sessions were filled with zero, let's make
    %these empty)
    allDates(allDates==0) = [];
    
    %retain only unique dates 
    allDates= unique(allDates); 
    
    
%% HEAT PLOT OF AVG RESPONSE TO CUE (by session)

%Here, we'll make a figure for each subject with 4 subplots based on avg daily 
%response to cue- Avg blue z score response to DS, Avg blue z score response 
%to NS, Avg purple z score response to DS, Avg purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots
%first, we need to collect the avg cue response from all sessions and reshape for plotting

for subj= 1:numel(subjectsAnalyzed) %for each subject analyzed
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    %DS - extract data for plots
    %avg cue response sorted by trial, timelocked to DS
    
    subjDates= zeros(1,numel(allDates));
    emptyDates= [];
    
    timeLock= [-preCueFrames:postCueFrames]/fs;
     
    %First find out which dates this subj has data for
    %get all dates for this subj
    for session= 1:numel(currentSubj)
        subjDates(session)= currentSubj(session).date;
    end %end session loop
    
    %now find out which dates from allDates this subj has data for 
    for thisDate = 1:numel(allDates) %loop through all dates
        if isempty(subjDates(subjDates==allDates(thisDate))) %if this subj doesn't have valid data on this date
%                 emptyDates= cat(1, emptyDates,thisDate); %save this empty date to an array (add onto array by using cat())
                currentSubj(end+1).date= allDates(thisDate); %use end+1 to add a new empty session
                
                %fill relevant fields with NaN for later 
                currentSubj(end).periDS.DSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periDS.DSzpurpleMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzpurpleMean= NaN(size(timeLock'));

        end
    end
    
    %now let's resort the struct with empty sessions by date
     subjTable = struct2table(currentSubj); % convert the struct array to a table
     subjTableSorted = sortrows(subjTable, 'date'); % sort the table by 'date'
     currentSubj = table2struct(subjTableSorted); %convert back to struct

    
    %now get the actual photometry data
    for session = 1:numel(currentSubj) %for each training session this subject completed       
            if session ==1 %for the first session, get this sessions periDS blue z score response
                        currentSubj(1).DSzblueSessionMean= currentSubj(session).periDS.DSzblueMean; 
                        currentSubj(1).DSzpurpleSessionMean= currentSubj(session).periDS.DSzpurpleMean;
                else % add on periDS response for subsequent sessions
                        currentSubj(1).DSzblueSessionMean= cat(2, currentSubj(1).DSzblueSessionMean, currentSubj(session).periDS.DSzblueMean);
                        currentSubj(1).DSzpurpleSessionMean= cat(2, currentSubj(1).DSzpurpleSessionMean, currentSubj(session).periDS.DSzpurpleMean);
            end
    end %end session loop
 
    
    %Transpose for readability
    currentSubj(1).DSzblueSessionMean= currentSubj(1).DSzblueSessionMean';
    currentSubj(1).DSzpurpleSessionMean= currentSubj(1).DSzpurpleSessionMean';

    %get list of session days for heatplot y axis (transposed for readability)
%     subjTrial= cat(2, currentSubj.trainDay).'; %this is only training days for this subj
    subjTrial= 1:numel(allDates); %let's just number each training day starting at 1

    %NS- extract data for plots
    %session axis (Y) is handled a bit differently because we only want to show sessions that have NS cues
    
    %photometry signals sorted by trial, timelocked to NS
    
    for session = 1:numel(currentSubj) %for each training session this subject completed
        %if there's no NS data, fill with NaNs first
        if isempty(currentSubj(session).periNS.NSzblueMean)
            currentSubj(session).periNS.NSzblueMean= NaN(size(timeLock'));
            currentSubj(session).periNS.NSzpurpleMean= NaN(size(timeLock'));
        end
        
        if session ==1 %for the first session, get this sessions periDS blue z score response
                currentSubj(1).NSzblueSessionMean= currentSubj(session).periNS.NSzblueMean; 
                currentSubj(1).NSzpurpleSessionMean= currentSubj(session).periNS.NSzpurpleMean;
        else % add on periDS response for subsequent sessions
                currentSubj(1).NSzblueSessionMean= cat(2, currentSubj(1).NSzblueSessionMean, currentSubj(session).periNS.NSzblueMean);
                currentSubj(1).NSzpurpleSessionMean= cat(2, currentSubj(1).NSzpurpleSessionMean, currentSubj(session).periNS.NSzpurpleMean);
        end

    end %end session loop
    
    
    %Transpose for readability
    currentSubj(1).NSzblueSessionMean= currentSubj(1).NSzblueSessionMean';
    currentSubj(1).NSzpurpleSessionMean= currentSubj(1).NSzpurpleSessionMean';
   
    %get list of session days for heatplot y axis
%     subjTrialNS=[]; %keep track of sessions that have valid NS trials
%     dateNS= [];
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%         if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
% %              subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay); %old method based on trainDay
%                 dateNS= cat(2, dateNS, currentSubj(session).date);
%         end
%     end %end session loop
%     
%     %search NS dates for the appropriate index in allDates, then label it
%     %similar to subjTrial
%     for thisDate = 1:numel(dateNS) 
%         subjTrialNS(thisDate)= find(allDates==dateNS(thisDate)); %returns the index in allDates that matches the date of this NS session
%     end
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
    
     %define DS color axes
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
     topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
        topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
        bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomMeanShared= bottomAllDS;
        topMeanShared= topAllDS;
    end
    
    
    %Heatplots!       
    %DS z plot
    figure(figureCount);
    hold on;
    subplot(2,2,1); %subplot for shared colorbar

    %plot blue DS

    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatDSzblueMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzblueSessionMean, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg blue z score response surrounding DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzpurpleSessionMean,  'AlphaData', ~isnan(currentSubj(1).DSzpurpleSessionMean)); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg purple z score response surrounding DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
    

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving




    %     %NS z plot
    hold on;
    subplot(2,2,2); %subplot for shared colorbar

    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatNSzblueMean= imagesc(timeLock,subjTrial,currentSubj(1).NSzblueSessionMean, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), 'avg blue z score response to NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple NS (subplotted for shared colorbar)
    subplot(2,2,4);
    heatNSzpurpleMean= imagesc(timeLock,subjTrial,currentSubj(1).NSzpurpleSessionMean, 'AlphaData', ~isnan(currentSubj(1).NSzpurpleSessionMean)); 

    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), ' avg purple z score response to NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
    saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZSessionAvg','.fig')); %save the current figure in fig format
    figureCount=figureCount+1; %iterate the figure count

    
%     % 2D plot of cue response from all sessions
%          figure(figureCount);
%          figureCount=figureCount+1;
%        
%          subplot(1,2,1) %DS
%          title('DS session avgs');
%           hold on;
%           plot(timeLock,currentSubj(1).DSzblueSessionMean, 'b');
%           plot(timeLock,currentSubj(1).DSzpurpleSessionMean, 'm');
%           
%           subplot(1,2,2) %NS
%           hold on;
%           title('NS session avgs');
%           plot(timeLock,currentSubj(1).NSzblueSessionMean, 'b');
%           plot(timeLock,currentSubj(1).NSzpurpleSessionMean, 'm');
%           set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
    
     %plot of mean response during each session; keypress advances thru sessions
              
          figure(figureCount);
     
         for session= 1:numel(currentSubj)
             subplot(1,2,1) %DS
             title('DS session avgs');
              hold on;
              plot(timeLock,currentSubj(1).DSzblueSessionMean(session,:), 'b');
              plot(timeLock,currentSubj(1).DSzpurpleSessionMean(session,:), 'm');

              subplot(1,2,2) %NS
              hold on;
              title('NS session avgs');
              plot(timeLock,currentSubj(1).NSzblueSessionMean(session,:), 'b');
              plot(timeLock,currentSubj(1).NSzpurpleSessionMean(session,:), 'm');
              set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
              
%               waitforbuttonpress;
%               cla;
         end %end session loop
     
           figureCount=figureCount+1;


end %end subject loop
    
%% HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION- sorted by trial 

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS, blue z score response to NS, purple z score response to
%DS, purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    sesCount= 1; %counter to keep track of sessions that meet a condition (e.g. if you only want to look at stage 5 sessions
    for session = 1:numel(currentSubj) %for each training session this subject completed
%         if currentSubj(session).trainStage == 5
%         if currentSubj(session).trainStage== 1 || currentSubj(session).trainStage ==2 || currentSubj(session).trainStage==3
        %collect all z score responses to every single DS across all sessions
            if sesCount==1 %for first session, initialize 
                currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

                currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
                currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

                currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
                currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 
            end
        sesCount=sesCount+1;   

    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
%      %overlay plot of transitions between training stages - TODO: this
%      %stopped working after stage 6 I think
%     transitionCue= [];
%     transitionDay=[];
%     
%     cueCount = 1;
%     
%     stageCount= 1;
%     
%     for session= 1:numel(currentSubj)
%        
%        if session ==1 
%            trainStage = currentSubj(session).trainStage;
%        end
%         
%        if currentSubj(session).trainStage ~= trainStage
%            %if the trainStage changes, save this day as a transision
%            trainStage = currentSubj(session).trainStage;
%            
%            %iterate stageCount
%            stageCount=stageCount+1
%            transitionDay(stageCount) = currentSubj(session).trainDay;
%            
% %            disp(strcat('transition day ', num2str(transitionDay(session))));
%            
%            %since we are plotting individual trials and not days, 
%            %find the cue corresponding to the transition
%            %to do so,loop over all cues in the session, finding the
%            %matching saved to DSzblueAllTrials
%            for cue = 1:numel(currentSubj(session).periDS.DS) %for each cue in this session
%                 cueCount=cueCount+1;                                
%                 if find(currentSubj(1).DSzblueAllTrials'==currentSubj(session).periDS.DSzblue(:,:,cue),1)% currentSubj(1).DSzblueAllTrials(cue,:)' == currentSubj(session).periDS.DSzblue(:,:,cue)
%                     
% %                     [~, cueInd] =  find(currentSubj(1).DSzblueAllTrials'==currentSubj(session).periDS.DSzblue(:,:,cue),1);
%                     transitionCue(stageCount)= cueCount;
%                 end
%            end
% %            disp(strcat('transition Cue', num2str(transitionCue(session))))
%        end %end stage transition conditional
%     end %end session loop
%  
%     
%     for i= 1:numel(transitionCue)
%         if transitionCue(i) ~= 0
%             subplot(2,2,1) %DS blue
%             hold on;
%             plot([timeLock(1), timeLock(end)], [transitionCue(i), transitionCue(i)], 'k--')  
%             
%             subplot(2,2,3) %DS puprle
%             hold on;
%             plot([timeLock(1), timeLock(end)], [transitionCue(i), transitionCue(i)], 'k--')
%             
%         end
%     end
%        
    figureCount= figureCount+1;
    
    
    %2d plot to see magnitude
    
    figure;
    figureCount= figureCount+1;
    subplot(2,1,1);
    title('DS');
    hold on;
    plot(timeLock,currentSubj(1).DSzblueAllTrials, 'b');
    plot(timeLock,currentSubj(1).DSzpurpleAllTrials, 'm');
    if ~isempty(currentSubj(1).NSzblueAllTrials)
        subplot(2,1,2);
        title('NS');
        hold on;
        plot(timeLock,currentSubj(1).NSzblueAllTrials, 'b');
        plot(timeLock,currentSubj(1).NSzpurpleAllTrials, 'm');
    end
end %end subject loop


%% LATENCY SORTED HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION

%Same as before, but now sorted by PE latency

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

        %initialize arrays for convenience
        currentSubj(1).NSzblueAllTrials= [];
        currentSubj(1).NSzpurpleAllTrials= [];
        currentSubj(1).NSpeLatencyAllTrials= [];

    for session = 1:numel(currentSubj) %for each training session this subject completed
       
        clear NSselected
        
        %We can only include trials that have a PE latency, so we need to
        %selectively extract these data first
        
            %get the DS cues
        DSselected= currentSubj(session).periDS.DS;  % all the DS cues

        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
            
        %We have to throw in an extra conditional in case we've excluded
        %cues in our peri cue analysis due to being too close to the
        %beginning or end. Otherwise, we can get an out of range error
        %because the inPortDS array doesn't exclude these cues.
        for inPortTrial = find(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS))
            if inPortTrial < numel(DSselected) 
                DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;
            end
        end
        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        
        %same here, we need an extra conditional in case cues were excluded
        for noPEtrial = find(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS))
            if noPEtrial < numel(DSselected)
                DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
            end
        end
        
        %this may create some zeros, so let's make those nan as well
        DSselected(DSselected==0) = nan;
        
        %lets convert this to an index of trials with a valid value 
        DSselected= find(~isnan(DSselected));
        
            %Repeat above for NS 
        if ~isempty(currentSubj(session).periNS.NS)
             NSselected= currentSubj(session).periNS.NS;  

            %First, let's exclude trials where animal was already in port
            %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
            %have a non-nan value and use these to exclude NS trials from this
            %analysis (we'll make them nan)

            NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

            %Then, let's exclude trials where animal didn't make a PE during
            %the cue epoch. To do so, get indices of empty cells in
            %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
            %happened during the cue epoch) and then use these to set that NS =
            %nan
            NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;

       
            %lets convert this to an index of trials with a valid value 
            NSselected= find(~isnan(NSselected));
        end %end NS conditional       
        
        %collect all z score responses to every single DS across all sessions
        %we'll use DSselected and NSselected as indices to pull only data
        %from trials with port entries
        if session==1 %for first session, initialize 
           currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
           currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
           currentSubj(1).DSpeLatencyAllTrials= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
         
           if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                currentSubj(1).NSpeLatencyAllTrials= currentSubj(session).behavior.NSpeLatency(NSselected); 
           else
               continue %continue if no NS data
           end
        else %add subsequent sessions using cat()
            currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSpeLatencyAllTrials = cat(2,currentSubj(1).DSpeLatencyAllTrials,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
        
            if ~isempty(currentSubj(session).periNS.NS)
                currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                currentSubj(1).NSpeLatencyAllTrials = cat(2,currentSubj(1).NSpeLatencyAllTrials,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
            else
                continue %continue if nos NS data
            end
        end        
    end %end session loop
    
    
    %Sort PE latencies and retrieve an index of the sorted order that
    %we'll use to sort the photometry data
    [DSpeLatencySorted,DSsortInd] = sort(currentSubj(1).DSpeLatencyAllTrials);       

    [NSpeLatencySorted,NSsortInd] = sort(currentSubj(1).NSpeLatencyAllTrials);
    
    %Sort all trials by PE latency
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials(:,DSsortInd);
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials(:,DSsortInd);
    currentSubj(1).NSzblueAllTrials = currentSubj(1).NSzblueAllTrials(:,NSsortInd);
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials(:,NSsortInd);

    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding DS trials with valid PE - sorted  by PE latency (Lo-Hi)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding DS trials with valid PE - sorted by PE latency (Lo-Hi) ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding NS trials with valid PE - sorted by PE latency (Lo-Hi) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding NS trials with valid PE - sorted by PE latency (Lo-Hi) ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    end   
    
   
    %Overlay scatter of PE latency
   subplot(2,2,1) %DS blue
   hold on
   scatter(DSpeLatencySorted,currentSubj(1).totalDScount', 'm.');
   subplot(2,2,3) %DS purple
   hold on
   scatter(DSpeLatencySorted,currentSubj(1).totalDScount', 'm.');
   
   if ~isempty(currentSubj(1).NSzblueAllTrials)
      subplot(2,2,2) %NS blue
      hold on
      scatter(NSpeLatencySorted,currentSubj(1).totalNScount', 'm.');
     
      subplot(2,2,4) %NS purple
      hold on
      scatter(NSpeLatencySorted,currentSubj(1).totalNScount', 'm.');
   end
    
    figureCount= figureCount+1;
   
    saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials_latSort','.fig')); %save the current figure in fig format

    
end %end subject loop

%% HEAT PLOT OF RESPONSE TO FIRST PE IN CUE EPOCH

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS firstPox, blue z score response to NS firstPox, purple z score response to
%DS firstPox, purple z score response to NS firstPox.

%we'll pull from the subjDataAnalyzed struct to make our heatplots 

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        %collect all z score responses to every single DSfirstPox across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSzpoxblueAllTrials= squeeze(currentSubj(session).periDSpox.DSzpoxblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSzpoxpurpleAllTrials= squeeze(currentSubj(session).periDSpox.DSzpoxpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSzpoxblueAllTrials= squeeze(currentSubj(session).periNSpox.NSzpoxblue); 
            currentSubj(1).NSzpoxpurpleAllTrials= squeeze(currentSubj(session).periNSpox.NSzpoxpurple);
        else %add subsequent sessions using cat()
            currentSubj(1).DSzpoxblueAllTrials = cat(2, currentSubj.DSzpoxblueAllTrials, (squeeze(currentSubj(session).periDSpox.DSzpoxblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpoxpurpleAllTrials = cat(2, currentSubj.DSzpoxpurpleAllTrials, (squeeze(currentSubj(session).periDSpox.DSzpoxpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSzpoxblueAllTrials = cat(2, currentSubj.NSzpoxblueAllTrials, (squeeze(currentSubj(session).periNSpox.NSzpoxblue))); 
            currentSubj(1).NSzpoxpurpleAllTrials = cat(2, currentSubj.NSzpoxpurpleAllTrials, (squeeze(currentSubj(session).periNSpox.NSzpoxpurple))); 
        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzpoxblueAllTrials= currentSubj(1).DSzpoxblueAllTrials';
    currentSubj(1).DSzpoxpurpleAllTrials= currentSubj(1).DSzpoxpurpleAllTrials';    
    currentSubj(1).NSzpoxblueAllTrials= currentSubj(1).NSzpoxblueAllTrials';
    currentSubj(1).NSzpoxpurpleAllTrials= currentSubj(1).NSzpoxpurpleAllTrials';
      
    
    %remove nan trials (trials with no PE)
    currentSubj(1).DSzpoxblueAllTrials=  currentSubj(1).DSzpoxblueAllTrials(all(~isnan(currentSubj(1).DSzpoxblueAllTrials),2),:);
    currentSubj(1).DSzpoxpurpleAllTrials=  currentSubj(1).DSzpoxpurpleAllTrials(all(~isnan(currentSubj(1).DSzpoxpurpleAllTrials),2),:);

    
    %remove nan trials (NSzpox arrays retain nan values bc of the 3d structure)
    currentSubj(1).NSzpoxblueAllTrials= currentSubj(1).NSzpoxblueAllTrials(all(~isnan(currentSubj(1).NSzpoxblueAllTrials),2),:); 
    currentSubj(1).NSzpoxpurpleAllTrials= currentSubj(1).NSzpoxpurpleAllTrials(all(~isnan(currentSubj(1).NSzpoxpurpleAllTrials),2),:); 

    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzpoxblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzpoxblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpoxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpoxpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpoxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpoxblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpoxpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzpoxblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpoxblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE in DS epoch')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from PE');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding DS');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpoxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpoxpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first PE in DS epoch')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from PE');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding DS');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzpoxblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpoxblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE in NS epoch ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding NS');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpoxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpoxpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first PE in NS epoch ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from PE ');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding NS');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_perifirstPoxZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
    
    figureCount= figureCount+1;
end %end subject loop

%% HEAT PLOT OF RESPONSE TO FIRST LICK IN CUE EPOCH

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS firstLox, blue z score response to NS firstLox, purple z score response to
%DS firstLox, purple z score response to NS firstLox.

%we'll pull from the subjDataAnalyzed struct to make our heatplots 

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        %collect all z score responses to every single DSfirstLox across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSzloxblueAllTrials= squeeze(currentSubj(session).periDSlox.DSzloxblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSzloxpurpleAllTrials= squeeze(currentSubj(session).periDSlox.DSzloxpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSzloxblueAllTrials= squeeze(currentSubj(session).periNSlox.NSzloxblue); 
            currentSubj(1).NSzloxpurpleAllTrials= squeeze(currentSubj(session).periNSlox.NSzloxpurple);
        else %add subsequent sessions using cat()
            currentSubj(1).DSzloxblueAllTrials = cat(2, currentSubj.DSzloxblueAllTrials, (squeeze(currentSubj(session).periDSlox.DSzloxblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzloxpurpleAllTrials = cat(2, currentSubj.DSzloxpurpleAllTrials, (squeeze(currentSubj(session).periDSlox.DSzloxpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSzloxblueAllTrials = cat(2, currentSubj.NSzloxblueAllTrials, (squeeze(currentSubj(session).periNSlox.NSzloxblue))); 
            currentSubj(1).NSzloxpurpleAllTrials = cat(2, currentSubj.NSzloxpurpleAllTrials, (squeeze(currentSubj(session).periNSlox.NSzloxpurple))); 
        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzloxblueAllTrials= currentSubj(1).DSzloxblueAllTrials';
    currentSubj(1).DSzloxpurpleAllTrials= currentSubj(1).DSzloxpurpleAllTrials';    
    currentSubj(1).NSzloxblueAllTrials= currentSubj(1).NSzloxblueAllTrials';
    currentSubj(1).NSzloxpurpleAllTrials= currentSubj(1).NSzloxpurpleAllTrials';
      
    
      %remove nan trials (trials w/ no lick)
    currentSubj(1).DSzloxblueAllTrials= currentSubj(1).DSzloxblueAllTrials(all(~isnan(currentSubj(1).DSzloxblueAllTrials),2),:); 
    currentSubj(1).DSzloxpurpleAllTrials= currentSubj(1).DSzloxpurpleAllTrials(all(~isnan(currentSubj(1).DSzloxpurpleAllTrials),2),:); 

    
    %remove nan trials (NSzlox arrays retain nan values bc of the 3d structure)
    currentSubj(1).NSzloxblueAllTrials= currentSubj(1).NSzloxblueAllTrials(all(~isnan(currentSubj(1).NSzloxblueAllTrials),2),:); 
    currentSubj(1).NSzloxpurpleAllTrials= currentSubj(1).NSzloxpurpleAllTrials(all(~isnan(currentSubj(1).NSzloxpurpleAllTrials),2),:); 

    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzloxblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzloxblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzloxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzloxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzloxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzloxpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzloxblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzloxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzloxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzloxblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzloxpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzloxblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSlox.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSlox.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSlox.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzloxblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzloxblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first lick in DS epoch')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from lick');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding DS');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzloxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzloxpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first lick in DS epoch')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from lick');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding DS');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzloxblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzloxblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzloxblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first lick in NS epoch ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from lick');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding NS');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzloxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzloxpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first lick in NS epoch ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from lick ');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding NS');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_perifirstLoxZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
    
    figureCount= figureCount+1;
end %end subject loop

% 
% %% DFF heat plot of response to every individual cue
% 
% 
% %Here, we'll make a figure for each subject with 4 subplots- blue z score
% %response to DS, blue z score response to NS, purple z score response to
% %DS, purple z score response to NS.
% 
% %we'll pull from the subjDataAnalyzed struct to make our heatplots
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
% currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%                 
%         %collect all z score responses to every single DS across all sessions
%         if session==1 %for first session, initialize 
%             currentSubj(1).DSbluedffAllTrials= squeeze(currentSubj(session).periDS.DSbluedff); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%             currentSubj(1).DSpurpledffAllTrials= squeeze(currentSubj(session).periDS.DSpurpledff); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%             
%             currentSubj(1).NSbluedffAllTrials= squeeze(currentSubj(session).periNS.NSbluedff); 
%             currentSubj(1).NSpurpledffAllTrials= squeeze(currentSubj(session).periNS.NSpurpledff);
%         else %add subsequent sessions using cat()
%             currentSubj(1).DSbluedffAllTrials = cat(2, currentSubj.DSbluedffAllTrials, (squeeze(currentSubj(session).periDS.DSbluedff))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%             currentSubj(1).DSpurpledffAllTrials = cat(2, currentSubj.DSpurpledffAllTrials, (squeeze(currentSubj(session).periDS.DSpurpledff))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%         
%             currentSubj(1).NSbluedffAllTrials = cat(2, currentSubj.NSbluedffAllTrials, (squeeze(currentSubj(session).periNS.NSbluedff))); 
%             currentSubj(1).NSpurpledffAllTrials = cat(2, currentSubj.NSpurpledffAllTrials, (squeeze(currentSubj(session).periNS.NSpurpledff))); 
% 
%         end
%         
%     end %end session loop
%     
%     %Transpose these data for readability
%     currentSubj(1).DSbluedffAllTrials= currentSubj(1).DSbluedffAllTrials';
%     currentSubj(1).DSpurpledffAllTrials= currentSubj(1).DSpurpledffAllTrials';    
%     currentSubj(1).NSbluedffAllTrials= currentSubj(1).NSbluedffAllTrials';
%     currentSubj(1).NSpurpledffAllTrials= currentSubj(1).NSpurpledffAllTrials';
%       
%     
%     %get a trial count to use for the heatplot ytick
%     currentSubj(1).totalDScount= 1:size(currentSubj(1).DSbluedffAllTrials,1); 
%     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSbluedffAllTrials,1);
%     
%     
%     %TODO: split up yticks by session (this would show any clear differences between days)
%     
%      %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%      
%      %define DS color axes
%      
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 8; %multiplicative factor- how many stds away do we want our color max & min?
%      
%      topDSdffblue= stdFactor*abs(nanmean((std(currentSubj(1).DSbluedffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSdffpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSpurpledffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSdffblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSbluedffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSdffpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSpurpledffAllTrials, 0, 2))));
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottomDSdffblue, bottomDSdffpurple);
%      topAllDS= max(topDSdffblue, topDSdffpurple);
%      
%     %same, but defining color axes for NS
%     if ~isempty(currentSubj(1).NSbluedffAllTrials) %only run this if there's NS data
%         topNSdffblue= stdFactor*abs(nanmean((std(currentSubj(1).NSbluedffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSdffpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSpurpledffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSdffblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSbluedffAllTrials, 0, 2))));
%         bottomNSdffpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSpurpledffAllTrials, 0, 2))));
% 
%         bottomAllNS= min(bottomNSdffblue, bottomNSdffpurple);
%         topAllNS= max(topNSdffblue, topNSdffpurple);
%     end
%     
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSbluedffAllTrials) %if there is an NS
%         bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
%         bottomAllShared= bottomAllDS;
%         topAllShared= topAllDS;
%     end
%     
%     %save for later 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
%     
%     %Heatplots!  
%     
%     %DS z plot
%     figure(figureCount);
%     hold on;
%     
%     timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
%     
%     %plot blue DS
% 
%     subplot(2,2,1); %subplot for shared colorbar
%     
%     heatDSdffblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSbluedffAllTrials);
%     title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue dff response surrounding every DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS blue dff ');
% 
% 
%     %   plot purple DS (subplotted for shared colorbar)
%     subplot(2,2,3);
%     heatDSdffpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSpurpledffAllTrials); 
% 
%     title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple dff response surrounding every DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% 
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
% 
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
%     
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS purple dff');
% 
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
% %     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
% 
%     if ~isempty(currentSubj(1).NSbluedffAllTrials) %if there is NS data
%         
%         %plot blue NS
%         subplot(2,2,2); %subplot for shared colorbar
% 
%         heatNSdffblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSbluedffAllTrials);
%         title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue dff response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS dff');
%         
%         
%            %   plot purple NS (subplotted for shared colorbar)
%         subplot(2,2,4);
%         heatNSdffpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSpurpledffAllTrials); 
% 
%         title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purpledff response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
% 
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
% 
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS purple dff');
% 
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%         saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueDffs_AllTrials','.fig')); %save the current figure in fig format
%     end
%     figureCount= figureCount+1;
% end %end subj loop

%% Variable reward z score heatplot- timlocked to CUE
%here we will make a figure with subplotted heatplots of the z score
%response to all Pump1, Pump2, and Pump3 DS trials

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct


rewardSessionCount= 0; %counter for sessions with valid variable reward data 


    for session = 1:numel(currentSubj) %for each training session this subject completed
                
        if currentSubj(session).trainStage>=8 %make sure this is a valid stage with multiple rewards
            
            rewardSessionCount= rewardSessionCount+1; %counter for sessions with valid variable reward data 

            
            %first we need to get the z score data surrounding either pump1,
            %pump2, or pump3 DS trials. To do this, we'll use the reward
            %identities (reward.DSreward) as an indidices to get the right DS trials

            indPump1= find(currentSubj(session).reward.DSreward==1);
            indPump2= find(currentSubj(session).reward.DSreward==2);
            indPump3= find(currentSubj(session).reward.DSreward==3);

            %collect all z score responses to every single DS across all sessions
            if rewardSessionCount==1 %for first session, initialize 
                
                %now we'll use the reward identity (pump) indices to get only responses to those specific trials 
                currentSubj(1).DSzbluePump1= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump2= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump3= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

                rewardSessionCount= rewardSessionCount+1;
                
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
%                 currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzbluePump1 = cat(2, currentSubj(1).DSzbluePump1, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump2 = cat(2, currentSubj(1).DSzbluePump2, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump3 = cat(2, currentSubj(1).DSzbluePump3, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

                rewardSessionCount= rewardSessionCount+1;

% currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
% 
%                 currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
%                 currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 

            end
        end %end session loop
    end %end ~isempty reward conditional (alternative to stage conditional)
    
       
    if rewardSessionCount ~=0 %if this subject had a session with valid variable reward data

        %Transpose these data for readability
        currentSubj(1).DSzbluePump1= currentSubj(1).DSzbluePump1';
        currentSubj(1).DSzbluePump2= currentSubj(1).DSzbluePump2';
        currentSubj(1).DSzbluePump3= currentSubj(1).DSzbluePump3';


    %     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    %     currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    %     currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
    %       

        %get a trial count to use for the heatplot ytick
        currentSubj(1).DScountPump1= 1:size(currentSubj(1).DSzbluePump1,1); 
        currentSubj(1).DScountPump2= 1:size(currentSubj(1).DSzbluePump2,1); 
        currentSubj(1).DScountPump3= 1:size(currentSubj(1).DSzbluePump3,1); 


    %     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);


        %TODO: split up yticks by session (this would show any clear differences between days)

%          Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes

         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?

         topDSzbluePump1= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump2= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump3= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         
%          topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzbluePump1 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump2 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump3 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
%          bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));

         %now choose the most extreme of these two (between blue and
         %purple)to represent the color axis 
         bottomAllDS= min([bottomDSzbluePump1, bottomDSzbluePump2, bottomDSzbluePump3]);
         topAllDS= max([topDSzbluePump1, topDSzbluePump2, topDSzbluePump3]);

%         %same, but defining color axes for NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%             topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%             topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%             bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%             bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%             topAllNS= max(topNSzblue, topNSzpurple);
%         end

%         %Establish a shared bottom and top for shared color axis of DS & NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%             bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%             topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%         else
            bottomAllShared= bottomAllDS;
            topAllShared= topAllDS;
%         end
% 
%         %save for later 
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;

        %Heatplots!  

        %DS z plot
        figure(figureCount);
        figureCount=figureCount+1;
        hold on;

        timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

        %plot pump1 blue DSz

        subplot(3,1,1); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump1,currentSubj(1).DSzbluePump1);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding Pump1 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        
                %plot pump2 blue DSz

        subplot(3,1,2); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump2,currentSubj(1).DSzbluePump2);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding Pump2 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

                %plot pump3 blue DSz

        subplot(3,1,3); %subplot for shared colorbar

        heatDSzbluePump3= imagesc(timeLock,currentSubj(1).DScountPump3,currentSubj(1).DSzbluePump3);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding Pump3 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        %TODO: add purple plot
        
               set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    end %end variable reward conditional
end %end subject loop


%% Variable reward z-score heatplot- timelocked to FIRST PE after cue

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    rewardSessionCount= 0; %counter for sessions with valid variable reward data 

    for session = 1:numel(currentSubj) %for each training session this subject completed
                
        %clear between sessions
        indPump1= [];
        indPump2= [];
        indPump3= [];
        
                
        if currentSubj(session).trainStage>=8 %make sure this is a valid stage with multiple rewards
            
            rewardSessionCount= rewardSessionCount+1; %counter for sessions with valid variable reward data 

            
            %first we need to get the z score data surrounding either pump1,
            %pump2, or pump3 DS trials. To do this, we'll use the reward
            %identities (reward.DSreward) as an indidices to get the right DS trials
           

            indPump1= find(currentSubj(session).reward.DSreward==1);
            indPump2= find(currentSubj(session).reward.DSreward==2);
            indPump3= find(currentSubj(session).reward.DSreward==3);
            
            %it's possible that indPump1,2, or 3 will result in an invalid
            %index (for a cue that was excluded in the peri cue analyses)
            %so let's check for that and exclude these (this may not be the
            %best method)
           
            for i= 1:numel(indPump1)
                if indPump1(i) > size(currentSubj(session).periDSpox.DSzpoxblue,3)
                   indPump1(i:end) = [];
                   break;
                end
            end
            
            for i= 1:numel(indPump2)
                if indPump2(i) > size(currentSubj(session).periDSpox.DSzpoxblue,3)
                   indPump2(i:end) = []; 
                  break;
                end
            end

            for i= 1:numel(indPump3)
                if indPump3(i) > size(currentSubj(session).periDSpox.DSzpoxblue,3)
                   indPump3(i:end) = []; 
                   break;
                end
            end

            %collect all z score responses to every single DS across all sessions
            if rewardSessionCount==1 %for first session, initialize 
                
                %now we'll use the reward identity (pump) indices to get only responses to those specific trials 
                currentSubj(1).DSzbluePump1= squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump1)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump2= squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump2)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump3= squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump3)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

                rewardSessionCount= rewardSessionCount+1;
                
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
%                 currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzbluePump1 = cat(2, currentSubj(1).DSzbluePump1, squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump1))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump2 = cat(2, currentSubj(1).DSzbluePump2, squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump2))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump3 = cat(2, currentSubj(1).DSzbluePump3, squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump3))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

                rewardSessionCount= rewardSessionCount+1;

% currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
% 
%                 currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
%                 currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 

            end
        end %end ~isempty reward conditional (alternative to stage conditional)
    end %end session loop
    
       
    if rewardSessionCount ~=0 %if this subject had a session with valid variable reward data
        
        %some values were filled
        

        %Transpose these data for readability
        currentSubj(1).DSzbluePump1= currentSubj(1).DSzbluePump1';
        currentSubj(1).DSzbluePump2= currentSubj(1).DSzbluePump2';
        currentSubj(1).DSzbluePump3= currentSubj(1).DSzbluePump3';


    %     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    %     currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    %     currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
    %       

        %get a trial count to use for the heatplot ytick
        currentSubj(1).DScountPump1= 1:size(currentSubj(1).DSzbluePump1,1); 
        currentSubj(1).DScountPump2= 1:size(currentSubj(1).DSzbluePump2,1); 
        currentSubj(1).DScountPump3= 1:size(currentSubj(1).DSzbluePump3,1); 


 
        %TODO: split up yticks by session (this would show any clear differences between days)

%          Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes

         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?

         topDSzbluePump1= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump2= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump3= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         
%          topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzbluePump1 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump2 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump3 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
%          bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));

         %now choose the most extreme of these two (between blue and
         %purple)to represent the color axis 
         bottomAllDS= min([bottomDSzbluePump1, bottomDSzbluePump2, bottomDSzbluePump3]);
         topAllDS= max([topDSzbluePump1, topDSzbluePump2, topDSzbluePump3]);

%         %same, but defining color axes for NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%             topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%             topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%             bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%             bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%             topAllNS= max(topNSzblue, topNSzpurple);
%         end

%         %Establish a shared bottom and top for shared color axis of DS & NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%             bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%             topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%         else
            bottomAllShared= bottomAllDS;
            topAllShared= topAllDS;
%         end
% 
%         %save for later 
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;

        %Heatplots!  

        %DS z plot
        figure(figureCount);
        figureCount=figureCount+1;
        hold on;

        timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0


        
        %plot pump1 blue DSz

        subplot(3,1,1); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump1,currentSubj(1).DSzbluePump1);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE- Pump1 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        
                %plot pump2 blue DSz

        subplot(3,1,2); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump2,currentSubj(1).DSzbluePump2);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE- Pump2 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

                %plot pump3 blue DSz

        subplot(3,1,3); %subplot for shared colorbar

        heatDSzbluePump3= imagesc(timeLock,currentSubj(1).DScountPump3,currentSubj(1).DSzbluePump3);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE- Pump3 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        %TODO: add purple plot
        
               set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

               
                   % ~~~~ 2d plot of all session means ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        %plot of response on Pump1, Pump2, and Pump3 DS trials
%        figure(figureCount);
%        figureCount=figureCount+1;
%        
%           hold on;
%           plot(timeLock,currentSubj(1).DSzbluePump1, 'k');
%           plot(timeLock,currentSubj(1).DSzbluePump2, 'r');
%           plot(timeLock,currentSubj(1).DSzbluePump3, 'g');
%           set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%           
          
      %~~~ 2d plot of grand mean of trials with valid PE
      
      figure(figureCount);
      figureCount= figureCount+1;
      hold on;
      plot(timeLock,nanmean(currentSubj(1).DSzbluePump1, 1), 'k');
      plot(timeLock,nanmean(currentSubj(1).DSzbluePump2, 1), 'r');
      plot(timeLock,nanmean(currentSubj(1).DSzbluePump3, 1), 'g');
      set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving               
               
    end %end variable reward conditional
end %end subject loop


%% Variable reward Session AVG z response heatplot & 2d plot


for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct


rewardSessionCount= 0; %counter for sessions with valid variable reward data 


%     %was trying to programmatically assign reward values %first get all unique stages with variable reward
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%         if currentSubj(session).trainStage>=8 
%             rewardSessionCount= rewardSessionCount+1;
%                   
%             
%             trainStage{1,rewardSessionCount}= currentSubj(session).trainStage;
%             trainStage{2,rewardSessionCount}= currentSubj(session).reward.pump1; %pump 1
%             trainStage{3,rewardSessionCount}= currentSubj(session).reward.pump2; %pump 2 
%             trainStage{4,rewardSessionCount}= currentSubj(session).reward.pump3; %pump 3
%         end
%     end
%     
%     %get only unique train stages & associated rewards
%     trainStage= unique(trainStage();
            
    for session = 1:numel(currentSubj) %for each training session this subject completed

%         if currentSubj(session).trainStage==12 %manually plotting only specific sessions (same stage= same rewards)
    
        
            %clear between sessions
            indPump1= [];
            indPump2= [];
            indPump3= [];


            if currentSubj(session).trainStage>=8 %make sure this is a valid stage with multiple rewards

                rewardSessionCount= rewardSessionCount+1; %counter for sessions with valid variable reward data 


                %first we need to get the z score data surrounding either pump1,
                %pump2, or pump3 DS trials. To do this, we'll use the reward
                %identities (reward.DSreward) as an indidices to get the right DS trials


                indPump1= find(currentSubj(session).reward.DSreward==1);
                indPump2= find(currentSubj(session).reward.DSreward==2);
                indPump3= find(currentSubj(session).reward.DSreward==3);

                %it's possible that indPump1,2, or 3 will result in an invalid
                %index (for a cue that was excluded in the peri cue analyses)
                %so let's check for that and exclude these (this may not be the
                %best method)

                for i= 1:numel(indPump1)
                    if indPump1(i) > size(currentSubj(session).periDS.DSzblue,3)
                       indPump1(i:end) = [];
                       break;
                    end
                end

                for i= 1:numel(indPump2)
                    if indPump2(i) > size(currentSubj(session).periDS.DSzblue,3)
                       indPump2(i:end) = []; 
                      break;
                    end
                end

                for i= 1:numel(indPump3)
                    if indPump3(i) > size(currentSubj(session).periDS.DSzblue,3)
                       indPump3(i:end) = []; 
                       break;
                    end
                end

                %collect all z score responses to every single DS across all sessions
                if rewardSessionCount==1 %for first session, initialize 

                    %now we'll use the reward identity (pump) indices to get only responses to those specific trials 
                    currentSubj(1).DSzbluePump1= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                    currentSubj(1).DSzbluePump2= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                    currentSubj(1).DSzbluePump3= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

    %                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
    % 
    %                 currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
    %                 currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
                else %add subsequent sessions using cat()
                    currentSubj(1).DSzbluePump1 = cat(2, currentSubj(1).DSzbluePump1, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                    currentSubj(1).DSzbluePump2 = cat(2, currentSubj(1).DSzbluePump2, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                    currentSubj(1).DSzbluePump3 = cat(2, currentSubj(1).DSzbluePump3, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

    % currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
    % 
    %                 currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
    %                 currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 
                end

                %get the Mean z value for each timepoint by taking mean z score for each timestamp across all
                %cues in this session
                currentSubj(1).DSzbluePump1mean(rewardSessionCount,:)= nanmean(squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1)),2)';
                currentSubj(1).DSzbluePump2mean(rewardSessionCount,:)= nanmean(squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2)),2)';
                currentSubj(1).DSzbluePump3mean(rewardSessionCount,:)= nanmean(squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3)),2)';

        %         currentSubj(session).DSzbluePump2mean= nanmean(currentSubj(1).DSzbluePump2,2);
        %         currentSubj(session).DSzbluePump3mean= nanmean(currentSubj(1).DSzbluePump3,2);

            end %end session loop
%         end %end trainStage conditional 
    end %end ~isempty reward conditional (alternative to stage conditional)
    
       
    if rewardSessionCount ~=0 %if this subject had a session with valid variable reward data




    %     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    %     currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    %     currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
    %       

        %get a trial count to use for the heatplot ytick
%         currentSubj(1).DScountPump1= 1:size(currentSubj(1).DSzbluePump1mean,1); 
%         currentSubj(1).DScountPump2= 1:size(currentSubj(1).DSzbluePump2mean,1); 
%         currentSubj(1).DScountPump3= 1:size(currentSubj(1).DSzbluePump3mean,1); 

 
        %TODO: split up yticks by session (this would show any clear differences between days)

%          Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes

         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?

         topDSzbluePump1= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump2= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump3= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         
%          topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzbluePump1 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump2 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump3 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
%          bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));

         %now choose the most extreme of these two (between blue and
         %purple)to represent the color axis 
         bottomAllDS= min([bottomDSzbluePump1, bottomDSzbluePump2, bottomDSzbluePump3]);
         topAllDS= max([topDSzbluePump1, topDSzbluePump2, topDSzbluePump3]);

%         %same, but defining color axes for NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%             topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%             topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%             bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%             bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%             topAllNS= max(topNSzblue, topNSzpurple);
%         end

%         %Establish a shared bottom and top for shared color axis of DS & NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%             bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%             topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%         else
            bottomAllShared= bottomAllDS;
            topAllShared= topAllDS;
%         end
% 
%         %save for later 
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;

        %Heatplots!  

        %DS z plot
        
    %SEPARATE FIGURES FOR EACH STAGE (each reward combination)
        %todo: programatically asisgn labels, currently manual
        
        figure(figureCount);
        figureCount=figureCount+1;
        hold on;

        sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), 'avg response to DS stage 8'));
        
        timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

        %plot pump1 blue DSz

        subplot(3,1,1); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,rewardSessionCount,currentSubj(1).DSzbluePump1mean);
        title(strcat('Avg 465nm z score response to Pump1 DS'));
        xlabel('seconds from PE');
        ylabel(strcat('training day'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        
                %plot pump2 blue DSz

        subplot(3,1,2); %subplot for shared colorbar

        heatDSzbluePump2= imagesc(timeLock,rewardSessionCount,currentSubj(1).DSzbluePump2mean);
        title(strcat('Avg 465nm z score response to Pump2 DS'));
        xlabel('seconds from PE');
        ylabel(strcat('training day'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

                %plot pump3 blue DSz

        subplot(3,1,3); %subplot for shared colorbar

        heatDSzbluePump3= imagesc(timeLock,rewardSessionCount,currentSubj(1).DSzbluePump3mean);
        title(strcat('Avg 465nm z score response to Pump3 DS'));
        xlabel('seconds from PE');
        ylabel(strcat('training day'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        %TODO: add purple plot
        
               set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
            
               
               
       % ~~~~ 2d plot of all session means ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        %plot of response on Pump1, Pump2, and Pump3 DS trials
       figure(figureCount);
       figureCount=figureCount+1;
       
          hold on;
%           sgtitle(strcat(subjects{subj},'-','stage12-All'));
          plot(timeLock,currentSubj(1).DSzbluePump1mean, 'k');
          plot(timeLock,currentSubj(1).DSzbluePump2mean, 'r');
          plot(timeLock,currentSubj(1).DSzbluePump3mean, 'g');
%           legend('empty','empty','empty');
          set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%           saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'stage12rewardAll','.fig'));
          
          
      %~~~ 2d plot of grand mean of session mean
      
      figure(figureCount);
      figureCount= figureCount+1;
%       sgtitle(strcat(subjects{subj},'-','stage12-Mean'));
      hold on;
      plot(timeLock,nanmean(currentSubj(1).DSzbluePump1mean, 1), 'k');
      plot(timeLock,nanmean(currentSubj(1).DSzbluePump2mean, 1), 'r');
      plot(timeLock,nanmean(currentSubj(1).DSzbluePump3mean, 1), 'g');
%       legend('empty','empty', 'empty')
      set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving               
%       saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'stage12rewardMean','.fig'));         
      
    end %end variable reward conditional
end %end subject loop

%% Plot post-PE response based on reward identity
%dp 10/30/2020 goal of this section is to create plot of post-PE activity
%for each unique reward identity (should be than plotting by pump)

%~~~~Logic here assumes that reward identity changes = coded as different
%stage in metadata excel sheet

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    
  %First get all of the relevant data from each peTrial within each
  %variable reward session
    rewardIDs= []; PEDSblue= []; PEDSpurple= []; pumpIDs= []; rewardsThisStage=[]; pumpOnTimeRel=[]; %reset between subjects
    
%     for session= 1:numel(currentSubj)
        peTrial= []; %reset between sessions
%         if currentSubj(session).trainStage >= 8 %only run for sessions with variable reward
            
          allStages= unique([currentSubj.trainStage]); 
              allRewardStages= allStages(allStages>=8);
          for thisStage= allRewardStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
            includedSessions= []; %excluded sessions will reset between unique stages

            %loop through all sessions and record index of sessions that correspond only to this stage
            for session= 1:numel(currentSubj)
                if currentSubj(session).trainStage == thisStage %only include sessions from this stage
                   includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
                end
            end%end session loop
            
            for includedSession= includedSessions
                for peTrial=find(currentSubj(includedSession).trialOutcome.DSoutcome==1)
                    pumpIDs= [pumpIDs; currentSubj(includedSession).reward.DSreward(peTrial)]; %list of pump identity for every peTrial                   
        
                    pumpOnTimeRel= [pumpOnTimeRel; currentSubj(includedSession).reward.pumpOnFirstPErel(peTrial)];
                    
                    PEDSblue= [PEDSblue, squeeze(currentSubj(includedSession).periDSpox.DSzpoxblue(:,:,peTrial))]; %list of peri- first PE response for every peTrial
                    PEDSpurple= [PEDSpurple, squeeze(currentSubj(includedSession).periDSpox.DSzpoxpurple(:,:,peTrial))]; %list of peri- first PE response for every peTrial
                end %end loop through PEtrials

                %make list of reward IDs given known pumpIDs for each trial
                rewardIDs= cell(size(pumpIDs)); %start with empty cell array (bc dealing with strings) and fill based on pumpID
                rewardIDs(find(pumpIDs==1))= {currentSubj(includedSession).reward.pump1};
                rewardIDs(find(pumpIDs==2))= {currentSubj(includedSession).reward.pump2};
                rewardIDs(find(pumpIDs==3))= {currentSubj(includedSession).reward.pump3};
            end %end includedSession loop
          
            %Now that we have the trial data and reward identity, let's make plots
            %based on each pump
            %Assuming that identity in each pump is constant for each
            %stage! Also assuming 3 pumps always being used!
            rewardsThisStage{1}= unique(rewardIDs(find(pumpIDs==1)));
            rewardsThisStage{2}= unique(rewardIDs(find(pumpIDs==2)));
            rewardsThisStage{3}= unique(rewardIDs(find(pumpIDs==3)));

        %There will be one subplot per rewardStage
            %with traces for each rewardID
            
            rewardColors= ['g','r','y']; %color plots based on reward identity
            
            figure(figureCount); sgtitle(strcat(subjects{subj},'-peri first PE DSz by reward identity (mean of all trials by stage)'));
%             subplot(1, numel(allRewardStages), find(allRewardStages==thisStage)); hold on;
            
             subplot(3, numel(allRewardStages),find(allRewardStages==thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'-pump1-reward=',rewardsThisStage{1}));
%              plot(timeLock,PEDSblue(:,find(strcmp(rewardIDs,rewardsThisStage{1}))), rewardColors(1)); %plot all trials
             plot(timeLock,nanmean(PEDSblue(:,find(strcmp(rewardIDs,rewardsThisStage{1}))),2), 'b'); %plot mean across all trials (for this stage)
             plot(timeLock,nanmean(PEDSpurple(:,find(strcmp(rewardIDs,rewardsThisStage{1}))),2), 'm'); %plot mean across all trials (for this stage)
             plot(ones(2,1)*nanmean(unique(pumpOnTimeRel(pumpIDs==1))), ylim, 'g'); %overlay line for pump on time (for now using nanmean bc slight differences unique() picks up probably because they haven't been rounded to the nearest timestamp)
             plot(ones(2,1)*0, ylim, 'k');%overlay line for PE
             
             subplot(3, numel(allRewardStages), numel(allRewardStages)+find(allRewardStages==thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'-pump2-reward=',rewardsThisStage{2}));
%              plot(timeLock,PEDSblue(:,find(strcmp(rewardIDs,rewardsThisStage{2}))), rewardColors(2)); %plot all trials
             plot(timeLock,nanmean(PEDSblue(:,find(strcmp(rewardIDs,rewardsThisStage{2}))),2), 'b'); %plot mean across all trials (for this stage)
             plot(timeLock,nanmean(PEDSpurple(:,find(strcmp(rewardIDs,rewardsThisStage{2}))),2), 'm'); %plot mean across all trials (for this stage)
             plot(ones(2,1)*nanmean(unique(pumpOnTimeRel(pumpIDs==2))), ylim, 'g'); %overlay line for pump on time (for now using nanmean bc slight differences unique() picks up probably because they haven't been rounded to the nearest timestamp)
             plot(ones(2,1)*0, ylim, 'k');%overlay line for PE

             subplot(3, numel(allRewardStages), numel(allRewardStages)+numel(allRewardStages)+find(allRewardStages==thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'-pump3-reward=',rewardsThisStage{3}));
%              plot(timeLock,PEDSblue(:,find(strcmp(rewardIDs,rewardsThisStage{3}))), rewardColors(3)); %plot all trials
             plot(timeLock,nanmean(PEDSblue(:,find(strcmp(rewardIDs,rewardsThisStage{3}))),2), 'b'); %plot mean across all trials (for this stage)
             plot(timeLock,nanmean(PEDSpurple(:,find(strcmp(rewardIDs,rewardsThisStage{3}))),2), 'm'); %plot mean across all trials (for this stage)
             plot(ones(2,1)*nanmean(unique(pumpOnTimeRel(pumpIDs==3))), ylim, 'g'); %overlay line for pump on time (for now using nanmean bc slight differences unique() picks up probably because they haven't been rounded to the nearest timestamp)
             plot(ones(2,1)*0, ylim, 'k');%overlay line for PE
             
             xlabel('time from PE (s)');
             ylabel('z score relative to pre-cue baseline)');

         end %end stage loop
        linkaxes();
        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving      

        legend('465nm z score','405nm z score', 'pump on', 'first PE during DS');
                        
        figureCount= figureCount+1;
                
%             uniqueRewards= [uniqueRewards,unique(rewardIDs)];
%         end %end variable reward session conditional
%     end
    
   
end %end subj loop


%% Extract data from specific sessions- EXAMPLE
%dp 9/20/2020 more efficient way to get data from specific stages
%rather than using a bunch of conditionals and repeated loops, get the
%number of unique training stages and loop through sessions to save data from each stage together
%should also prevent errors by not referencing specific stages that don't exist (e.g. if
%animals are partially through training but haven't reached a stage)

% for subj= 1:numel(subjects)
%     currentSubj= subjDataAnalyzed.(subjects{subj});
%     allStages= unique([currentSubj.trainStage]);
%     for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
%         includedSessions= []; %excluded sessions will reset between unique stages
%         
%         %loop through all sessions and record index of sessions that correspond only to this stage
%         for session= 1:numel(currentSubj)
%             if currentSubj(session).trainStage == thisStage %only include sessions from this stage
%                includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
%             end
%         end%end session loop
%     
%         for includedSession= includedSessions %loop through only sessions that match this stage
%             %extract data you want from specific sessions here using currentSubj(includedSession) as index
%         end
%         
%         figure(figureCount); hold on; sgtitle('plot by stages example');
%         subplot(2, allStages(end), thisStage); title(strcat('DS stage-',num2str(thisStage)));
%         subplot(2,allStages(end), allStages(end)+thisStage); title(strcat('NS stage-', num2str(thisStage)));
% 
%     end %end Stage loop 
%       figureCount= figureCount+1;
% end %end subj loop

%% Peri-DS 2d plots by stage

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    allStages= unique([currentSubj.trainStage]);
    
    for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
        includedSessions= []; %excluded sessions will reset between unique stages
        
        %loop through all sessions and record index of sessions that correspond only to this stage
        for session= 1:numel(currentSubj)
            if currentSubj(session).trainStage == thisStage %only include sessions from this stage
               includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
            end
        end%end session loop
    
        %create empty arrays that we'll use to extract data from each included session
        DSblue= [];
        DSpurple= [];
        NSblue= [];
        NSpurple= [];
        
        for includedSession= includedSessions %loop through only sessions that match this stage
            %Extracting periDS (timelocked to DS) photometry signals
            DSblue= [DSblue,squeeze(currentSubj(includedSession).periDS.DSzblue)]; %squeeze to make 2d and concatenate
            DSpurple= [DSpurple, squeeze(currentSubj(includedSession).periDS.DSzpurple)];
            NSblue= [NSblue, squeeze(currentSubj(includedSession).periNS.NSzblue)];
            NSpurple= [NSpurple, squeeze(currentSubj(includedSession).periNS.NSzpurple)];
        end
        
    
        
     %generate heatplots
        figure(figureCount); hold on; sgtitle(strcat(subjects{subj},'-peri-DSz by stages'));
        subplot(2, allStages(end), thisStage); title(strcat('465nm Stage-',num2str(thisStage))); hold on;
        
%         plot(timeLock, DSblue, 'k--'); %plot all individual trials
        plot(timeLock, nanmean(DSblue, 2), 'b'); %plot mean
        xlabel('time to cue (s)'); ylabel('mean z-score 465nm');
       
        
        subplot(2, allStages(end), allStages(end)+thisStage); title(strcat('405nm Stage-', num2str(thisStage))); hold on;

%         plot(timeLock, DSpurple, 'k--'); %plot all individual trials
        plot(timeLock, nanmean(DSpurple, 2), 'm'); %plot mean
        xlabel('time to cue (s)'); ylabel('mean z-score 405nm');

            
    end %end Stage loop 
       
    linkaxes; %make axes of subplots equal for nicer look & sense of scale
    
    figureCount= figureCount+1;
    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

end %end subj loop

%% peri-DS heatplots by stage

allSubjDSblue= []; %initialize 
allSubjDSpurple= [];
allSubjNSblue= [];
allSubjNSpurple= [];

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    allStages= unique([currentSubj.trainStage]);
    for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
        includedSessions= []; %excluded sessions will reset between unique stages
        
        %loop through all sessions and record index of sessions that correspond only to this stage
        for session= 1:numel(currentSubj)
            if currentSubj(session).trainStage == thisStage %only include sessions from this stage
               includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
            end
        end%end session loop
    
        %create empty arrays that we'll use to extract data from each included session
        DSblue= [];
        DSpurple= [];
        NSblue= [];
        NSpurple= [];
        
        for includedSession= includedSessions %loop through only sessions that match this stage
            %Extracting periDS (timelocked to DS) photometry signals
            DSblue= [DSblue,squeeze(currentSubj(includedSession).periDS.DSzblue)]; %squeeze to make 2d and concatenate
            DSpurple= [DSpurple, squeeze(currentSubj(includedSession).periDS.DSzpurple)];
            NSblue= [NSblue, squeeze(currentSubj(includedSession).periNS.NSzblue)];
            NSpurple= [NSpurple, squeeze(currentSubj(includedSession).periNS.NSzpurple)];
            
        end
        
        %collect data from all subjects for a between-subjects mean plot
        allSubjDSblue(:,thisStage,subj)= nanmean(DSblue,2);
        allSubjDSpurple(:,thisStage, subj)= nanmean(DSpurple,2);
    
        if ~isempty(NSblue)
           allSubjNSblue(:,thisStage,subj)= nanmean(NSblue,2);
           allSubjNSpurple(:,thisStage,subj)= nanmean(NSpurple,2);
        end
    
     %get a shared color axis for all subplots
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
     topDSzblue= stdFactor*abs(nanmean((std(DSblue, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(DSpurple, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(DSblue, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(DSpurple, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
        
     %generate heatplots
        figure(figureCount); hold on; sgtitle(strcat(subjects{subj},'-peri-DSz by stages'));
        subplot(2, allStages(end), thisStage); title(strcat('465nm Stage-',num2str(thisStage))); hold on;
        
        imagesc(timeLock, 1:size(DSblue,2), DSblue');
        xlabel('time to cue (s)'); ylabel('trial');
        set(gca,'YDir','reverse'); %for some reason y axis is flipped using imagesc()
        ylim([1,size(DSblue,2)]); %this eliminates any extra white space
        caxis([bottomAllDS,topAllDS]);
       
        
        subplot(2, allStages(end), allStages(end)+thisStage); title(strcat('405nm Stage-', num2str(thisStage))); hold on;

        imagesc(timeLock, 1:size(DSpurple,2), DSpurple');
        xlabel('time to cue (s)'); ylabel('trial');
        set(gca,'YDir','reverse'); %for some reason y axis is flipped using imagesc()
        ylim([1,size(DSpurple,2)]); %this eliminates any extra white space
        caxis([bottomAllDS,topAllDS]);
            
    end %end Stage loop 
    
    figure(figureCount)
    cbar= colorbar; %just add one colorbar at the very end for each figure... no straightforward way to make this appear separate from a subplot
    cbar.Position= [.92,.1, .02, .8]; %manually position colorbar to prevent downsizing of last subplot
%     colorbar('Location','eastoutside'); %could do this but subplot is made smaller
    %todo: this can be done https://www.mathworks.com/matlabcentral/answers/78635-how-to-display-only-one-legend-for-a-figure-with-multiple-plots
    
    figureCount= figureCount+1;
    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

end %end subj loop

%replace columns that have all zeros with nans (this could happen if an animal
%didn't run a particular stage)
for subj= 1:numel(subjects)
    allSubjDSblue(:,find(all(allSubjDSblue(:,:,subj)==0)),subj)= nan;
    allSubjDSpurple(:,find(all(allSubjDSpurple(:,:,subj)==0)), subj)= nan;
    allSubjNSblue(:,find(all(allSubjNSblue(:,:,subj)==0)), subj)= nan;
    allSubjNSpurple(:,find(all(allSubjNSpurple(:,:,subj)==0)), subj)= nan;
end

% Now make a between-subj plot of mean across all animals
figure;
figureCount=figureCount+1; sgtitle('peri-cue response: mean between subjects ');
for subj= 1:numel(subjects)
    for thisStage= 1:size(allSubjDSblue,2) 
        thisStageDSblue= nanmean(allSubjDSblue(:,thisStage,:),3);
        thisStageDSpurple= nanmean(allSubjDSpurple(:,thisStage,:),3);
        thisStageNSblue= nanmean(allSubjNSblue(:,thisStage,:), 3);
        thisStageNSpurple= nanmean(allSubjNSpurple(:,thisStage,:),3);

                %DS
        subplot(subplot(2, size(allSubjDSblue,2), thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'peri-DS')) 
        plot(timeLock, (allSubjDSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjDSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageDSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageDSpurple,'r','LineWidth',2); %plot between-subjects mean purple
            %NS
        subplot(subplot(2, size(allSubjDSblue,2), size(allSubjDSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'peri-NS')) 
        plot(timeLock, (allSubjNSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjNSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageNSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageNSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        if thisStage==1
           legend('465 individual subj mean', '405 individual subj mean', '465 all subj mean','405 all subj mean');
        end
    end
end

linkaxes(); %link axes for scale comparison

%% Peri-DSpox 2d plots by stage

allSubjDSblue= []; %initialize 
allSubjDSpurple= [];
allSubjNSblue= [];
allSubjNSpurple= [];

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    allStages= unique([currentSubj.trainStage]);
    
    for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
        includedSessions= []; %excluded sessions will reset between unique stages
        
        %loop through all sessions and record index of sessions that correspond only to this stage
        for session= 1:numel(currentSubj)
            if currentSubj(session).trainStage == thisStage %only include sessions from this stage
               includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
            end
        end%end session loop
    
        %create empty arrays that we'll use to extract data from each included session
        DSblue= [];
        DSpurple= [];
        NSblue= [];
        NSpurple= [];
        
        for includedSession= includedSessions %loop through only sessions that match this stage
            %Extracting periDS (timelocked to DS) photometry signals
            DSblue= [DSblue,squeeze(currentSubj(includedSession).periDSpox.DSzpoxblue)]; %squeeze to make 2d and concatenate
            DSpurple= [DSpurple, squeeze(currentSubj(includedSession).periDSpox.DSzpoxpurple)];
            NSblue= [NSblue, squeeze(currentSubj(includedSession).periNSpox.NSzpoxblue)];
            NSpurple= [NSpurple, squeeze(currentSubj(includedSession).periNSpox.NSzpoxpurple)];
        end
        
        %collect data from all subjects for a between-subjects mean plot
        allSubjDSblue(:,thisStage,subj)= nanmean(DSblue,2);
        allSubjDSpurple(:,thisStage, subj)= nanmean(DSpurple,2);
    
        if ~isempty(NSblue)
           allSubjNSblue(:,thisStage,subj)= nanmean(NSblue,2);
           allSubjNSpurple(:,thisStage,subj)= nanmean(NSpurple,2);
        end
    
        
     %generate plots
        figure(figureCount); hold on; sgtitle(strcat(subjects{subj},'-peri first PE in DS epoch by stages'));
        subplot(2, allStages(end), thisStage); title(strcat('465nm Stage-',num2str(thisStage))); hold on;
        
%         plot(timeLock, DSblue, 'k--'); %plot all individual trials
        plot(timeLock, nanmean(DSblue, 2), 'b'); %plot mean
        xlabel('time to first PE after DS (s)'); ylabel('mean z-score 465nm');
        
%             %calculate SEM for this subject (will be used to overlay this SEM or even between subjects SEM later)
        sem(:,thisStage,subj)= (nanstd(DSblue,0,2))/sqrt(size(DSblue,2));
        semLinePos= nanmean(DSblue,2)+sem(:,thisStage,subj); %save mean + sem and mean - s for easier patch() overlay
        semLineNeg= nanmean(DSblue,2)-sem(:,thisStage,subj);
%              %calculate std for trials in this stage (will be used to overlay std for some measure of variability)
%         stdLinePos= nanmean(DSblue,2)+nanstd(DSblue,0,2); %save mean + std and mean - std for easier patch() overlay
%         stdLineNeg= nanmean(DSblue,2)-nanstd(DSblue,0,2);
             
        patch([timeLock,timeLock(end:-1:1)],[semLinePos',semLineNeg(end:-1:1)'],'b','EdgeColor','None');alpha(0.5);

        %add only one legend for the first subplot (seems to be easiest solution)
        if thisStage== allStages(1)
            legend('mean', 'within-subject SEM (n=# trials)');
        end
        
        subplot(2, allStages(end), allStages(end)+thisStage); title(strcat('405nm Stage-', num2str(thisStage))); hold on;

%         plot(timeLock, DSpurple, 'k--'); %plot all individual trials
        plot(timeLock, nanmean(DSpurple, 2), 'm'); %plot mean
        xlabel('time to first PE after DS (s)'); ylabel('mean z-score 405nm');

        %             %calculate SEM for this subject (will be used to overlay this SEM or even between subjects SEM later)
        sem(:,thisStage,subj)= (nanstd(DSpurple,0,2))/sqrt(size(DSpurple,2));
        semLinePos= nanmean(DSpurple,2)+sem(:,thisStage,subj); %save mean + sem and mean - s for easier patch() overlay
        semLineNeg= nanmean(DSpurple,2)-sem(:,thisStage,subj);
%              %calculate std for trials in this stage (will be used to overlay std for some measure of variability)
%         stdLinePos= nanmean(DSblue,2)+nanstd(DSblue,0,2); %save mean + std and mean - std for easier patch() overlay
%         stdLineNeg= nanmean(DSblue,2)-nanstd(DSblue,0,2);
             
        patch([timeLock,timeLock(end:-1:1)],[semLinePos',semLineNeg(end:-1:1)'],'m','EdgeColor','None');alpha(0.5);

        %add only one legend for the first subplot (seems to be easiest solution)
        if thisStage== allStages(1)
            legend('mean', 'within-subject SEM (n=# trials)');
        end
            
    end %end Stage loop 
       
    linkaxes; %make axes of subplots equal for nicer look & sense of scale
    
    figureCount= figureCount+1;
    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

end %end subj loop

%replace columns that have all zeros with nans (this could happen if an animal
%didn't run a particular stage)
for subj= 1:numel(subjects)
    allSubjDSblue(:,find(all(allSubjDSblue(:,:,subj)==0)),subj)= nan;
    allSubjDSpurple(:,find(all(allSubjDSpurple(:,:,subj)==0)), subj)= nan;
    allSubjNSblue(:,find(all(allSubjNSblue(:,:,subj)==0)), subj)= nan;
    allSubjNSpurple(:,find(all(allSubjNSpurple(:,:,subj)==0)), subj)= nan;
end

% Now make a between-subj plot of mean across all animals
figure;
figureCount=figureCount+1; sgtitle('peri-first PE response: mean between subjects ');
for subj= 1:numel(subjects)
    for thisStage= 1:size(allSubjDSblue,2) 
        thisStageDSblue= nanmean(allSubjDSblue(:,thisStage,:),3);
        thisStageDSpurple= nanmean(allSubjDSpurple(:,thisStage,:),3);
        thisStageNSblue= nanmean(allSubjNSblue(:,thisStage,:), 3);
        thisStageNSpurple= nanmean(allSubjNSpurple(:,thisStage,:),3);

                %DS
        subplot(subplot(2, size(allSubjDSblue,2), thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'peri-first PE DS')) 
        plot(timeLock, (allSubjDSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjDSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageDSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageDSpurple,'r','LineWidth',2); %plot between-subjects mean purple
            %NS
        subplot(subplot(2, size(allSubjDSblue,2), size(allSubjDSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'peri-first PE NS')) 
        plot(timeLock, (allSubjNSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjNSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageNSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageNSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        if thisStage==1
           legend('465 individual subj mean', '405 individual subj mean', '465 all subj mean','405 all subj mean');
        end
    end
end

linkaxes(); %link axes for scale comparison


%% Peri-DSlox 2d plots by stage

allSubjDSblue= []; %initialize 
allSubjDSpurple= [];
allSubjNSblue= [];
allSubjNSpurple= [];

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    allStages= unique([currentSubj.trainStage]);
    
    for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
        includedSessions= []; %excluded sessions will reset between unique stages
        
        %loop through all sessions and record index of sessions that correspond only to this stage
        for session= 1:numel(currentSubj)
            if currentSubj(session).trainStage == thisStage %only include sessions from this stage
               includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
            end
        end%end session loop
    
        %create empty arrays that we'll use to extract data from each included session
        DSblue= [];
        DSpurple= [];
        NSblue= [];
        NSpurple= [];
        
        for includedSession= includedSessions %loop through only sessions that match this stage
            %Extracting periDS (timelocked to DS) photometry signals
            DSblue= [DSblue,squeeze(currentSubj(includedSession).periDSlox.DSzloxblue)]; %squeeze to make 2d and concatenate
            DSpurple= [DSpurple, squeeze(currentSubj(includedSession).periDSlox.DSzloxpurple)];
            NSblue= [NSblue, squeeze(currentSubj(includedSession).periNSlox.NSzloxblue)];
            NSpurple= [NSpurple, squeeze(currentSubj(includedSession).periNSlox.NSzloxpurple)];
        end
        
     %collect data from all subjects for a between-subjects mean plot
        allSubjDSblue(:,thisStage,subj)= nanmean(DSblue,2);
        allSubjDSpurple(:,thisStage, subj)= nanmean(DSpurple,2);
    
        if ~isempty(NSblue)
           allSubjNSblue(:,thisStage,subj)= nanmean(NSblue,2);
           allSubjNSpurple(:,thisStage,subj)= nanmean(NSpurple,2);
        end
        
     %generate plots
        figure(figureCount); hold on; sgtitle(strcat(subjects{subj},'-peri first LICK in DS epoch by stages'));
        subplot(2, allStages(end), thisStage); title(strcat('465nm Stage-',num2str(thisStage))); hold on;
        
%         plot(timeLock, DSblue, 'k--'); %plot all individual trials
        plot(timeLock, nanmean(DSblue, 2), 'b'); %plot mean
        xlabel('time to first lick after DS (s)'); ylabel('mean z-score 465nm');
        
%             %calculate SEM for this subject (will be used to overlay this SEM or even between subjects SEM later)
        sem(:,thisStage,subj)= (nanstd(DSblue,0,2))/sqrt(size(DSblue,2));
        semLinePos= nanmean(DSblue,2)+sem(:,thisStage,subj); %save mean + sem and mean - s for easier patch() overlay
        semLineNeg= nanmean(DSblue,2)-sem(:,thisStage,subj);
%              %calculate std for trials in this stage (will be used to overlay std for some measure of variability)
%         stdLinePos= nanmean(DSblue,2)+nanstd(DSblue,0,2); %save mean + std and mean - std for easier patch() overlay
%         stdLineNeg= nanmean(DSblue,2)-nanstd(DSblue,0,2);
             
        patch([timeLock,timeLock(end:-1:1)],[semLinePos',semLineNeg(end:-1:1)'],'b','EdgeColor','None');alpha(0.5);

        %add only one legend for the first subplot (seems to be easiest solution)
        if thisStage== allStages(1)
            legend('mean', 'within-subject SEM (n=# trials)');
        end
        
        subplot(2, allStages(end), allStages(end)+thisStage); title(strcat('405nm Stage-', num2str(thisStage))); hold on;

%         plot(timeLock, DSpurple, 'k--'); %plot all individual trials
        plot(timeLock, nanmean(DSpurple, 2), 'm'); %plot mean
        xlabel('time to first lick after DS (s)'); ylabel('mean z-score 405nm');

        %             %calculate SEM for this subject (will be used to overlay this SEM or even between subjects SEM later)
        sem(:,thisStage,subj)= (nanstd(DSpurple,0,2))/sqrt(size(DSpurple,2));
        semLinePos= nanmean(DSpurple,2)+sem(:,thisStage,subj); %save mean + sem and mean - s for easier patch() overlay
        semLineNeg= nanmean(DSpurple,2)-sem(:,thisStage,subj);
%              %calculate std for trials in this stage (will be used to overlay std for some measure of variability)
%         stdLinePos = nanmean(DSblue,2)+nanstd(DSblue,0,2); %save mean + std and mean - std for easier patch() overlay
%         stdLineNeg= nanmean(DSblue,2)-nanstd(DSblue,0,2);
             
        patch([timeLock,timeLock(end:-1:1)],[semLinePos',semLineNeg(end:-1:1)'],'m','EdgeColor','None');alpha(0.5);

        %add only one legend for the first subplot (seems to be easiest solution)
        if thisStage== allStages(1)
            legend('mean', 'within-subject SEM (n=# trials)');
        end
            
    end %end Stage loop 
       
    linkaxes; %make axes of subplots equal for nicer look & sense of scale
    
    figureCount= figureCount+1;
    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

end %end subj loop


%replace columns that have all zeros with nans (this could happen if an animal
%didn't run a particular stage)
for subj= 1:numel(subjects)
    allSubjDSblue(:,find(all(allSubjDSblue(:,:,subj)==0)),subj)= nan;
    allSubjDSpurple(:,find(all(allSubjDSpurple(:,:,subj)==0)), subj)= nan;
    allSubjNSblue(:,find(all(allSubjNSblue(:,:,subj)==0)), subj)= nan;
    allSubjNSpurple(:,find(all(allSubjNSpurple(:,:,subj)==0)), subj)= nan;
end

% Now make a between-subj plot of mean across all animals
figure;
figureCount=figureCount+1; sgtitle('peri-first LICK response: mean between subjects ');
for subj= 1:numel(subjects)
    for thisStage= 1:size(allSubjDSblue,2) 
        thisStageDSblue= nanmean(allSubjDSblue(:,thisStage,:),3);
        thisStageDSpurple= nanmean(allSubjDSpurple(:,thisStage,:),3);
        thisStageNSblue= nanmean(allSubjNSblue(:,thisStage,:), 3);
        thisStageNSpurple= nanmean(allSubjNSpurple(:,thisStage,:),3);

                %DS
        subplot(subplot(2, size(allSubjDSblue,2), thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'peri-first lick DS')) 
        plot(timeLock, (allSubjDSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjDSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageDSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageDSpurple,'r','LineWidth',2); %plot between-subjects mean purple
            %NS
        subplot(subplot(2, size(allSubjDSblue,2), size(allSubjDSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'peri-first lick NS')) 
        plot(timeLock, (allSubjNSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjNSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageNSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageNSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        if thisStage==1
           legend('465 individual subj mean', '405 individual subj mean', '465 all subj mean','405 all subj mean');
        end
    end
end

linkaxes(); %link axes for scale comparison


%% ~~ Between subjects peri-event plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% Between subjects- Heatplot of Avg response to cue (by date)
 
 %gathering all mean data from time window around cue 
 
 
 for subj= 1:numel(subjectsAnalyzed) %for each subject
     
     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
 
     %we'll want to organize these by common date instead of relative
     %training day as well
     
     %First find out which dates this subj has data for
    %get all dates for this subj
    for session= 1:numel(currentSubj)
        subjDates(session)= currentSubj(session).date;
    end %end session loop
    
    %now find out which dates from allDates this subj has data for 
    for thisDate = 1:numel(allDates) %loop through all dates
        if isempty(subjDates(subjDates==allDates(thisDate))) %if this subj doesn't have valid data on this date
%                 emptyDates= cat(1, emptyDates,thisDate); %save this empty date to an array (add onto array by using cat())
                currentSubj(end+1).date= allDates(thisDate); %use end+1 to add a new empty session
                
                %fill relevant fields with NaN for later 
                currentSubj(end).periDS.DSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periDS.DSzpurpleMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzpurpleMean= NaN(size(timeLock'));
                
                currentSubj(end).periNS.NS= nan;

        end
    end
    
    %now let's resort the struct with empty sessions by date
     subjTable = struct2table(currentSubj); % convert the struct array to a table
     subjTableSorted = sortrows(subjTable, 'date'); % sort the table by 'date'
     currentSubj = table2struct(subjTableSorted); %convert back to struct

     
     
     NStrialCount= 1; %counter for ns sessions
     
     %now get the actual photometry data
     
     for session = 1:numel(currentSubj) %for each session this subject completed

         allRats.meanDSzblue(:,session,subj)= currentSubj(session).periDS.DSzblueMean;
         allRats.meanDSzpurple(:,session,subj)= currentSubj(session).periDS.DSzpurpleMean;

         if isempty(currentSubj(session).periNS.NS) %if there's no NS data, fill with NaNs
            currentSubj(session).periNS.NSzblueMean= NaN(size(timeLock'));
            currentSubj(session).periNS.NSzpurpleMean=  NaN(size(timeLock'));
         end
         
         allRats.meanNSzblue(:,session,subj)= currentSubj(session).periNS.NSzblueMean;
         allRats.meanNSzpurple(:,session,subj)= currentSubj(session).periNS.NSzpurpleMean;
         
%          if ~isempty(currentSubj(session).periNS.NS) %only run if NS data present
%             allRats.meanNSzblue(:,NStrialCount,subj)= currentSubj(session).periNS.NSzblueMean;
%             allRats.meanNSzpurple(:,NStrialCount,subj)= currentSubj(session).periNS.NSzpurpleMean;
%              
% %             allRats.subjTrialNS(NStrialCount,subj)= currentSubj(session).trainDay;
%             
%             NStrialCount= NStrialCount+1;
%             % zeros are appearing in sessions where there's no data! (e.g.
%             % rats are on different training days, so one can be on day 14
%             % ahead of others that are on day 13)
%                        %skipping from 6->10
%          else %if there's no NS data present, fill with nan (otherwise will fill with zeros)
%             allRats.meanNSzblue(:,session, subj)= nan(size(currentSubj(session).periDS.DSzblueMean));
%             allRats.meanNSzpurple(:,session,subj)= nan(size(currentSubj(session).periDS.DSzblueMean));        
%          end %end NS conditional
     end %end session loop
          
 end %end subj loop

 % mean of all rats per training day ( each column is a training day , each 3d page is a subject)
allRats.grandDSzblue=nanmean(allRats.meanDSzblue(:,:,:),3)'; %(:,:,1:4),3)' % doing 1:4 in 3rd dmension because rat8 is a GFP animal but need to find more robust way to do this
allRats.grandDSzpurple=nanmean(allRats.meanDSzpurple(:,:, :),3)'; %1:4),3)'
allRats.grandNSzblue=nanmean(allRats.meanNSzblue(:,:,:),3)';%'; %1:4),3)'
allRats.grandNSzpurple=nanmean(allRats.meanNSzpurple(:,:,:),3)'; %,1:4),3)'

 %get bottom and top for color axis of DS heatplot
 allRats.bottomMeanallDS = min(min(min(allRats.grandDSzblue)), min(min(allRats.grandDSzpurple))); %find the lowest value 
 allRats.topMeanallDS = max(max(max(allRats.grandDSzblue)), max(max(allRats.grandDSzpurple))); %find the highest value

 %get bottom and top for color axis of NS heatplot
 allRats.bottomMeanallNS = min(min(min(allRats.grandNSzblue)), min(min(allRats.grandNSzpurple)));
 allRats.topMeanallNS = max(max(max(allRats.grandNSzblue)), max(max(allRats.grandNSzpurple)));


%Establish a shared bottom and top for shared color axis of DS & NS means
    if ~isnan(allRats.bottomMeanallNS) %if there is an NS
        allRats.bottomMeanallShared= min(allRats.bottomMeanallDS, allRats.bottomMeanallNS); %find the absolute min value
        allRats.topMeanallShared= max(allRats.topMeanallDS, allRats.topMeanallNS); %find the absolute min value
    else
        allRats.bottomMeanallShared= allRats.bottomMeanallDS;
        allRats.topMeanallShared= allRats.topMeanallDS;
    end
    
 %get list of session days for heatplot y axis
%  for day= 1:size(allRats.grandDSzblue,1)   
%     allRats.subjTrialDS(day,1)= day;
%  end

    subjTrial= 1:numel(allDates); %let's just number each training day starting at 1

 
%get list of NS session days for heatplot y axis
% need to loop through all subjects and sessions, find unique trials with NS data
allRats.subjTrialNS=[];
 for subj = 1:numel(subjectsAnalyzed)

    currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing
    for session = 1:numel(currentSubj) %for each training session this subject completed
        if ~isempty(currentSubj(session).periNS.NS) %if there's an NS trial in this session, add it to the array that will mark the y axis
%              allRats.subjTrialNS= cat(2, allRats.subjTrialNS, currentSubj(session).trainDay);
%              disp(currentSubj(session).trainDay);
        end
    end %end session loop
     
     
 end %end subj loop
   
%get only unique elements of subjTrialNS
% allRats.subjTrialNS= unique(allRats.subjTrialNS);

% HEATPLOT

 %DS z plot
    figure(figureCount);
    figureCount=figureCount+1;
    hold on;
    subplot(2,2,1); %subplot for shared colorbar

    %plot blue DS

    timeLock = [-preCueFrames:postCueFrames]/fs;% [-periDSFrames:periDSFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatDSzblueMeanall= imagesc(timeLock,subjTrial,allRats.grandDSzblue);
    title(' All rats avg blue z score response to DS '); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleMeanall= imagesc(timeLock,subjTrial,allRats.grandDSzpurple); 

    title(' All rats avg purple z score response to DS ') %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); 

    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values
    
%     %% TODO: try linspace with caxis

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving




    %     %NS z plot
    %         figure(figureCount-1); %subplotting on the same figure as the DS heatplots
    hold on;
    subplot(2,2,2); %subplot for shared colorbar

    timeLock = [-preCueFrames:postCueFrames]/fs;%[-periDSFrames:periDSFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatNSzblueMeanall= imagesc(timeLock,subjTrial,allRats.grandNSzblue, 'AlphaData', ~isnan(allRats.grandNSzpurple));
    title(' All rats avg blue z score response to NS '); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple NS (subplotted for shared colorbar)
    subplot(2,2,4);
    heatNSzpurpleMean= imagesc(timeLock,subjTrial,allRats.grandNSzpurple, 'AlphaData', ~isnan(allRats.grandNSzpurple)); 

    title(' All rats avg purple z score response to NS ') %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); 
    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%  %% Between subjects response to cue on key transition sessions
% %avg response timelocked to ALL CUES on key transition sessions
% %(e.g. first day of training, first day with NS, last day of stage 5
% btwnSubjAllCues();
% 
% %% Between subjects response to FIRST PE after cue on key transition sessions
% %avg response timelocked to FIRST PE on key transition sessions
% %(e.g. first day of training, first day with NS, last day of stage 5
% 
% btwnSubjFirstPox();
% 
% %% Between subj response to cue- TRIALS NO PE 
% 
% btwnSubjNoPE();
% 
% %% Between subj response to cue- TRIALS WITH PE
% 
% btwnSubjonlyPE();
% 
% %% Between subj response to cue- TRIALS WHEN ALREADY IN PORT
% btwnSubjonlyInPort();

%% Trying some stat with visualization

%first spike after cue effect- seems like a rapid rise starting ~0.2s (maybe 0.3s on extinction day) like to start falling by 0.9s
effectStart= 0.3; % Define a time window of interest after cue onset within which we will look for an effect (this is t in seconds relative to cue onset)
effectEnd= 0.8;

cueOnsetTime= periCueFrames-postCueFrames;

effectWindow= effectStart*fs:effectEnd*fs; %Indices of the time window for the effect




%% ~~ Data vis- photometry & behavior ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Peri-cue activity by PE outcome (PE, noPE, or inPort)
% goal here is to plot peri-DS response for each stage based on trial outcome (either rat
% was in port at cue onset, made a PE during cue epoch, or
% did not make a PE)

%initialize some variables
allSubjPEDSblue= []; allSubjPEDSpurple= []; allSubjPENSblue= []; allSubjPENSpurple=[];
allSubjNoPEDSblue= []; allSubjNoPEDSpurple= []; allSubjNoPENSblue= []; allSubjNoPENSpurple= [];
allSubjInPortDSblue= []; allSubjInPortDSpurple= []; allSubjInPortNSblue= []; allSubjInPortNSpurple= [];

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    allStages= unique([currentSubj.trainStage]);
   
    for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
        includedSessions= []; %excluded sessions will reset between unique stages
        inPortDSblue= []; inPortDSpurple= []; noPEDSblue= []; noPEDSpurple= []; PEDSblue= []; PEDSpurple= []; %reset between sessions
        inPortNSblue= []; inPortNSpurple= []; noPENSblue= []; noPENSpurple= []; PENSblue= []; PENSpurple= []; %reset between sessions
        
        %loop through all sessions and record index of sessions that correspond only to this stage
        for session= 1:numel(currentSubj)
            if currentSubj(session).trainStage == thisStage %only include sessions from this stage
               includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
            end
        end%end session loop
    
         for includedSession= includedSessions %loop through only sessions that match this stage
            DSinPort= []; DSnoPE= []; DSPE= []; %reset between sessions
            NSinPort= []; NSnoPE= []; NSPE= [];
             %Extract data based on trial outcome
             
         %loop through each trial type (1= PE, 2= noPE, 3= inPort) and get
         %peri-DS response
                           
         %Here we will collect mean() peri-DS response within sessions,
         %that we can see if there's a particularly bad session that would
         %otherwise be hidden in a between-session mean
            for PEtrial= currentSubj(includedSession).trialOutcome.DSoutcome==1 %loop through trials and cat responses into one array
                PEDSblue= [PEDSblue, nanmean(currentSubj(includedSession).periDS.DSzblue(:,:,PEtrial),3)];
                PEDSpurple= [PEDSpurple, nanmean(currentSubj(includedSession).periDS.DSzpurple(:,:,PEtrial),3)];
            end
            
            for noPEtrial= currentSubj(includedSession).trialOutcome.DSoutcome==2 %loop through trials and cat responses into one array
                noPEDSblue= [noPEDSblue, nanmean(currentSubj(includedSession).periDS.DSzblue(:,:,noPEtrial),3)];
                noPEDSpurple= [noPEDSpurple, nanmean(currentSubj(includedSession).periDS.DSzpurple(:,:,noPEtrial),3)];
            end
            
            for inPortTrial = currentSubj(includedSession).trialOutcome.DSoutcome==3 %loop through trials and cat responses into one array
                inPortDSblue= [inPortDSblue, nanmean(currentSubj(includedSession).periDS.DSzblue(:,:,inPortTrial),3)];
                inPortDSpurple= [inPortDSpurple, nanmean(currentSubj(includedSession).periDS.DSzpurple(:,:,inPortTrial),3)];
            end  
            
            %repeat for NS
            PEtrial= []; noPEtrial= []; inPortTrial=[];
            for PEtrial= currentSubj(includedSession).trialOutcome.NSoutcome==1 %loop through trials and cat responses into one array
                PENSblue= [PENSblue, nanmean(currentSubj(includedSession).periNS.NSzblue(:,:,PEtrial),3)];
                PENSpurple= [PENSpurple, nanmean(currentSubj(includedSession).periNS.NSzpurple(:,:,PEtrial),3)];
            end
            
            for noPEtrial= currentSubj(includedSession).trialOutcome.NSoutcome==2 %loop through trials and cat responses into one array
                noPENSblue= [noPENSblue, nanmean(currentSubj(includedSession).periNS.NSzblue(:,:,noPEtrial),3)];
                noPENSpurple= [noPENSpurple, nanmean(currentSubj(includedSession).periNS.NSzpurple(:,:,noPEtrial),3)];
            end
            
            for inPortTrial = currentSubj(includedSession).trialOutcome.NSoutcome==3 %loop through trials and cat responses into one array
                inPortNSblue= [inPortNSblue, nanmean(currentSubj(includedSession).periNS.NSzblue(:,:,inPortTrial),3)];
                inPortNSpurple= [inPortNSpurple, nanmean(currentSubj(includedSession).periNS.NSzpurple(:,:,inPortTrial),3)];
            end    
            
         end %end includedSession loop         
        
          %collect data from all subjects for a between-subjects mean plot
        allSubjPEDSblue(:,thisStage,subj)= nanmean(PEDSblue,2);
        allSubjPEDSpurple(:,thisStage, subj)= nanmean(PEDSpurple,2);
        
        allSubjNoPEDSblue(:, thisStage, subj)= nanmean(noPEDSblue, 2);
        allSubjNoPEDSpurple(:, thisStage, subj)= nanmean(noPEDSpurple, 2);
        
        allSubjInPortDSblue(:,thisStage, subj)= nanmean(inPortDSblue, 2);
        allSubjInPortDSpurple(:,thisStage, subj)= nanmean(inPortDSpurple,2);

    
        if ~isempty(PENSblue)
           allSubjPENSblue(:,thisStage,subj)= nanmean(PENSblue,2);
           allSubjPENSpurple(:,thisStage,subj)= nanmean(PENSpurple,2);
           
           allSubjNoPENSblue(:,thisStage,subj)= nanmean(noPENSblue,2);
           allSubjNoPENSpurple(:,thisStage,subj)= nanmean(noPENSpurple,2);
           
              
           allSubjInPortNSblue(:,thisStage,subj)= nanmean(inPortNSblue,2);
           allSubjInPortNSpurple(:,thisStage,subj)= nanmean(inPortNSpurple,2);
        end
         
        figure(figureCount); hold on; sgtitle(strcat(subjectsAnalyzed{subj},'peri-DS response session means by PE outcome'));
        
        subplot(3, allStages(end), thisStage); hold on; title(strcat('No PE DS stage-',num2str(thisStage)));
        plot(timeLock, noPEDSblue, 'b');
        plot(timeLock, noPEDSpurple,'m');
        subplot(3,allStages(end), allStages(end)+thisStage); hold on; title(strcat('PE DS stage-',num2str(thisStage)));
        plot(timeLock, PEDSblue, 'b');
        plot(timeLock, PEDSpurple, 'm');
        subplot(3, allStages(end),  allStages(end)+allStages(end)+thisStage); hold on; title(strcat('inPort DS stage-',num2str(thisStage)));
        plot(timeLock, inPortDSblue, 'b');
        plot(timeLock, inPortDSpurple, 'm');

        linkaxes();

            %todo : overlay mean & SEM
        
        xlabel('time from DS onset');
        ylabel(' 465nm z score response');

        %repeat for NS
        if thisStage>= 5%only run for stages with NS
            figure(figureCount+1); hold on; sgtitle(strcat(subjectsAnalyzed{subj},'peri-NS response session means by PE outcome'));

            subplot(3, allStages(end), thisStage); hold on; title(strcat('No PE NS stage-',num2str(thisStage)));
            plot(timeLock, noPENSblue, 'b');
            plot(timeLock, noPENSpurple,'m');
            subplot(3,allStages(end), allStages(end)+thisStage); hold on; title(strcat('PE NS stage-',num2str(thisStage)));
            plot(timeLock, PENSblue, 'b');
            plot(timeLock, PENSpurple, 'm');
            subplot(3, allStages(end),  allStages(end)+allStages(end)+thisStage); hold on; title(strcat('inPort NS stage-',num2str(thisStage)));
            plot(timeLock, inPortNSblue, 'b');
            plot(timeLock, inPortNSpurple, 'm');
        end %end NS stage conditional
        linkaxes();
        
    end %end Stage loop 
       set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
       set(figure(figureCount), 'Position', get(0, 'Screensize'));
%        linkaxes();

      figureCount= figureCount+2; %+2 because alternating plot on separate DS & NS figures
end %end subj loop

%replace columns that have all zeros with nans (this could happen if an animal
%didn't run a particular stage)
for subj= 1:numel(subjects)
    allSubjPEDSblue(:,find(all(allSubjPEDSblue(:,:,subj)==0)),subj)= nan;
    allSubjPEDSpurple(:,find(all(allSubjPEDSpurple(:,:,subj)==0)), subj)= nan;
    
    allSubjNoPEDSblue(:,find(all(allSubjNoPEDSblue(:,:,subj)==0)), subj)= nan;
    allSubjNoPEDSpurple(:,find(all(allSubjNoPEDSpurple(:,:,subj)==0)), subj)= nan;
    
    allSubjInPortDSblue(:,find(all(allSubjInPortDSblue(:,:,subj)==0)), subj)= nan;
    allSubjInPortDSpurple(:,find(all(allSubjInPortDSpurple(:,:,subj)==0)), subj)= nan;
    
    allSubjPENSblue(:,find(all(allSubjPENSblue(:,:,subj)==0)),subj)= nan;
    allSubjPENSpurple(:,find(all(allSubjPENSpurple(:,:,subj)==0)), subj)= nan;
    
    allSubjNoPENSblue(:,find(all(allSubjNoPENSblue(:,:,subj)==0)), subj)= nan;
    allSubjNoPENSpurple(:,find(all(allSubjNoPENSpurple(:,:,subj)==0)), subj)= nan;
    
    allSubjInPortNSblue(:,find(all(allSubjInPortNSblue(:,:,subj)==0)), subj)= nan;
    allSubjInPortNSpurple(:,find(all(allSubjInPortNSpurple(:,:,subj)==0)), subj)= nan;


end

% Now make a between-subj plot of mean across all animals
    %DS
figure;
figureCount=figureCount+1; sgtitle('peri-DS response by PE outcome: mean between subjects ');
for subj= 1:numel(subjects)
    for thisStage= 1:size(allSubjDSblue,2) 
        thisStagePEDSblue= nanmean(allSubjPEDSblue(:,thisStage,:),3);
        thisStagePEDSpurple= nanmean(allSubjPEDSpurple(:,thisStage,:),3);
        
        thisStageNoPEDSDSblue= nanmean(allSubjNoPEDSblue(:,thisStage,:),3);
        thisStageNoPEDSpurple= nanmean(allSubjNoPEDSpurple(:,thisStage,:),3);

        thisStageInPortDSblue= nanmean(allSubjInPortDSblue(:,thisStage,:),3);
        thisStageInPortDSpurple= nanmean(allSubjInPortDSpurple(:,thisStage,:),3);

                %DS
        subplot(subplot(3, size(allSubjPEDSblue,2), thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'DS with port entry')) 
        plot(timeLock, (allSubjPEDSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjDSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStagePEDSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStagePEDSpurple,'r','LineWidth',2); %plot between-subjects mean purple
      
        subplot(subplot(3, size(allSubjPEDSblue,2), size(allSubjPEDSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'DS with no port entry')) 
        plot(timeLock, (allSubjNoPEDSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjNoPEDSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageNoPEDSDSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageNoPEDSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        subplot(subplot(3, size(allSubjPEDSblue,2), size(allSubjPEDSblue,2)+size(allSubjPEDSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'in Port at DS onset')) 
        plot(timeLock, (allSubjInPortDSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjInPortDSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageInPortDSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageInPortDSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        if thisStage==1
           legend('465 individual subj mean', '405 individual subj mean', '465 all subj mean','405 all subj mean');
        end
    end
end

linkaxes(); %link axes for scale comparison


%NS
figure;
figureCount=figureCount+1; sgtitle('peri-NS response by PE outcome: mean between subjects ');
for subj= 1:numel(subjects)
    for thisStage= 1:size(allSubjNSblue,2) 
        thisStagePENSblue= nanmean(allSubjPENSblue(:,thisStage,:),3);
        thisStagePENSpurple= nanmean(allSubjPENSpurple(:,thisStage,:),3);
        
        thisStageNoPENSNSblue= nanmean(allSubjNoPENSblue(:,thisStage,:),3);
        thisStageNoPENSpurple= nanmean(allSubjNoPENSpurple(:,thisStage,:),3);

        thisStageInPortNSblue= nanmean(allSubjInPortNSblue(:,thisStage,:),3);
        thisStageInPortNSpurple= nanmean(allSubjInPortNSpurple(:,thisStage,:),3);

                %NS
        subplot(subplot(3, size(allSubjPENSblue,2), thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'NS with port entry')) 
        plot(timeLock, (allSubjPENSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjNSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStagePENSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStagePENSpurple,'r','LineWidth',2); %plot between-subjects mean purple
      
        subplot(subplot(3, size(allSubjPENSblue,2), size(allSubjPENSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'NS with no port entry')) 
        plot(timeLock, (allSubjNoPENSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjNoPENSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageNoPENSNSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageNoPENSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        subplot(subplot(3, size(allSubjPENSblue,2), size(allSubjPENSblue,2)+size(allSubjPENSblue,2)+thisStage)); hold on; title(strcat('stage-',num2str(thisStage),'in Port at NS onset')) 
        plot(timeLock, (allSubjInPortNSblue(:,thisStage,subj)),'b--'); %plot each individual subject mean blue
        plot(timeLock, (allSubjInPortNSpurple(:,thisStage, subj)), 'm--'); %plot each individual subject mean purple
        plot(timeLock, thisStageInPortNSblue,'k','LineWidth',2); %plot between-subjects mean blue
        plot(timeLock, thisStageInPortNSpurple,'r','LineWidth',2); %plot between-subjects mean purple
        
        if thisStage==1
           legend('465 individual subj mean', '405 individual subj mean', '465 all subj mean','405 all subj mean');
        end
    end
end
linkaxes();

%% Scatter of cue-elicited response vs. port entry outcome (does cue elicited response predict PE?)

%goal here will be to create scatter of mean response to cue with 3 different outcomes: no PE, PE, or already in port (denoted by color of plot) 

%first set parameters
cueResponseLastFrame=.8*fs; %time after cue over which to take avg activity (t in seconds * fs)
cueResponseFirstFrame= (periCueFrames-postCueFrames)+ (.5*fs); %first frame after cue onset = (periCueFrames-postCueFrames)+1
for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    allStages= unique([currentSubj.trainStage]);
   
    for thisStage= allStages %~~ Here we vectorize the field 'trainStage' to get the unique values easily %we'll loop through each unique stage
        includedSessions= []; %excluded sessions will reset between unique stages
        
        inPortDSblue= []; inPortDSpurple= []; noPEDSblue= []; noPEDSpurple= []; PEDSblue= []; PEDSpurple= []; %reset between sessions
        inPortNSblue= []; inPortNSpurple= []; noPENSblue= []; noPENSpurple= []; PENSblue= []; PENSpurple= []; %reset between sessions
        
        %loop through all sessions and record index of sessions that correspond only to this stage
        for session= 1:numel(currentSubj)
            if currentSubj(session).trainStage == thisStage %only include sessions from this stage
               includedSessions= [includedSessions, session]; % just cat() this session into the list of sessions to save
            end
        end%end session loop
    
         for includedSession= includedSessions %loop through only sessions that match this stage
            DSinPort= []; DSnoPE= []; DSPE= []; %reset between sessions
            NSinPort= []; NSnoPE= []; NSPE= [];
             %Extracting cue response
             %to do so, will use
             %cueOnsetFrame:cueOnsetFrame+cueResponseFrames as indices to
             %pull out relevant photometry data and will take the mean()

              %Identify trials where animal was in port at trial start,
              %trials with no PE, and trials with a valid PE. For each
              %trial type, loop through trials and get mean
              %cue-elicited response 

                %First, let's get trials where animal was already in port
                DSinPort= find(~isnan(currentSubj(includedSession).behavior.inPortDS));

                %Then, let's get trials where animal did not make a PE during the cue epoch. (cellfun('isempty'))
                DSnoPE = find(cellfun('isempty', currentSubj(includedSession).behavior.poxDS));
                 %additional check here to make sure animal was not in the
                %port at trial start even if a valid PE exists
                 for inPortTrial= DSinPort
                    DSnoPE(DSnoPE==inPortTrial)=[]; %eliminate trials where animal was in port
                 end
                 
             %lastly, get trials with valid PE
             DSPE= find(~cellfun('isempty', currentSubj(includedSession).behavior.poxDS));
              %additional check here to make sure animal was not in the
                %port at trial start even if a valid PE exists
             for inPortTrial= DSinPort
                 DSPE(DSPE==inPortTrial)=[]; %eliminate trials where animal was in port
             end
             
                %Make sure the trial types are all mutually exclusive to prevent errors (intersect() should return empty because no trials should be the same) 
             if ~isempty(intersect(DSinPort,DSnoPE)) || ~isempty(intersect(DSinPort, DSPE)) || ~isempty(intersect(DSnoPE, DSPE))
                disp('~~~~~~~~error: trial types not mutually exclusive');
             end
             
             %Repeat for NS trials
             %First, let's get trials where animal was already in port
                NSinPort= find(~isnan(currentSubj(includedSession).behavior.inPortNS));

                %Then, let's get trials where animal did not make a PE during the cue epoch. (cellfun('isempty'))
                NSnoPE = find(cellfun('isempty', currentSubj(includedSession).behavior.poxNS))'; %transpose ' due to shape
                 %additional check here to make sure animal was not in the
                %port at trial start even if a valid PE exists
                 for inPortTrial= NSinPort
                    NSnoPE(NSnoPE==inPortTrial)=[]; %eliminate trials where animal was in port
                 end
                 
             %lastly, get trials with valid PE
             NSPE= find(~cellfun('isempty', currentSubj(includedSession).behavior.poxNS))'; %transpose ' due to shape
              %additional check here to make sure animal was not in the
                %port at trial start even if a valid PE exists
             for inPortTrial= NSinPort
                 NSPE(NSPE==inPortTrial)=[]; %eliminate trials where animal was in port
             end
             
                %Make sure the trial types are all mutually exclusive to prevent errors (intersect() should return empty because no trials should be the same) 
             if ~isempty(intersect(NSinPort,NSnoPE)) || ~isempty(intersect(NSinPort, NSPE)) || ~isempty(intersect(NSnoPE, NSPE))
                disp('~~~~~~~~error: trial types not mutually exclusive');
             end
             
             
         %Now, loop through each trial type and get mean cue response for each trial
            for inPortTrial = DSinPort %loop through trials and cat mean response into one array
                inPortDSblue= [inPortDSblue, nanmean(currentSubj(includedSession).periDS.DSzblue(cueResponseFirstFrame:cueResponseFirstFrame+cueResponseLastFrame,:,inPortTrial))];
            end    

            for noPEtrial= DSnoPE
                noPEDSblue= [noPEDSblue, nanmean(currentSubj(includedSession).periDS.DSzblue(cueResponseFirstFrame:cueResponseFirstFrame+cueResponseLastFrame,:,noPEtrial))];
            end

            for PEtrial= DSPE
                PEDSblue= [PEDSblue, nanmean(currentSubj(includedSession).periDS.DSzblue(cueResponseFirstFrame:cueResponseFirstFrame+cueResponseLastFrame,:,PEtrial))];
            end   

            if thisStage >= 5
                for inPortTrial = NSinPort %loop through trials and cat mean response into one array
                    inPortNSblue= [inPortNSblue, nanmean(currentSubj(includedSession).periNS.NSzblue(cueResponseFirstFrame:cueResponseFirstFrame+cueResponseLastFrame,:,inPortTrial))];
                end    

                for noPEtrial= NSnoPE
                    noPENSblue= [noPENSblue, nanmean(currentSubj(includedSession).periNS.NSzblue(cueResponseFirstFrame:cueResponseFirstFrame+cueResponseLastFrame,:,noPEtrial))];
                end

                for PEtrial= NSPE
                    PENSblue= [PENSblue, nanmean(currentSubj(includedSession).periNS.NSzblue(cueResponseFirstFrame:cueResponseFirstFrame+cueResponseLastFrame,:,PEtrial))];
                end
            end
          
         end %end includedSession loop
        
               %TODO: would be much more efficient to loop through trial
               %types (inPort, PE, noPE) instead of having discrete
               %variables for each
         %calculate within-subjects & within-stage SEM 
         SEMinPortDSblue= nanstd(inPortDSblue)/sqrt(numel(inPortDSblue)); %calculate SEM for each stage (n= # trials with this PE outcome)
         SEMnoPEDSblue= nanstd(noPEDSblue)/sqrt(numel(noPEDSblue));
         SEMPEDSblue= nanstd(PEDSblue)/sqrt(numel(noPEDSblue));
         
         SEMinPortNSblue= nanstd(inPortNSblue)/sqrt(numel(inPortNSblue)); %calculate SEM for each stage (n= # trials with this PE outcome)
         SEMnoPENSblue= nanstd(noPENSblue)/sqrt(numel(noPENSblue));
         SEMPENSblue= nanstd(PENSblue)/sqrt(numel(noPENSblue));
         
        
        figure(figureCount); hold on; sgtitle(strcat(subjectsAnalyzed{subj},'-PE outcome vs. mean cue response (',num2str(cueResponseFirstFrame/fs-preCueFrames/fs) ,': ' ,num2str(cueResponseLastFrame/fs),' s)'));
        subplot(2, allStages(end), thisStage); title(strcat('DS stage-',num2str(thisStage))); hold on;
%         histogram(inPortDSblue); %hist
%         histogram(noPEDSblue);
%         histogram(PEDSblue);
%         xlabel('mean 465nm DS response');
%         ylabel('trial count');
        scatter(ones(1,numel(inPortDSblue)), inPortDSblue); %scatter
        scatter(2*ones(1,numel(noPEDSblue)), noPEDSblue);
        scatter(3*ones(1,numel(PEDSblue)), PEDSblue);
        
            %overlay mean & SEM
        plot([1-.2, 1+.2], [nanmean(inPortDSblue), nanmean(inPortDSblue)], 'k');
        plot([1-.2,1+.2] , [nanmean(inPortDSblue)+SEMinPortDSblue, nanmean(inPortDSblue)+SEMinPortDSblue], 'k--');%overlay + sem of each subject
        plot([1-.2,1+.2] , [nanmean(inPortDSblue)-SEMinPortDSblue, nanmean(inPortDSblue)-SEMinPortDSblue], 'k--');%overlay - sem of each subject
        plot([1, 1], [nanmean(inPortDSblue),nanmean(inPortDSblue)-SEMinPortDSblue], 'k--'); %connect -SEM to mean
        plot([1, 1], [nanmean(inPortDSblue),nanmean(inPortDSblue)+SEMinPortDSblue], 'k--'); %connect -SEM to mean
        
        plot([2-.2, 2+.2], [nanmean(noPEDSblue), nanmean(noPEDSblue)], 'k');
        plot([2-.2,2+.2] , [nanmean(noPEDSblue)+SEMnoPEDSblue, nanmean(noPEDSblue)+SEMnoPEDSblue], 'k--');%overlay + sem of each subject
        plot([2-.2,2+.2] , [nanmean(noPEDSblue)-SEMnoPEDSblue, nanmean(noPEDSblue)-SEMnoPEDSblue], 'k--');%overlay - sem of each subject
        plot([2, 2], [nanmean(noPEDSblue),nanmean(noPEDSblue)-SEMnoPEDSblue], 'k--'); %connect -SEM to mean
        plot([2, 2], [nanmean(noPEDSblue),nanmean(noPEDSblue)+SEMnoPEDSblue], 'k--'); %connect -SEM to mean
        
        plot([3-.2, 3+.2], [nanmean(PEDSblue), nanmean(PEDSblue)], 'k');
        plot([3-.2,3+.2] , [nanmean(PEDSblue)+SEMPEDSblue, nanmean(PEDSblue)+SEMPEDSblue], 'k--');%overlay + sem of each subject
        plot([3-.2,3+.2] , [nanmean(PEDSblue)-SEMPEDSblue, nanmean(PEDSblue)-SEMPEDSblue], 'k--');%overlay - sem of each subject
        plot([3, 3], [nanmean(PEDSblue),nanmean(PEDSblue)-SEMPEDSblue], 'k--'); %connect -SEM to mean
        plot([3, 3], [nanmean(PEDSblue),nanmean(PEDSblue)+SEMPEDSblue], 'k--'); %connect -SEM to mean
        
        xlim([0,4]);
        
        xlabel('PE outcome');
        ylabel('mean 465nm z score response');
        if thisStage==allStages(1)
           legend('in port at cue onset', 'no port entry (unrewarded)', 'port entry during cue epoch (rewarded)'); 
        end
        
            %NS plot
        subplot(2,allStages(end), allStages(end)+thisStage); title(strcat('NS stage-', num2str(thisStage))); hold on;
        scatter(ones(1,numel(inPortNSblue)), inPortNSblue); %scatter
        scatter(2*ones(1,numel(noPENSblue)), noPENSblue);
        scatter(3*ones(1,numel(PENSblue)), PENSblue);
        
                    %overlay mean & SEM
        plot([1-.2, 1+.2], [nanmean(inPortNSblue), nanmean(inPortNSblue)], 'k');
        plot([1-.2,1+.2] , [nanmean(inPortNSblue)+SEMinPortNSblue, nanmean(inPortNSblue)+SEMinPortNSblue], 'k--');%overlay + sem of each subject
        plot([1-.2,1+.2] , [nanmean(inPortNSblue)-SEMinPortNSblue, nanmean(inPortNSblue)-SEMinPortNSblue], 'k--');%overlay - sem of each subject
        plot([1, 1], [nanmean(inPortNSblue),nanmean(inPortNSblue)-SEMinPortNSblue], 'k--'); %connect -SEM to mean
        plot([1, 1], [nanmean(inPortNSblue),nanmean(inPortNSblue)+SEMinPortNSblue], 'k--'); %connect -SEM to mean
        
        plot([2-.2, 2+.2], [nanmean(noPENSblue), nanmean(noPENSblue)], 'k');
        plot([2-.2,2+.2] , [nanmean(noPENSblue)+SEMnoPENSblue, nanmean(noPENSblue)+SEMnoPENSblue], 'k--');%overlay + sem of each subject
        plot([2-.2,2+.2] , [nanmean(noPENSblue)-SEMnoPENSblue, nanmean(noPENSblue)-SEMnoPENSblue], 'k--');%overlay - sem of each subject
        plot([2, 2], [nanmean(noPENSblue),nanmean(noPENSblue)-SEMnoPENSblue], 'k--'); %connect -SEM to mean
        plot([2, 2], [nanmean(noPENSblue),nanmean(noPENSblue)+SEMnoPENSblue], 'k--'); %connect -SEM to mean
        
        plot([3-.2, 3+.2], [nanmean(PENSblue), nanmean(PENSblue)], 'k');
        plot([3-.2,3+.2] , [nanmean(PENSblue)+SEMPENSblue, nanmean(PENSblue)+SEMPENSblue], 'k--');%overlay + sem of each subject
        plot([3-.2,3+.2] , [nanmean(PENSblue)-SEMPENSblue, nanmean(PENSblue)-SEMPENSblue], 'k--');%overlay - sem of each subject
        plot([3, 3], [nanmean(PENSblue),nanmean(PENSblue)-SEMPENSblue], 'k--'); %connect -SEM to mean
        plot([3, 3], [nanmean(PENSblue),nanmean(PENSblue)+SEMPENSblue], 'k--'); %connect -SEM to mean
        
        xlim([0,4]);
        
        xlabel('PE outcome');
        ylabel('mean 465nm z score response');
        if thisStage==allStages(1)
           legend('in port at cue onset', 'no port entry (unrewarded)', 'port entry during cue epoch (unrewarded)'); 
        end
        
    end %end Stage loop 
       set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%        linkaxes();

      figureCount= figureCount+1;
end %end subj loop

    
%% Scatter of cue-elicited response vs. port entry latency
%This only includes trials that had a valid PE
% 
% %first set parameters
% cueResponseFrames=1*fs; %time after cue over which to take avg activity 
% cueOnsetFrame= (periCueFrames-postCueFrames)+1;
% 
% for subj= 1:numel(subjects) %for each subject
%    currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%        
%     %initialize/clear arrays between subjects
%     currentSubj(1).NSzblueAllTrials= [];
%     currentSubj(1).NSzpurpleAllTrials= [];
%     currentSubj(1).NSpeLatencyAllTrials= [];
% 
%     sesCountA= 1;
%     sesCountB= 1;
%     sesCountC= 1;
%     sesCountD=1;
% 
%     subjSessA= [];
%     subjSessB= [];
%     subjSessC= [];
%     subjSessD= [];
%     
%     trialAcount= 1;
%     trialBcount=1;
%     trialCcount=1;
%     trialDcount=1;
%     
%     trialBNScount=1;
%     trialCNScount=1;
%     trialDNScount=1;
%     
%     DSloxAllTrialsA = [];
%     DSloxAllTrialsB= [];
%     DSloxAllTrialsC= [];
%     DSloxAllTrialsD= [];
%     
%     NSloxAllTrialsA= [];
%     NSloxAllTrialsB= [];
%     NSloxAllTrialsC= [];
%     NSloxAllTrialsD= [];
%     
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%        
%         clear NSselected
%         
%         %We can only include trials that have a PE latency, so we need to
%         %selectively extract these data first
%         
%             %get the DS cues
%         DSselected= currentSubj(session).periDS.DS;  % all the DS cues
% 
%         %First, let's exclude trials where animal was already in port
%         %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
%         %have a non-nan value and use these to exclude DS trials from this
%         %analysis (we'll make them nan)
%             
%         %We have to throw in an extra conditional in case we've excluded
%         %cues in our peri cue analysis due to being too close to the
%         %beginning or end. Otherwise, we can get an out of range error
%         %because the inPortDS array doesn't exclude these cues.
%         for inPortTrial = find(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS))
%             if inPortTrial < numel(DSselected) 
%                 DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;
%             end
%         end
%         %Then, let's exclude trials where animal didn't make a PE during
%         %the cue epoch. To do so, get indices of empty cells in
%         %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
%         %happened during the cue epoch) and then use these to set that DS =
%         %nan
%         
%         %same here, we need an extra conditional in case cues were excluded
%         for noPEtrial = find(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS))
%             if noPEtrial < numel(DSselected)
%                 DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
%             end
%         end
%         
%         %this may create some zeros, so let's make those nan as well
%         DSselected(DSselected==0) = nan;
%         
%         %lets convert this to an index of trials with a valid value 
%         DSselected= find(~isnan(DSselected));
%         
%             %Repeat above for NS 
%         if ~isempty(currentSubj(session).periNS.NS)
%              NSselected= currentSubj(session).periNS.NS;  
% 
%             %First, let's exclude trials where animal was already in port
%             %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
%             %have a non-nan value and use these to exclude NS trials from this
%             %analysis (we'll make them nan)
% 
%             NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;
% 
%             %Then, let's exclude trials where animal didn't make a PE during
%             %the cue epoch. To do so, get indices of empty cells in
%             %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
%             %happened during the cue epoch) and then use these to set that NS =
%             %nan
%             NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
% 
%        
%             %lets convert this to an index of trials with a valid value 
%             NSselected= find(~isnan(NSselected));
%         end %end NS conditional       
%         
%         %Condition A
%             if currentSubj(session).trainStage <5
%                 if sesCountA== 1 
%                     currentSubj(1).DSzblueAllTrialsA= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                     currentSubj(1).DSzpurpleAllTrialsA= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                     currentSubj(1).DSpeLatencyAllTrialsA= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                     
% %                     currentSubj(1).DSloxAllTrialsA= currentSubj(session).behavior.loxDS{DSselected};
%                     if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                         currentSubj(1).NSzblueAllTrialsA= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
%                         currentSubj(1).NSzpurpleAllTrialsA= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
%                         currentSubj(1).NSpeLatencyAllTrialsA= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                         
%                      else
% %                        continue %continue if no NS data
%                      end
%                 else %add subsequent sessions using cat()
%                     currentSubj(1).DSzblueAllTrialsA = cat(2, currentSubj.DSzblueAllTrialsA, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).DSzpurpleAllTrialsA = cat(2, currentSubj.DSzpurpleAllTrialsA, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).DSpeLatencyAllTrialsA = cat(2,currentSubj(1).DSpeLatencyAllTrialsA,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
% %                     currentSubj(1).DSloxAllTrialsA= cat(2,currentSubj(1).DSloxAllTrialsA,currentSubj(session).behavior.loxDS{DSselected});
% 
%                     if ~isempty(currentSubj(session).periNS.NS)
%                         currentSubj(1).NSzblueAllTrialsA = cat(2, currentSubj.NSzblueAllTrialsA, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                         currentSubj(1).NSzpurpleAllTrialsA = cat(2, currentSubj.NSzpurpleAllTrialsA, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                         currentSubj(1).NSpeLatencyAllTrialsA = cat(2,currentSubj(1).NSpeLatencyAllTrialsA,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                     else
% %                         continue %continue if no NS data
%                     end
%                 end %end sesCount conditional
% 
%                     % licks
%                     currentSubj(1).DSloxAllTrialsA{sesCountA}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
%                 
%                      %in order to sort licks according to trial by PE latency
%                      %later, we need to reshape the lox cell array from nested
%                      %{session}{cue} to just {cue}
%                       for cue = 1:numel(currentSubj(1).DSloxAllTrialsA{session})
%                           DSloxAllTrialsA{trialAcount} = currentSubj(1).DSloxAllTrialsA{session}{cue};
%                           trialAcount=trialAcount+1;
%                       end           
% 
% %                       trialAcount=1; %reset counter
% %                       % NS licks
% %                     currentSubj(1).NSloxAllTrialsA{session}= currentSubj(session).behavior.loxNSrel(NSselected);
% %                     
% %                     for cue= 1:numel(currentSubj(1).NSloxAllTrialsA{session})
% %                         NSloxAllTrialsA{trialAcount}= currentSubj(1).NSloxAllTrialsA{session}{cue};
% %                         trialAcount=trialAcount+1;
% %                     end
% %                         
%                       
%                 sesCountA= sesCountA+1;
%                 subjSessA= cat(2, subjSessA, currentSubj(session).trainDay); %day count for y axis
% 
%             end %end Cond A
%             
%             %Condition B
%                    if currentSubj(session).trainStage ==5
%                         if sesCountB== 1 
%                             currentSubj(1).DSzblueAllTrialsB= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                             currentSubj(1).DSzpurpleAllTrialsB= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                             currentSubj(1).DSpeLatencyAllTrialsB= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                              if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                                 currentSubj(1).NSzblueAllTrialsB= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
%                                 currentSubj(1).NSzpurpleAllTrialsB= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
%                                 currentSubj(1).NSpeLatencyAllTrialsB= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                              else
% %                                continue %continue if no NS data
%                              end
%                         else %add subsequent sessions using cat()
%                             currentSubj(1).DSzblueAllTrialsB = cat(2, currentSubj.DSzblueAllTrialsB, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                             currentSubj(1).DSzpurpleAllTrialsB = cat(2, currentSubj.DSzpurpleAllTrialsB, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                             currentSubj(1).DSpeLatencyAllTrialsB = cat(2,currentSubj(1).DSpeLatencyAllTrialsB,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
%                             if ~isempty(currentSubj(session).periNS.NS)
%                                 currentSubj(1).NSzblueAllTrialsB = cat(2, currentSubj.NSzblueAllTrialsB, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                                 currentSubj(1).NSzpurpleAllTrialsB = cat(2, currentSubj.NSzpurpleAllTrialsB, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                                 currentSubj(1).NSpeLatencyAllTrialsB = cat(2,currentSubj(1).NSpeLatencyAllTrialsB,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                             else
% %                                 continue %continue if nos NS data
%                             end
%                         end %end sesCount conditional
% 
%                         
%                          %licks
%                         currentSubj(1).DSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
% 
%                         currentSubj(1).NSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxNSrel(NSselected);
% 
%                         
%                          %in order to sort licks according to trial by PE latency
%                          %later, we need to reshape the lox cell array from nested
%                          %{session}{cue} to just {cue}
%                           for cue = 1:numel(currentSubj(1).DSloxAllTrialsB{sesCountB})
%                               DSloxAllTrialsB{trialBcount} = currentSubj(1).DSloxAllTrialsB{sesCountB}{cue};
%                               trialBcount=trialBcount+1;
%                           end           
%                                             
%                         for cue= 1:numel(currentSubj(1).NSloxAllTrialsB{sesCountB})
%                             NSloxAllTrialsB{trialBNScount}= currentSubj(1).NSloxAllTrialsB{sesCountB}{cue};
%                             trialBNScount=trialBNScount+1;
%                         end
% 
%                         
%                         sesCountB= sesCountB+1;
%                         subjSessB= cat(2, subjSessB, currentSubj(session).trainDay); %day count for y axis
% 
%                   end %end Cond B
%                   
%               %Condition C
%                if currentSubj(session).trainStage== 6 || currentSubj(session).trainStage ==7
%                    
%                     if sesCountC== 1 
%                         currentSubj(1).DSzblueAllTrialsC= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                         currentSubj(1).DSzpurpleAllTrialsC= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                         currentSubj(1).DSpeLatencyAllTrialsC= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                          if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                             currentSubj(1).NSzblueAllTrialsC= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
%                             currentSubj(1).NSzpurpleAllTrialsC= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
%                             currentSubj(1).NSpeLatencyAllTrialsC= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                          else
% %                            continue %continue if no NS data
%                          end
%                     else %add subsequent sessions using cat()
%                         currentSubj(1).DSzblueAllTrialsC = cat(2, currentSubj.DSzblueAllTrialsC, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSzpurpleAllTrialsC = cat(2, currentSubj.DSzpurpleAllTrialsC, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSpeLatencyAllTrialsC = cat(2, currentSubj(1).DSpeLatencyAllTrialsC, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
%                         if ~isempty(currentSubj(session).periNS.NS)
%                             currentSubj(1).NSzblueAllTrialsC = cat(2, currentSubj.NSzblueAllTrialsC, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                             currentSubj(1).NSzpurpleAllTrialsC = cat(2, currentSubj.NSzpurpleAllTrialsC, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                             currentSubj(1).NSpeLatencyAllTrialsC = cat(2,currentSubj(1).NSpeLatencyAllTrialsC,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                         else
% %                             continue %continue if nos NS data
%                         end
%                     end %end sesCount conditional
% 
%                         %licks
%                         currentSubj(1).DSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
% 
%                         currentSubj(1).NSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxNSrel(NSselected);
% 
%                         
%                          %in order to sort licks according to trial by PE latency
%                          %later, we need to reshape the lox cell array from nested
%                          %{session}{cue} to just {cue}
%                           for cue = 1:numel(currentSubj(1).DSloxAllTrialsC{sesCountC})
%                               DSloxAllTrialsC{trialCcount} = currentSubj(1).DSloxAllTrialsC{sesCountC}{cue};
%                               trialCcount=trialCcount+1;
%                           end           
%                                             
%                         for cue= 1:numel(currentSubj(1).NSloxAllTrialsC{sesCountC})
%                             NSloxAllTrialsC{trialCNScount}= currentSubj(1).NSloxAllTrialsC{sesCountC}{cue};
%                             trialCNScount=trialCNScount+1;
%                         end
% 
%                     sesCountC= sesCountC+1;
%                     subjSessC= cat(2, subjSessC, currentSubj(session).trainDay); %day count for y axis
% 
%               end %end Cond C
%               
%                      
%               %Condition D
%                if currentSubj(session).trainStage==8
%                    
%                     if sesCountD== 1 
%                         currentSubj(1).DSzblueAllTrialsD= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                         currentSubj(1).DSzpurpleAllTrialsD= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
%                         currentSubj(1).DSpeLatencyAllTrialsD= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                          if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                             currentSubj(1).NSzblueAllTrialsD= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
%                             currentSubj(1).NSzpurpleAllTrialsD= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
%                             currentSubj(1).NSpeLatencyAllTrialsD= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                          else
% %                            continue %continue if no NS data
%                          end
%                     else %add subsequent sessions using cat()
%                         currentSubj(1).DSzblueAllTrialsD = cat(2, currentSubj.DSzblueAllTrialsD, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSzpurpleAllTrialsD = cat(2, currentSubj.DSzpurpleAllTrialsD, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSpeLatencyAllTrialsD = cat(2, currentSubj(1).DSpeLatencyAllTrialsD, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
%                         if ~isempty(currentSubj(session).periNS.NS)
%                             currentSubj(1).NSzblueAllTrialsD = cat(2, currentSubj.NSzblueAllTrialsD, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                             currentSubj(1).NSzpurpleAllTrialsD = cat(2, currentSubj.NSzpurpleAllTrialsD, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
%                             currentSubj(1).NSpeLatencyAllTrialsD = cat(2,currentSubj(1).NSpeLatencyAllTrialsD,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                         else
% %                             continue %continue if nos NS data
%                         end
%                     end %end sesCount conditional
% 
%                         %licks
%                         currentSubj(1).DSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
% 
%                         currentSubj(1).NSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxNSrel(NSselected);
% 
%                         
%                          %in order to sort licks according to trial by PE latency
%                          %later, we need to reshape the lox cell array from nested
%                          %{session}{cue} to just {cue}
%                           for cue = 1:numel(currentSubj(1).DSloxAllTrialsD{sesCountD})
%                               DSloxAllTrialsD{trialDcount} = currentSubj(1).DSloxAllTrialsD{sesCountD}{cue};
%                               trialDcount=trialDcount+1;
%                           end           
%                                             
%                         for cue= 1:numel(currentSubj(1).NSloxAllTrialsD{sesCountD})
%                             NSloxAllTrialsD{trialDNScount}= currentSubj(1).NSloxAllTrialsD{sesCountD}{cue};
%                             trialDNScount=trialDNScount+1;
%                         end
% 
%                     sesCountD= sesCountD+1;
%                     subjSessD= cat(2, subjSessD, currentSubj(session).trainDay); %day count for y axis
% 
%               end %end Cond D
%              
%    end %end session loop
%    
%    
%    %now get the mean z value within the cueResponseFrames
%         %cond A
%    currentSubj(1).meanDSzblueResponseA= nanmean(currentSubj(1).DSzblueAllTrialsA,1);
%    currentSubj(1).meanDSzpurpleResponseA= nanmean(currentSubj(1).DSzpurpleAllTrialsA,1);
%    
%         %cond B
%    currentSubj(1).meanDSzblueResponseB= nanmean(currentSubj(1).DSzblueAllTrialsB,1);
%    currentSubj(1).meanDSzpurpleResponseB= nanmean(currentSubj(1).DSzpurpleAllTrialsB,1);
%    currentSubj(1).meanNSzblueResponseB= nanmean(currentSubj(1).NSzblueAllTrialsB,1);
%    currentSubj(1).meanNSzpurpleResponseB= nanmean(currentSubj(1).NSzpurpleAllTrialsB,1);
%         %cond C
%    currentSubj(1).meanDSzblueResponseC= nanmean(currentSubj(1).DSzblueAllTrialsC,1);
%    currentSubj(1).meanDSzpurpleResponseC= nanmean(currentSubj(1).DSzpurpleAllTrialsC,1);
%    currentSubj(1).meanNSzblueResponseC= nanmean(currentSubj(1).NSzblueAllTrialsC,1);
%    currentSubj(1).meanNSzpurpleResponseC= nanmean(currentSubj(1).NSzpurpleAllTrialsC,1);
%         %cond D
%    currentSubj(1).meanDSzblueResponseD= nanmean(currentSubj(1).DSzblueAllTrialsD,1);
%    currentSubj(1).meanDSzpurpleResponseD= nanmean(currentSubj(1).DSzpurpleAllTrialsD,1);
%    currentSubj(1).meanNSzblueResponseD= nanmean(currentSubj(1).NSzblueAllTrialsD,1);
%    currentSubj(1).meanNSzpurpleResponseD= nanmean(currentSubj(1).NSzpurpleAllTrialsD,1);
% 
%    
%    figure(figureCount);
%    figureCount=figureCount+1;
%  
%    sgtitle(strcat('Rat #',num2str(currentSubj(1).rat),'PE latency by mean cue-evoked photometry response (within 1s)'));
%    
%    subplot(4,1,1); %cond A
%    scatter(currentSubj(1).meanDSzblueResponseA, currentSubj(1).DSpeLatencyAllTrialsA);
%    xlabel('465nm z score');
%    ylabel('PE latency (s)');
%    
%    subplot(4,1,2); %cond B
%    scatter(currentSubj(1).meanDSzblueResponseB, currentSubj(1).DSpeLatencyAllTrialsB);
%    xlabel('z score');
%    ylabel('PE latency (s)');
%    
%    subplot(4,1,3); %cond C
%    scatter(currentSubj(1).meanDSzblueResponseC, currentSubj(1).DSpeLatencyAllTrialsC);
%    xlabel('465nm z score');
%    ylabel('PE latency (s)');
%    
%     
%    subplot(4,1,4); %cond D
%    scatter(currentSubj(1).meanDSzblueResponseD, currentSubj(1).DSpeLatencyAllTrialsD);
%    xlabel('465nm z score');
%    ylabel('PE latency (s)');
%    
%    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%    
% end %end subject loop
% 
% 


%% ~~~Behavioral plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% %% PLOT PORT ENTRY COUNT ACROSS DAYS FOR ALL SUBJECTS - not very meaningful,  but good template for DS PE ratio or latency
% 
% %In this section, we'll loop through our subjData struct, extracting a port entry
% %count for each session. Then we'll plot # of port entries as training
% %progresses.
% 
% disp('plotting port entry counts')
% 
% figure(figureCount) %one figure with poxCount across sessions for all subjects
% 
% figureCount= figureCount+1; %iterate the figure count
% for subj= 1:numel(subjects) %for each subject
%     
%     %initialize
%     poxCount = [];
%     days = [];
%     
%    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
%        
%        currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%       
%        %Plot number of port entries across all sessions
%        
%         poxCount(session)= numel(currentSubj(session).pox); %get the total number of port entries across days
%         days(session)= currentSubj(session).trainDay; %keep track of days to associate with poxCount
%    end
%    hold on;
%    plot(days, poxCount)
% end
% 
% title(strcat(currentSubj(session).experiment,' port entry count across days'));
% xlabel('training day');
% ylabel('port entry count');
% legend(subjects); %add rats to legend
% 
% %make figure full screen, save, and close this figure
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'port_entries_by_session','.fig'));
% %         close; %close 

%% PLOT AVERAGE PORT ENTRY COUNT BETWEEN DAYS FOR ALL ANIMALS

%In this section, we'll loop through our subjData struct to get a port
%entry count for each session. Then, we'll calculate an avg port entry
%count for each subject across sessions, along with an SEM for each subject
%with n= number of sessions. This information will be used to make a
%scatter plot of individual port entry counts by day, along with the mean +/- SEM.

clear poxCount; %used the same variable name as previous section, so clear it

disp('plotting avg port entry counts by animal');

%get the figure ready before starting subj loop
figure(figureCount) %one figure with avg poxCount for all subjects
figureCount= figureCount+1;
title(strcat(currentSubj(session).experiment,'avg port entry count by subject +/- SEM'));
xlabel('subject');
ylabel(' port entry count');

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       
       %Get number of port entries for all sessions
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       poxCount{1,subj}(session,1)= numel(currentSubj(session).pox);%get the total number of port entries across days %use a cell array in case # of sessions differs between subjects
       
       subjectLabel{1,subj}(session,1)= currentSubj(session).rat; %label each data point with a subject ID %use a cell array in case subjects have different # of sessions
       
   end %end session loop
   
   %Get the mean and SEM for each subject
   poxCountMean(1, subj)= nanmean(poxCount{1,subj}(:,1)); %calculate avg poxCount across sessions for each subject
   poxCountSEM(1,subj)= std(poxCount{1,subj}(:,1))/sqrt(numel(currentSubj)); %calculate SEM for each subject: standard deviation of number of port entries across sessions / number of sessions for this subject


   %now plot the data
   hold on;
   
   scatter(subjectLabel{1,subj}, poxCount{1,subj}(:,:)); %scatter daily port entry counts by subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj), poxCountMean(1,subj)], 'k'); %overlay mean of each subject
     
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)-poxCountSEM(1,subj), poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--');%overlay - sem of each subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)+poxCountSEM(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--');%overlay + sem of each subject
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [poxCountMean(1,subj),poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--'); %connect -SEM to mean
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [ poxCountMean(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--'); %connect +SEM to mean
end

%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'average_port_entries_by_subject','.fig'));
%         close; %close 

%% PLOT DS & NS PE RATIO ACROSS DAYS

%In this section, we'll loop through our subjData struct, extracting a port entry
%count for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting port entry ratios')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
    
    %initialize
    days = []; 
    DSpeRatio= [];
    NSpeRatio= [];
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       
       currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE ratios
       
        DSpeRatio(session)= currentSubj(session).behavior.DSpeRatio; %get the DSpeRatio
       
        NSpeRatio(session)= currentSubj(session).behavior.NSpeRatio; %get NSpeRatio
   end
   subplot(2,1,1)
   hold on;
   h= plot(days, DSpeRatio); %save a handle so we can get the color of this plot and use it for NS
   
   %get this plot's color and x axis so we can use the same color for the NS plot
   c= get(h,'Color');
   x= xlim;
   y=[0,1];
   ylim(y);
   
   subplot(2,1,2)
   hold on;
   plot(days, NSpeRatio, 'Color', c, 'LineStyle','--');
   xlim(x);
   ylim(y);
   
end

subplot(2,1,1)
title(strcat(currentSubj(session).experiment,' DS PE Ratio across days'));
xlabel('training day');
ylabel('port entry ratio (# of trials with PE / total # of trials)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot

subplot(2,1,2)
title(strcat(currentSubj(session).experiment,' NS PE Ratio across days'));
xlabel('training day');
ylabel('port entry ratio (# of trials with PE / total # of trials)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot


%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'pe_ratio_by_session','.fig'));
%         close; %close 

%% PLOT FIRST 10s DS & NS PE RATIO ACROSS DAYS

% %In this section, we'll loop through our subjData struct, extracting a port entry
% %count for each session. Then we'll plot # of port entries as training
% %progresses.
% 
% disp('plotting port entry ratios')
% 
% figure(figureCount) %one figure with poxCount across sessions for all subjects
% 
% figureCount= figureCount+1; %iterate the figure count
% for subj= 1:numel(subjects) %for each subject
%     
%     %initialize
%     days = []; 
%     DSpeRatio= [];
%     NSpeRatio= [];
%    
%    for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
%        
%        currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%       
%        %Plot number of port entries across all sessions
%        
%         days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE ratios
%        
%         DSpeRatio(session)= currentSubj(session).behavior.tensecDSpeRatio; %get the DSpeRatio
%        
%         NSpeRatio(session)= currentSubj(session).behavior.tensecNSpeRatio; %get NSpeRatio
%    end
%    subplot(2,1,1)
%    hold on;
%    h= plot(days, DSpeRatio); %save a handle so we can get the color of this plot and use it for NS
%    
%    %get this plot's color and x axis so we can use the same color for the NS plot
%    c= get(h,'Color');
%    x= xlim;
%    y=[0,1];
%    ylim(y);
%    
%    subplot(2,1,2)
%    hold on;
%    plot(days, NSpeRatio, 'Color', c, 'LineStyle','--');
%    xlim(x);
%    ylim(y);
%    
% end
% 
% subplot(2,1,1); hold on;
% title(strcat(currentSubj(session).experiment,' DS PE Ratio across days'));
% plot(days, mean(DSpeRatio), 'k');
% xlabel('training day');
% ylabel('port entry ratio (# of trials with PE / total # of trials)');
% legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot
% 
% subplot(2,1,2); hold on;
% title(strcat(currentSubj(session).experiment,' NS PE Ratio across days'));
% xlabel('training day');
% ylabel('port entry ratio (# of trials with PE / total # of trials)');
% legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot
% 
% 
% %make figure full screen, save, and close this figure
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'pe_ratio_by_session','.fig'));
% %         close; %close 

%% PLOT AVG DS & NS PE LATENCY BY DAY

%In this section, we'll loop through our subjData struct, extracting an avg port entry
%latency for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting port entry latencies')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
    
    %initialize
    days = []; 
    meanDSpeLat= [];
    meanNSpeLat= [];
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       
       currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE lat
       
        meanDSpeLat(session)= nanmean(currentSubj(session).behavior.DSpeLatency); %get the mean DS PE lat
       
        meanNSpeLat(session)= nanmean(currentSubj(session).behavior.NSpeLatency); %get the mean NS PE lat
   end
   subplot(2,1,1)
   hold on;
   h= plot(days, meanDSpeLat); %save a handle so we can get the color of this plot and use it for NS
   
   %get this plot's color and x axis so we can use the same color for the NS plot
   c= get(h,'Color');
   x= xlim;
   y=ylim;
   
   subplot(2,1,2)
   hold on;
   plot(days, meanNSpeLat, 'Color', c, 'LineStyle','--');
   xlim(x);
%    ylim(y);
    ylim([0,30]);
   
end

subplot(2,1,1)
title(strcat(currentSubj(session).experiment,'Mean DS PE latency across days'));
xlabel('training day');
ylabel('mean latency to PE after cue onset (s)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot

subplot(2,1,2)
title(strcat(currentSubj(session).experiment,'Mean NS PE latency across days'));
xlabel('training day');
ylabel('mean latency to PE after cue onset (s)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot


%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'pe_latency_by_session','.fig'));
%         close; %close 

%% PLOT DS & NS LICKS ACROSS DAYS

%In this section, we'll loop through our subjData struct, extracting a port entry
%count for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting DS & NS licks')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
    
    %initialize
    days = []; 
    DSlicks= [];
    NSlicks= [];
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       
       currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE ratios
       
        
        %we have saved timestamps of each lick during the cue saved in
        %SubjDataAnalyzed.behavior. We'll use cellfun to get the length of
        %each cell (the number of licks in each cue presentation), then
        %we'll sum this to get a total lick count during cues in that
        %session
        DSlicks(session)= sum(cellfun('length', currentSubj(session).behavior.loxDS)); %get the DS licks
       
        if isempty(currentSubj(session).periNS.NS) %if this is a trial without NS data, make lick count nan (just makes plot nicer)
            NSlicks(session)=nan;
        else %otherwise, if there's valid NS data get the lick count
            NSlicks(session)= sum(cellfun('length',currentSubj(session).behavior.loxNS)); %get NS licks
        end   
        
        
   end
   subplot(2,1,1)
   hold on;
   h= plot(days, DSlicks); %save a handle so we can get the color of this plot and use it for NS
   
   %get this plot's color and x axis so we can use the same color for the NS plot
   c= get(h,'Color');
   x= xlim;
%    y=ylim;
   
   subplot(2,1,2)
   hold on;
   plot(days, NSlicks, 'Color', c, 'LineStyle','--');
   xlim(x);
%    ylim(y);
   
end

subplot(2,1,1)
title(strcat(currentSubj(session).experiment,' DS licks across days'));
xlabel('training day');
ylabel('# of licks in DS epoch (cue onset+ cue duration)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot

subplot(2,1,2)
title(strcat(currentSubj(session).experiment,' NS licks across days'));
xlabel('training day');
ylabel('# of licks in NS epoch (cue onset+ cue duration)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot


%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'cueLicks','.fig'));
%         close; %close 




%% ~~~Power analysis~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Try to estimate effect size. Effect we're looking at is the difference in
%z score 465nm(blue) response to DS cue vs. NS cue over some period of time. 
%In order to do so, we need to get an avg response to each cue across all subjects. Then, we'll 
%get an avg std of the response and use this to calculate pooledStd
%across subjects

%Need to define a timescale within which to look for cue-related effect
%Here, we will use a 1s time window after cue onset
effectDuration= 1; % Define a time window of interest after cue onset within which we will look for an effect

cueOnsetTime= periCueFrames-postCueFrames;

effectWindow= cueOnsetTime+1:cueOnsetTime+(effectDuration*fs); %Indices of the time window for the effect

%Because 405nm and 465nm signals are inversely related, looking for an
%effect between these signals doesn't seem appropriate. We could look for
%a difference between response to DS vs. response to NS. We could also look
%for a difference between cue-related response and 'spontaneous'
%activity during ITI. I think there must be some normalized metric between
%subjects to estimate an effect size (e.g. z score)
for subj= 1:numel(subjectsAnalyzed) %for each subject
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
   disp(strcat('working on effect size estimate for subj', num2str(subj), ' / ', num2str(numel(subjectsAnalyzed))));
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       %raw blue and purple signals don't mean much as their value is arbitrary, can't really compare the two directly 
       %instead, need to look at change in signal over time
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue= currentSubj(session).DSblue(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblueMean= nanmean(nanmean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple= currentSubj(session).DSpurple(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurpleMean= nanmean(nanmean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
       %Z score is a normalized metric which seems appropriate for analyzing this
       %type of data. While z score already incorporates within-subject std
       %into its calculation, we will use a pooledStd to incorporate
       %between-subject std.
       
       %get the z score values during the 'effect' time window
       %for now, interested in blue signal
       
       %Extract the blue z score response to cue in a specific time window of interest
       %for all DS cues (and then the avg response to all cues)...
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblue= currentSubj(session).periDS.DSzblue(effectWindow, 1, :);
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueMean= nanmean(nanmean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
       %then calculate the std of this response to cues (and then the avg std of response to all cues)
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periDS.DSzblue(effectWindow,1,:)); %this gives us std of response to each cue
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueAvgStd= nanmean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueStd); %this gives us the avg std of response to each cue
       
       %repeat above but for response to NS cue
       if isempty(currentSubj(session).periNS.NSzblue) %if there's no valid NS, there's no effect to look for
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean= [];
           
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd= [];
       else %if an NS is present, extract cue-related activity in the 'effect' time window
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue= currentSubj(session).periNS.NSzblue(effectWindow,1,:);
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean= nanmean(nanmean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue,3));
       
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periNS.NSzblue(effectWindow,1,:)); %this gives us std of response to each cue
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd= nanmean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd); %this gives us the avg std of response to each cue
       end
              
   end %end session loop
   
  %get a grand mean of 'effect' (here the z score in the blue channel) across all cues and all sessions for each subject
  grandMeanEffectDSzblue(:,subj)= nanmean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueMean));  
  grandMeanEffectNSzblue(:,subj)= nanmean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean));
   
  %get a grand avg std of the z score for each subject
  grandStdDSzblue(:,subj)= nanmean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueAvgStd));  
  grandStdNSzblue(:,subj)= nanmean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd));  

end %end subject loop

  %now avg everything across subjects; use nanmean since some NS dat   a may be nan
  grandMeanEffectDSzblueAllSubjects= nanmean(grandMeanEffectDSzblue); %avg response to DS
  grandMeanEffectNSzblueAllSubjects= nanmean(grandMeanEffectNSzblue); %avg response to NS

  grandStdDSzblueAllSubjects= nanmean(grandStdDSzblue); %avg std in response to DS
  grandStdNSzblueAllSubjects= nanmean(grandStdNSzblue); %avg std in response to NS
  
  
  %now, calculate a pooledStd between the DS and NS
  pooledStdAllSubjects= sqrt(((grandStdDSzblueAllSubjects^2)+(grandStdNSzblueAllSubjects^2))/2); 

 %now, estimate Cohen's D (mean1-mean2)/pooledStd
 
 cohensDzBlue= abs((grandMeanEffectDSzblueAllSubjects-grandMeanEffectNSzblueAllSubjects)/pooledStdAllSubjects)
 %May need to refine the time period over which to look for an effect (1s seems too broad, 
 %heatplots show response only ~500ms after cue). Could also look for a max
 %response and then use those instead of getting an avg response.
 
 %just for fun, what n would we need for .80 power given this effect size?
 nCuePresentationsNeeded = sampsizepwr('t',[grandMeanEffectDSzblueAllSubjects, pooledStdAllSubjects], grandMeanEffectNSzblueAllSubjects, .80,[])
  
 
 %lets save this too
for subj= 1:numel(subjectsAnalyzed) %for each subject
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.cohensDzBlue= cohensDzBlue;
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.nCuePresentationsNeeded= nCuePresentationsNeeded;
end %end subject loop


%% ~~~Inferential stats~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% I think the data here will be parametric - at least in latter stages of
% training, there seem to be consistent cue responses 

% Since I'd like to see how the neural cue response changes with training, I would like to
% use n-way ANOVA to look at the main effect of cue, the main effect of session,
% and any interaction

%% ANOVA of blueZ in response to cue
% Trying to do N-way anova of blue z score response to DS vs. NS
% in a predefined time window of interest following the cue
%The time window is the same as in the power analysis above, and we'll pull
%from calculations made in the power analysis to get the avg. response to
%both cues
% For now, factors of interest: Cue, Subject, and Session (time)... and
% interactions

anovanSessionCount =1; %initialize an iterator for indexing

%Let's get our data into the right shape
%for simplicity, we'll loop through the data twice to get DS and NS data
for subj= 1:numel(subjectsAnalyzed) %for each subject
    
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
    for session = 1:numel(currentSubj) %for each training session this subject completed

        %in order to make a comparison, we still need to select data only
        %from sessions that have both the DS and NS
        
        if ~isempty(currentSubj(session).effectSize.effectWindowNSzblueMean)
            anovanMeanZblue(anovanSessionCount,1)= currentSubj(session).effectSize.effectWindowDSzblueMean; %get mean blue z score response to DS
            anovanSessionLabel(anovanSessionCount,1)= currentSubj(session).trainDay;
            anovanSubjLabel(anovanSessionCount,1)= currentSubj(session).rat;
            anovanCueLabel(anovanSessionCount,1)= 1; %1 for DS

            anovanSessionCount= anovanSessionCount+1; %iterate the session count
        end
    end %end session loop  
end %end subject loop

%for simplicity, let's loop again through subjs/sessions for the NS data
for subj= 1:numel(subjectsAnalyzed)
    
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj});
    
    for session= 1:numel(currentSubj)
        if ~isempty(currentSubj(session).effectSize.effectWindowNSzblueMean) %only assign NS data if it's present
            anovanMeanZblue(anovanSessionCount,1)= currentSubj(session).effectSize.effectWindowNSzblueMean; %get mean blue z score response to NS
            anovanSessionLabel(anovanSessionCount,1)= currentSubj(session).trainDay;
            anovanSubjLabel(anovanSessionCount,1)= currentSubj(session).rat;
            anovanCueLabel(anovanSessionCount,1)= 2; %2 for NS
            
            anovanSessionCount= anovanSessionCount+1; %iterate the session count
        end        
    end %end session loop
end %end subject loop

%example 3 way anova
% y = [52.7 57.5 45.9 44.5 53.0 57.0 45.9 44.0]'; %raw data
% g1 = [1 2 1 2 1 2 1 2]; %label 1
% g2 = {'hi';'hi';'lo';'lo';'hi';'hi';'lo';'lo'}; %label 2
% g3 = {'may';'may';'may';'may';'june';'june';'june';'june'}; %label 3
% p = anovan(y,{g1,g2,g3})

[anovanP, anovanTbl, anovanStats]= anovan(anovanMeanZblue,{anovanCueLabel,anovanSubjLabel,anovanSessionLabel}, 'model', 'interaction', 'varnames', {'cue', 'subject', 'session'});


% disp(anovanTbl);

%% ~~~Artifact identification/elimination~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Maybe we should just exclude extreme trials/ trials where artifacts are present
%Trying to visualize outliers here first
    
%% Histograms of individual trial z score response
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     
%     %histogram plot of the blue z score response to DS, #bins = # cue presentations
%     figure;
%     subplot(2,1,1);
%     histogram(currentSubj(1).periDS.DSzblueAllTrials, currentSubj(1).periDS.totalDScount(end), 'facecolor', 'b');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     %hist the purple z score response to DS #bins = # cue presentations
%     subplot(2,1,2)
%     histogram(currentSubj(1).periDS.DSzpurpleAllTrials, currentSubj(1).periDS.totalDScount(end) , 'facecolor', 'm');
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     
% end

% % % HISTOGRAM OF RESPONSE OVER TIME
% % march through timestamps on button press
% % for subj= 1:numel(subjectsAnalyzed) %for each subject
% %     
% %     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
% %     
% %     timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% %     
% %     histogram plot of the blue z score response to DS
% %     figure(figureCount);
% %     figureCount= figureCount+1;
% %     disp('***displaying histograms of z score response to cue thru time');
% %     for timestamp= 1:numel(timeStep)
% %             subplot(2,1,1);
% %             histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %         
% %             hist the purple z score response to DS 
% %             subplot(2,1,2)
% %             histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %             pause(0.008); %this will automatically iterate (seconds); to wait for user input use pause()
% %     end
% %     close;
% % end

%% Looping histogram of z score DS response over time
% %TODO: save to movie
% timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% 
% figure(figureCount);
% figureCount=figureCount+1;
% hold on;
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
% histTitle= sgtitle(strcat('z score in response to DS at T= ')); %add big title above all subplots
% 
% 
% % while 1 %infinite loop while true
%     disp('***displaying histograms of z score response to cue thru time, press key to stop');
%     
%     %loop through all timestamps, for each timestamp loop through subjects
%     %and plot the peri-cue z score values first in the blue channel then in
%     %the purple channel (looped twice in order to organize subplots so that
%     %blue is on top of purple for each subject)
%     
%     for timestamp= 1:numel(timeStep)
%         subplotCount= 1; %reset all the subplots between timestamps
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);   
%                 subplotCount=subplotCount+1;
%                 
%                 histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z'));
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% 
%         end
%         
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 %hist the purple z score response to DS #bins = # cue presentations
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);
%                 subplotCount=subplotCount+1;
%                 histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z'));
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%         end
%         
%         pause(0.005); %this will automatically iterate (seconds); to wait for user input use pause()
% 
%     end
% % end
% 
% close;
    
%% Artifact elimination
% 
% %Artifacts should be considered fast deflections in both shannels in the same
% %direction, or we could just use the 405nm to keep it simple
% 
% %define a threshold criteria for the isosbestic channel based on std,
% %and discard frames where the isosbestic signal deviates above this threshold
% 
% %keep in mind that 405nm signal could vary with ca++ events
% 
% %this strategy seeems imperfect- good datapoints may be removed due to
% %bleaching and it doesn't capture all artifacts... instead of looking
% %at global std, need to do some kind of sliding calculation to look at
% %local std
%     
% for subj= 1:numel(subjects)
%     
%     currentSubj= subjData.(subjects{subj});
%     
%     disp(strcat('artifact elimination_', subjects{subj}));
%     
%     
%     figure(figureCount);
%     figureCount=figureCount+1;
%     sgtitle(strcat('Rat #',num2str(currentSubj(1).rat), 'artifact detection'));
%     
%     subplotCount=1;
% 
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%        artifactThreshold = std(currentSubj(session).repurple)*2;
%        
%        subjDataAnalyzed.(subjects{subj})(session).photometrySignals.artifactThreshold= artifactThreshold; %save this value
%       
%     for timestamp= 1:numel(currentSubj(session).repurple)
%         if timestamp== 1
%             currentSubj(session).dPurple(timestamp)= 0; %no change possible on the first timestamp
%         else
%             currentSubj(session).dPurple(timestamp) = currentSubj(session).repurple(timestamp)-currentSubj(session).repurple(timestamp-1);
%         end  
%     end
%     
%     dPurple= currentSubj(session).dPurple;
%     
%     %let's define a threshold beyond which we want to exclude data (noise)
%     dThreshold = std(currentSubj(session).dPurple)*8;
%     dMean= nanmean(currentSubj(session).dPurple);
%     
%     %identify points that exceed this threshold
%     dArtifactIndex= find(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     dArtifactsVals= dPurple(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     subplot(numel(currentSubj),3,subplotCount);
%     subplotCount=subplotCount+1;
%     hold on;
%     plot(currentSubj(session).dPurple, 'm');
%     
%     title('dPurple');
%     %overlay threshold
%     plot([1,numel(currentSubj(session).dPurple)], [dMean - dThreshold, dMean - dThreshold], 'k--');
%     plot([1,numel(currentSubj(session).dPurple)], [dMean + dThreshold, dMean + dThreshold], 'k--');
%     %overlay points beyond threshold
%     scatter(dArtifactIndex, dArtifactsVals, 'rx')
%    
%     
%     % let's put these excluded timestamps over the raw purple trace to compare
%     
%        subplot(numel(currentSubj), 3, subplotCount);
%        subplotCount= subplotCount+1;
%        hold on;
%        plot(currentSubj(session).repurple, 'm'); %plot 405 signal
%        title('repurple, artifact timestamps calculated based on dPurple');
%        
%        %overlay + and - the threshold relative to the mean 405 signal
%        plot([1,numel(currentSubj(session).repurple)], [nanmean(currentSubj(session).repurple) + artifactThreshold, nanmean(currentSubj(session).repurple) + artifactThreshold], 'k--')
%        plot([1,numel(currentSubj(session).repurple)], [nanmean(currentSubj(session).repurple) - artifactThreshold, nanmean(currentSubj(session).repurple) - artifactThreshold], 'k--')
% 
%        scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+nanmean(currentSubj(session).repurple), 'rx'); 
%     
%        %plot blue too
%        plot(currentSubj(session).reblue);
%     
% 
%     
% 
%     %conservative threshold works well here- just looking for extreme
%     %artifacts- big, abrupt changes
%     
%     %seems to work for most trials, but @ threshold = 10 std trhis misses a pretty big case for
%     %VP-VTA-FP rat 9 trial 32
%     
%     %TODO: this is calculating dF timestamp by timestamp, but maybe we want to reject
%     %rapid increases over a specific time period or do some kind of sliding
%     %calculation
% 
%     %Let's actually remove the artifacts now
%     
%     cutTime= currentSubj(session).cutTime;
%     
%     %get the actual timestamp values to be excluded from cutTime
%     excludedTimestamps = cutTime(dArtifactIndex);
%         
%     %extract all timestmap values from cutTime that aren't equal to these
%     %excluded timestamps
%     
%     %make these excluded timestamps NaN
%     cutTime(dArtifactIndex)= NaN;
%     %extract timestamps that aren't NaN
%     timeNoArtifact= cutTime(~isnan(cutTime));
%     
% %     disp(strcat('excluded_', num2str(numel(excludedTimestamps)), ' timestamps w/ artifacts '));
%     
%     %now use the same strategy to extract photometry signals
%     reblueNoArtifact= currentSubj(session).reblue(~isnan(cutTime));
%     repurpleNoArtifact= currentSubj(session).repurple(~isnan(cutTime));
%     
%     
%    subplot(numel(currentSubj), 3, subplotCount);
%    subplotCount= subplotCount+1;
%    hold on;
%    plot(repurpleNoArtifact, 'm'); %plot 405 signal
%    title('artifacts removed- this method isnt working');
% 
%    scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+nanmean(currentSubj(session).repurple), 'rx'); 
% 
%    %plot blue too
%    plot(reblueNoArtifact, 'b');
% 
%    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%    
%    %this method doesn't seem to work well enough- but at least we have
%    %decent timestamps of artifacts... we maybe we can use this to exclude TRIALS
%    %instead of trying to remove the artifacts themselves?
%    
%    %maybe it would be best to just exlucde trials with huge z scores
%    
%    %Maybe instead of excluding trials, change the baseline z score calc in
%    %some way (exclude timestamps?)
%    
%    %save the artifact indices for each session
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.dArtifactTimes= excludedTimestamps; %this is a list of the excluded timestamps
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.cutTimeNoArtifacts= cutTime; %this is a time axis where timestamps with artifacts= NaN
% 
%    end %end session loop
%    
%     %save figure
% %    saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_ArtifactID','.tiff')); %save the current figure in fig format
% 
% end %end subj loop
   
%% HEAT PLOT WITH ARTIFACT TRIALS EXCLUDED
% 
% %Now that we have timestamps of 'artifacts', check if the peri-event window
% %includes an artifact. If so, exclude this trial.
% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
% currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     for session = 1:numel(currentSubj) %for each training session this subject completed
% 
%         %go through each session and check to see if periDS window contains an
%         %excluded timestamp (due to artifact being detected)
%         DSincluded = size(currentSubj(session).periDS.periDSwindow,3);
% 
%         DSexcluded= []; %keep track of which cues were excluded for this session
% 
%             for cue = 1:DSincluded
%                 preEventTimeDS= currentSubj(session).periDS.periDSwindow(:,1,cue);
%                 postEventTimeDS= currentSubj(session).periDS.periDSwindow(:,end,cue);
% 
%                 for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                     %if artifact occurs between preEventTime and postEventTime
%                     if artifact>preEventTimeDS && artifact<postEventTimeDS
%                         disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding DS_', num2str(cue), ' from heat plot'))
%                         DSexcluded= [DSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                         continue; %if this cue has an artifact, we don't need to keep checking anymore
%                     end
%                 end
%             end
% 
%             currentSubj(session).periDS.DSexcludedArtifact= DSexcluded; %save list of excluded cues for each session
% 
%             %now that we have excluded cues, let's go in and extract only data
%             %from included cues
% 
%             for excludedTrial = DSexcluded
%                 %make all the dat in excluded trials = nan
%                 currentSubj(session).periDS.DSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                 currentSubj(session).periDS.DSzpurple(:,:,excludedTrial)=nan; 
%             end
% 
% 
%       %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single DS)
%             if session==1
%                 currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%             else
%                 currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                 currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%             end
% 
%             %repeat above steps for NS
%             
%         if ~isempty(currentSubj(session).periNS.periNSwindow) %only run if there's NS data present
%             NSincluded = size(currentSubj(session).periNS.periNSwindow,3);
% 
%             NSexcluded= []; %keep track of which cues were excluded for this session
% 
%                 for cue = 1:NSincluded
%                     preEventTimeNS= currentSubj(session).periNS.periNSwindow(:,1,cue);
%                     postEventTimeNS= currentSubj(session).periNS.periNSwindow(:,end,cue);
% 
%                     for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                         %if artifact occurs between preEventTime and postEventTime
%                         if artifact>preEventTimeNS && artifact<postEventTimeNS
%                             disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding NS_', num2str(cue), ' from heat plot'))
%                             NSexcluded= [NSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                             continue; %if this cue has an artifact, we don't need to keep checking anymore
%                         end
%                     end
%                 end
% 
%                 currentSubj(session).periNS.NSexcludedArtifact= NSexcluded; %save list of excluded cues for each session
% 
%                 %now that we have excluded cues, let's go in and extract only data
%                 %from included cues
% 
%                 for excludedTrial = NSexcluded
%                     %make all the dat in excluded trials = nan
%                     currentSubj(session).periNS.NSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                     currentSubj(session).periNS.NSzpurple(:,:,excludedTrial)=nan; 
%                 end
% 
% 
%           %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single NS)
%                 if session==1
%                     currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                     currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 else
%                     currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                 end
%                  
%         else %if there's no NS data present
%             currentSubj(1).NSzblueAllTrials= [];
%             currentSubj(1).NSzpurpleAllTrials= [];    
%         end %end NS conditional
%         
%     end %end session loop
% 
%     %Transpose these data for readability
%     currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
%     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';
%    
%     if ~isempty(currentSubj(1).NSzblueAllTrials)
%         currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
%         currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
%     end
%      %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%      
%      %define DS color axes
%      
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 4;
%      
%      %need to use nanmean now bc we have nans on excluded trials
%      topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
%      topAllDS= max(topDSzblue, topDSzpurple);
%      
%         %same defining color axes for NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%         topAllNS= max(topNSzblue, topNSzpurple);
%     end
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%         bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
%         bottomAllShared= bottomAllDS;
%         topAllShared= topAllDS;
%     end
%            
%     
%     %get a trial count to use for the heatplot ytick
%     currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
%     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1); 
% 
%     %save for later 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
%     
%     %TODO: split up yticks by session (this would show any clear differences between days)
%     
%      %Heatplots!       
%     %DS z plot
%     figure(figureCount);
%     hold on;
%     subplot(2,2,1); %subplot for shared colorbar
% 
%     %plot blue DS
% 
%     timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
%     heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
%     title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
% 
%     %   plot purple DS (subplotted for shared colorbar)
%     subplot(2,2,3);
%     heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 
% 
%     title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% 
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
% 
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
%     
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials_ArtifactRemoved','.fig')); %save the current figure in fig format
% 
%       if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
%         
%         %plot blue NS
%         subplot(2,2,2); %subplot for shared colorbar
% 
%         heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
%         title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%         
%         
%            %   plot purple NS (subplotted for shared colorbar)
%         subplot(2,2,4);
%         heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 
% 
%         title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
% 
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
% 
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%         saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
%     end
%     
%     
%     
%     figureCount= figureCount+1;

% end%end subj loop

%% experimenting with nonlinear colormap

% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%   
% % First, Id pick an existing colormap, such as Parula. Specify the max and min values of your data (e.g. 34 and -350), and then select the value at which you would like more color variation (e.g. perhaps 34 or 0). You can play with the scaling intensity parameter to see what looks nice.
%   cMap = parula(256);
%   dataMax = topAllShared;
%   dataMin = bottomAllShared;
%   centerPoint = 1; %nanmean(nanmean(currentSubj(1).periDS.DSzpurpleAllTrials,1));
%   scalingIntensity = 1; %nanmean(std(currentSubj(1).periDS.DSzpurpleAllTrials));
% % Then perform some operations to create your colormap. I have done this by altering the indices x at which each existing color lives, and then interpolating to expand or shrink certain areas of the spectrum.
%   x = 1:length(cMap); 
%   x = x - (centerPoint-dataMin)*length(x)/(dataMax-dataMin);
%   x = scalingIntensity * x/max(abs(x));
% % Next, select some function or operations to transform the original linear indices into nonlinear. In the last line, I then use interp1 to create the new colormap from the original colormap and the transformed indices.
%   x = sign(x).* exp(abs(x));
%   x = x - min(x); x = x*511/max(x)+1; 
%   newMap = interp1(x, cMap, 1:512);
% % Then plot! 
% %   figure; imagesc(X);
% %   figure; imagesc(X); colormap(newMap);
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colorbar; title(strcat('auto colormap rat_ ', num2str(currentSubj(1).rat)));
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colormap(newMap); colorbar;
%   title(strcat('nonlinear colormap; center= ', num2str(centerPoint), '; scaling = ', num2str(scalingIntensity), '; rat_', num2str(currentSubj(1).rat)));
%  
%   
%     figureCount= figureCount+1;
% end %end subj loop

%% ~~~Dakota GPN poster retreat plots~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% stage 1-4 , 5, and 6+ session DS plots

% for subj= 1:numel(subjects) %for each subject
%    currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%    
%    
%   sesCountA= 1;
%   sesCountB= 1;
%   sesCountC= 1;
%   
%   sesCountD= 1;
%   
%   subjSessA= [];
%   subjSessB= [];
%   subjSessC= [];
%   
%   subjSessD= [];
% 
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%               
%        %compare avg response to cue for each session across stages
%        
%        %First get data from sessions on stages <5
%        if currentSubj(session).trainStage <5
%             if sesCountA ==1 %for the first session, get this sessions periDS blue z score response
%                         currentSubj(1).DSzblueSessionMeanA= currentSubj(session).periDS.DSzblueMean; 
%                         currentSubj(1).DSzpurpleSessionMeanA= currentSubj(session).periDS.DSzpurpleMean;
%                 else % add on periDS response for subsequent sessions
%                         currentSubj(1).DSzblueSessionMeanA= cat(2, currentSubj(1).DSzblueSessionMeanA, currentSubj(session).periDS.DSzblueMean);
%                         currentSubj(1).DSzpurpleSessionMeanA= cat(2, currentSubj(1).DSzpurpleSessionMeanA, currentSubj(session).periDS.DSzpurpleMean);
%             end
%             sesCountA= sesCountA+1;
%             subjSessA= cat(2, subjSessA, currentSubj(session).trainDay); %day count for y axis
%        end %end conditional A
%        
%        %now get data from sessions on stage 5
%        if currentSubj(session).trainStage == 5
%               if sesCountB ==1 %for the first session, get this sessions periDS blue z score response
%                         currentSubj(1).DSzblueSessionMeanB= currentSubj(session).periDS.DSzblueMean; 
%                         currentSubj(1).DSzpurpleSessionMeanB= currentSubj(session).periDS.DSzpurpleMean;
%                         currentSubj(1).NSzblueSessionMeanB= currentSubj(session).periNS.NSzblueMean;
%                         currentSubj(1).NSzpurpleSessionMeanB= currentSubj(session).periNS.NSzpurpleMean;
%               else % add on periDS response for subsequent sessions
%                         currentSubj(1).DSzblueSessionMeanB= cat(2, currentSubj(1).DSzblueSessionMeanB, currentSubj(session).periDS.DSzblueMean);
%                         currentSubj(1).DSzpurpleSessionMeanB= cat(2, currentSubj(1).DSzpurpleSessionMeanB, currentSubj(session).periDS.DSzpurpleMean);
%                         currentSubj(1).NSzblueSessionMeanB= cat(2, currentSubj(1).NSzblueSessionMeanB, currentSubj(session).periNS.NSzblueMean);
%                         currentSubj(1).NSzpurpleSessionMeanB= cat(2, currentSubj(1).NSzpurpleSessionMeanB, currentSubj(session).periNS.NSzpurpleMean);
%               end
%               sesCountB= sesCountB+1;
%               subjSessB= cat(2, subjSessB, currentSubj(session).trainDay); %day count for y axis
% 
%        end %end conditional B
%        
%        %now get data from sessions above stages 6-7 (where delay introduced)
%        if currentSubj(session).trainStage==6 || currentSubj(session).trainStage==7
%             if sesCountC ==1 %for the first session, get this sessions periDS blue z score response
%                         currentSubj(1).DSzblueSessionMeanC= currentSubj(session).periDS.DSzblueMean; 
%                         currentSubj(1).DSzpurpleSessionMeanC= currentSubj(session).periDS.DSzpurpleMean;
%                         currentSubj(1).NSzblueSessionMeanC= currentSubj(session).periNS.NSzblueMean;
%                         currentSubj(1).NSzpurpleSessionMeanC= currentSubj(session).periNS.NSzpurpleMean;
%              else % add on periDS response for subsequent sessions
%                         currentSubj(1).DSzblueSessionMeanC= cat(2, currentSubj(1).DSzblueSessionMeanC, currentSubj(session).periDS.DSzblueMean);
%                         currentSubj(1).DSzpurpleSessionMeanC= cat(2, currentSubj(1).DSzpurpleSessionMeanC, currentSubj(session).periDS.DSzpurpleMean);
%                         currentSubj(1).NSzblueSessionMeanC= cat(2, currentSubj(1).NSzblueSessionMeanC, currentSubj(session).periNS.NSzblueMean);
%                         currentSubj(1).NSzpurpleSessionMeanC= cat(2, currentSubj(1).NSzpurpleSessionMeanC, currentSubj(session).periNS.NSzpurpleMean);
%             end
%             sesCountC= sesCountC+1;
%             subjSessC= cat(2, subjSessC, currentSubj(session).trainDay); %day count for y axis
% 
%        end %end conditional C
%        
%        
%        if currentSubj(session).trainStage == 8
%            
%            if sesCountD ==1 %for the first session, get this sessions periDS blue z score response
%                         currentSubj(1).DSzblueSessionMeanD= currentSubj(session).periDS.DSzblueMean; 
%                         currentSubj(1).DSzpurpleSessionMeanD= currentSubj(session).periDS.DSzpurpleMean;
%                         currentSubj(1).NSzblueSessionMeanD= currentSubj(session).periNS.NSzblueMean;
%                         currentSubj(1).NSzpurpleSessionMeanD= currentSubj(session).periNS.NSzpurpleMean;
%              else % add on periDS response for subsequent sessions
%                         currentSubj(1).DSzblueSessionMeanD= cat(2, currentSubj(1).DSzblueSessionMeanD, currentSubj(session).periDS.DSzblueMean);
%                         currentSubj(1).DSzpurpleSessionMeanD= cat(2, currentSubj(1).DSzpurpleSessionMeanD, currentSubj(session).periDS.DSzpurpleMean);
%                         currentSubj(1).NSzblueSessionMeanD= cat(2, currentSubj(1).NSzblueSessionMeanD, currentSubj(session).periNS.NSzblueMean);
%                         currentSubj(1).NSzpurpleSessionMeanD= cat(2, currentSubj(1).NSzpurpleSessionMeanD, currentSubj(session).periNS.NSzpurpleMean);
%             end
%             sesCountD= sesCountD+1;
%             subjSessD= cat(2, subjSessD, currentSubj(session).trainDay); %day count for y axis
% 
%        end %end conditional D
%        
%     end %end session loop
%  
%     
%     %Transpose for readability
%     currentSubj(1).DSzblueSessionMeanA= currentSubj(1).DSzblueSessionMeanA';
%     currentSubj(1).DSzpurpleSessionMeanA= currentSubj(1).DSzpurpleSessionMeanA';
%     
%     currentSubj(1).DSzblueSessionMeanB= currentSubj(1).DSzblueSessionMeanB';
%     currentSubj(1).DSzpurpleSessionMeanB= currentSubj(1).DSzpurpleSessionMeanB';
%     currentSubj(1).NSzblueSessionMeanB= currentSubj(1).NSzblueSessionMeanB';
%     currentSubj(1).NSzpurpleSessionMeanB= currentSubj(1).NSzpurpleSessionMeanB';
%     
%     currentSubj(1).DSzblueSessionMeanC= currentSubj(1).DSzblueSessionMeanC';
%     currentSubj(1).DSzpurpleSessionMeanC= currentSubj(1).DSzpurpleSessionMeanC';
%     currentSubj(1).NSzblueSessionMeanC= currentSubj(1).NSzblueSessionMeanC';
%     currentSubj(1).NSzpurpleSessionMeanC= currentSubj(1).NSzpurpleSessionMeanC';
%     
%     
%     currentSubj(1).DSzblueSessionMeanD= currentSubj(1).DSzblueSessionMeanD';
%     currentSubj(1).DSzpurpleSessionMeanD= currentSubj(1).DSzpurpleSessionMeanD';
%     currentSubj(1).NSzblueSessionMeanD= currentSubj(1).NSzblueSessionMeanD';
%     currentSubj(1).NSzpurpleSessionMeanD= currentSubj(1).NSzpurpleSessionMeanD';
%     
% 
% %     %get list of session days for heatplot y axis (transposed for readability)
% %     subjTrial= cat(2, currentSubj.trainDay).'; %this is only training days for this subj
% 
%   
%     
%     %get list of session days for heatplot y axis
% %     subjTrialNS=[]; %keep track of sessions that have valid NS trials
% %     dateNS= [];
% %     for session = 1:numel(currentSubj) %for each training session this subject completed
% %         if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
% % %              subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay); %old method based on trainDay
% %                 dateNS= cat(2, dateNS, currentSubj(session).date);
% %         end
% %     end %end session loop
% %     
% %     %search NS dates for the appropriate index in allDates, then label it
% %     %similar to subjTrial
% %     for thisDate = 1:numel(dateNS) 
% %         subjTrialNS(thisDate)= find(allDates==dateNS(thisDate)); %returns the index in allDates that matches the date of this NS session
% %     end
%      %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%     
%      %define DS color axes
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
%      
%      %cond A
%      topDSzblueA= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleA= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueA = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleA= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanA, 0, 2))));
%      
%      %cond b
%      topDSzblueB= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleB= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueB = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleB= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanB, 0, 2))));
%      
%      %cond c
%      topDSzblueC= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleC= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueC = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleC= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanC, 0, 2))));
%      
%      bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC];
%      tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC];
%      
%      %cond D
%      topDSzblueD= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleD= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueD = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleD= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanD, 0, 2))));
%      
%      bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzblueD, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC, bottomDSzpurpleD];
%      tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzblueD, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC, topDSzpurpleD];
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottoms);
%      topAllDS= max(tops);
%      
% %     %same, but defining color axes for NS
% %     if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
% %         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% %         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% % 
% %         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
% %         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));
% % 
% %         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
% %         topAllNS= max(topNSzblue, topNSzpurple);
% %     end
% %     %Establish a shared bottom and top for shared color axis of DS & NS
% %     if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
% %         bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
% %         topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
% %     else
%         bottomMeanShared= bottomAllDS;
%         topMeanShared= topAllDS;
% %     end
%     
%    
% 
%     timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% % 
% %         figure(figureCount);
% %         figureCount= figureCount+1;
% % 
% %         sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, 'Avg response by session to DS across training stages')); %add big title above all subplots
% % 
% % 
% %         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
% %         
% %             imagesc(timeLock,subjSessA,currentSubj(1).DSzblueSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('daily avg 465nm z score response surrounding DS- Stages 1-4')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %             
% %         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
% %             
% %             imagesc(timeLock,subjSessB,currentSubj(1).DSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('daily avg 465nm z score response surrounding DS- Stage 5')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %         
% %         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
% %             imagesc(timeLock,subjSessC,currentSubj(1).DSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('daily avg 465nm z score response surrounding DS- Stages 6-8')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% % 
% %        subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
% %             imagesc(timeLock,subjSessA,currentSubj(1).DSzpurpleSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('daily avg 405nm z score response surrounding DS- Stages 1-4')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %        subplot(2,3,5) %plot of stage 5 purple (cond B purple)
% %             imagesc(timeLock,subjSessB,currentSubj(1).DSzpurpleSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('daily avg 405nm z score response surrounding DS- Stage 5')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %        subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
% %             imagesc(timeLock,subjSessC,currentSubj(1).DSzpurpleSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('daily avg 405nm z score response surrounding DS- Stages 6-8')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% %             
% %             
% %             
% %             %NS plots ~~~~~
% %             
% %             figure(figureCount);
% %             figureCount= figureCount+1;
% % 
% %             
% %         sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, 'Avg response by session to NS across training stages')); %add big title above all subplots
% % 
% % 
% %         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
% %         
% % %             imagesc(timeLock,subjSessA,currentSubj(1).NSzblueSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% % %             title(strcat('daily avg 465nm z score response surrounding NS- Stages 1-4')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% % %             xlabel('seconds from cue onset');
% % %             ylabel('training day');
% % %             set(gca, 'ytick', subjSessA); %label trials appropriately
% % %             caxis manual;
% % %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % % 
% % %             c= colorbar; %colorbar legend
% % %             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %             
% %         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
% %             
% %             imagesc(timeLock,subjSessB,currentSubj(1).NSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('daily avg 465nm z score response surrounding NS- Stage 5')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %         
% %         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
% %             imagesc(timeLock,subjSessC,currentSubj(1).NSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('daily avg 465nm z score response surrounding NS- Stages 6-8')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% % 
% %        subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
% % %             imagesc(timeLock,subjSessA,currentSubj(1).NSzpurpleSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% % %             title(strcat('daily avg 405nm z score response surrounding NS- Stages 1-4')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% % %             xlabel('seconds from cue onset');
% % %             ylabel('training day');
% % %             set(gca, 'ytick', subjSessA); %label trials appropriately
% % %             caxis manual;
% % %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% % %             c= colorbar; %colorbar legend
% % %             c.Label.String= strcat('NS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %        subplot(2,3,5) %plot of stage 5 purple (cond B purple)
% %             imagesc(timeLock,subjSessB,currentSubj(1).NSzpurpleSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('daily avg 405nm z score response surrounding NS- Stage 5')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %        subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
% %             imagesc(timeLock,subjSessC,currentSubj(1).NSzpurpleSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('daily avg 405nm z score response surrounding NS- Stages 6-8')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% %             
% %             
%             
%             
%      % ~~~~~~~~~~ One figure with only Blue response to DS & NS ~~~~~~~
%             
%         figure(figureCount);
%         figureCount= figureCount+1;
% 
%         sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, 'Avg response by session to DS or NS across training stages')); %add big title above all subplots
% 
% 
%         subplot(2,4,1) %plot of stage 1-4 blue (cond A blue)
%         
%             imagesc(timeLock,subjSessA,currentSubj(1).DSzblueSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stages 1-4 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,4,2) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,subjSessB,currentSubj(1).DSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stages 5 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,4,3) %plot of stage 6-7 blue (cond C blue)
%             imagesc(timeLock,subjSessC,currentSubj(1).DSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%         subplot(2,4,4) %plot of stage 8 blue (cond D blue)
%             imagesc(timeLock,subjSessD,currentSubj(1).DSzblueSessionMeanD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessD); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%             
%               
%                    
%         subplot(2,4,6) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,subjSessB,currentSubj(1).NSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg NS response Stages 1-4 (465nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,4,7) %plot of stage 6-8 blue (cond C blue)
%             imagesc(timeLock,subjSessC,currentSubj(1).NSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg NS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%             
%             subplot(2,4,8) %plot of stage 6-8 blue (cond C blue)
%             imagesc(timeLock,subjSessD,currentSubj(1).NSzblueSessionMeanD) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg NS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%             
% end %end subject loop


%% Between subjects session avg by stage
% 
% %TODO: all photometry data is  more readable in (session, cue, subj)
% %format, consider switching rest of code to this format
% 
% for subj= 1:numel(subjIncluded) %for each subject
%        currentSubj= subjDataAnalyzed.(subjIncluded{subj}); %use this for easy indexing into the current subject within the struct
% 
%       %counter for sessions that meet each condition, reset between subjs
%       sesCountA= 1;
%       sesCountB= 1;
%       sesCountC= 1;
%       sesCountD= 1;
% 
%        for session = 1:numel(currentSubj) %for each training session this subject completed
%             
%            %cond A
%            if currentSubj(session).trainStage <5 
%                %save photometry data 
%                 allRats(1).DSzblueSessionMeanA(sesCountA,:,subj)= currentSubj(session).periDS.DSzblueMean; 
%                %save training day label for this data 
%                 allRats(1).subjSessA(sesCountA,subj)=currentSubj(session).trainDay; 
%                %iterate the counter for sessions that meet this condition
%                 sesCountA= sesCountA+1;
%            end %end conditional A
% 
%              %cond B
%            if currentSubj(session).trainStage ==5 
%                %save photometry data 
%                 allRats(1).DSzblueSessionMeanB(sesCountB,:,subj)= currentSubj(session).periDS.DSzblueMean; 
% %                 allRats(1).DSzpurpleSessionMeanB(:,sesCountB,subj)= currentSubj(session).periDS.DSzpurpleMean;
%                 allRats(1).NSzblueSessionMeanB(sesCountB,:,subj)= currentSubj(session).periNS.NSzblueMean;
%                %save training day label for this data 
%                 allRats(1).subjSessB(sesCountB,subj)=currentSubj(session).trainDay; 
%                %iterate the counter for sessions that meet this condition
%                 sesCountB= sesCountB+1;
%            end %end conditional B
%            
%                %cond C
%            if currentSubj(session).trainStage== 6 || currentSubj(session).trainStage==7 
%                %save photometry data 
%                 allRats(1).DSzblueSessionMeanC(sesCountC,:,subj)= currentSubj(session).periDS.DSzblueMean; 
%                 allRats(1).NSzblueSessionMeanC(sesCountC,:,subj)= currentSubj(session).periNS.NSzblueMean;
%                %save training day label for this data 
%                 allRats(1).subjSessC(sesCountC,subj)=currentSubj(session).trainDay; 
%                %iterate the counter for sessions that meet this condition
%                 sesCountC= sesCountC+1;
%            end %end conditional C
%            
%                 %cond D
%            if currentSubj(session).trainStage ==8
%                %save photometry data 
%                 allRats(1).DSzblueSessionMeanD(sesCountD,:,subj)= currentSubj(session).periDS.DSzblueMean; 
%                 allRats(1).NSzblueSessionMeanD(sesCountD,:,subj)= currentSubj(session).periNS.NSzblueMean;
%                %save training day label for this data 
%                 allRats(1).subjSessD(sesCountD,subj)=currentSubj(session).trainDay; 
%                %iterate the counter for sessions that meet this condition
%                 sesCountD= sesCountD+1;
%            end %end conditional D
%            
% 
%         end %end session loop
%         
%         
%         %the above code filled in blank training dates with 0 (e.g. if 1 rat 
%         %ran 12 days but others ran 9 days, the 3 days in between were 
%         %filled with 0), let's make these = nan instead 
%             %condA
%         for ses = 1:size(allRats(1).subjSessA,1) %each row is a session
%            if allRats(1).subjSessA(ses,subj)==0 %if there's no data for this date
%               %make train day nan
%               allRats(1).subjSessA(ses,subj)=nan;
%               %make photometery data nan
%               allRats(1).DSzblueSessionMeanA(ses,:,subj)=nan; 
%            end
%         end
%             %condB
%          for ses = 1:size(allRats(1).subjSessB,1) %each row is a session
%            if allRats(1).subjSessB(ses,subj)==0 %if there's no data for this date
%               %make train day nan
%               allRats(1).subjSessB(ses,subj)=nan;
%               %make photometery data nan
%               allRats(1).DSzblueSessionMeanB(ses,:,subj)=nan; 
%               allRats(1).NSzblueSessionMeanB(ses,:,subj)=nan;
%            end
%          end
%            %condC
%          for ses = 1:size(allRats(1).subjSessC,1) %each row is a session
%            if allRats(1).subjSessC(ses,subj)==0 %if there's no data for this date
%               %make train day nan
%               allRats(1).subjSessC(ses,subj)=nan;
%               %make photometery data nan
%               allRats(1).DSzblueSessionMeanC(ses,:,subj)=nan; 
%               allRats(1).NSzblueSessionMeanC(ses,:,subj)=nan;
%            end
%          end
%            %condD
%          for ses = 1:size(allRats(1).subjSessD,1) %each row is a session
%            if allRats(1).subjSessD(ses,subj)==0 %if there's no data for this date
%               %make train day nan`
%               allRats(1).subjSessD(ses,subj)=nan;
%               %make photometery data nan
%               allRats(1).DSzblueSessionMeanD(ses,:,subj)=nan; 
%               allRats(1).NSzblueSessionMeanD(ses,:,subj)=nan;
%            end
%         end
%         
% end
% 
% 
% 
%  % now get mean of all rats per training day ( each column is a training day , each 3d page is a subject)
% 
%  %cond A
%  allRats.grandMeanDSzblueA=nanmean(allRats.DSzblueSessionMeanA,3);
% 
%  %cond B
%   allRats.grandMeanDSzblueB=nanmean(allRats.DSzblueSessionMeanB,3);
%   allRats.grandMeanNSzblueB= nanmean(allRats.NSzblueSessionMeanB,3);
% 
%  %cond C
%   allRats.grandMeanDSzblueC=nanmean(allRats.DSzblueSessionMeanC,3);
%   allRats.grandMeanNSzblueC= nanmean(allRats.NSzblueSessionMeanC,3);
%   
%  %cond D
%   allRats.grandMeanDSzblueD=nanmean(allRats.DSzblueSessionMeanD,3);
%   allRats.grandMeanNSzblueD= nanmean(allRats.NSzblueSessionMeanD,3);
%   
%   %let's get a simple day count for each condition to use as heatplot y axis
%     sessA= 1:size(allRats(1).subjSessA,1);
%     sessB= 1:size(allRats(1).subjSessB,1);
%     sessC= 1:size(allRats(1).subjSessC,1);
%     sessD= 1:size(allRats(1).subjSessD,1);
% 
%     %     %get list of session days for heatplot y axis (transposed for readability)
%     %     subjTrial= cat(2, currentSubj.trainDay).'; %this is only training days for this subj
% 
% 
% 
%         %get list of session days for heatplot y axis
%     %     subjTrialNS=[]; %keep track of sessions that have valid NS trials
%     %     dateNS= [];
%     %     for session = 1:numel(currentSubj) %for each training session this subject completed
%     %         if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
%     % %              subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay); %old method based on trainDay
%     %                 dateNS= cat(2, dateNS, currentSubj(session).date);
%     %         end
%     %     end %end session loop
%     %     
%     %     %search NS dates for the appropriate index in allDates, then label it
%     %     %similar to subjTrial
%     %     for thisDate = 1:numel(dateNS) 
%     %         subjTrialNS(thisDate)= find(allDates==dateNS(thisDate)); %returns the index in allDates that matches the date of this NS session
%     %     end
%          %Color axes   
% 
%          %First, we'll want to establish boundaries for our colormaps based on
%          %the std of the z score response. We want to have equidistant
%          %color axis max and min so that 0 sits directly in the middle
% 
%          %TODO: should this be a pooled std calculation (pooled blue & purple)?
% 
%          %define DS color axes
%          %get the avg std in the blue and purple z score responses to all cues,
%          %get absolute value and then multiply this by some factor to define a color axis max and min
% 
%          stdFactor= 6; %multiplicative factor- how many stds away should we set our max & min color value? 
% 
%              %cond A
%          topDSzblueA= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%          bottomDSzblueA = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             %cond b
%          topDSzblueB= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%          bottomDSzblueB = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             %cond c
%          topDSzblueC= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%          bottomDSzblueC = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             %cond D
%          topDSzblueD= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%          bottomDSzblueD = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%          
%          bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzblueD];
%          tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzblueD];
% 
%        
%          %now choose the most extreme values to represent the color axis
%          bottomAllDS= min(bottoms);
%          topAllDS= max(tops);
% 
%     %     %same, but defining color axes for NS
%     %     if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
%     %         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%     %         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%     % 
%     %         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
%     %         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));
%     % 
%     %         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%     %         topAllNS= max(topNSzblue, topNSzpurple);
%     %     end
%     %     %Establish a shared bottom and top for shared color axis of DS & NS
%     %     if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
%     %         bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%     %         topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
%     %     else
%             bottomMeanShared= bottomAllDS;
%             topMeanShared= topAllDS;
%     %     end
% 
% 
% 
%     timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
%     % 
% 
%       % ~~~~~~~~~~ One figure with only Blue response to DS & NS ~~~~~~~
%             
%         figure(figureCount);
%         figureCount= figureCount+1;
% 
%         sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' Avg response to DS or NS across 5 subjects')); %add big title above all subplots
% 
% 
%         subplot(2,4,1) %plot of stage 1-4 blue (cond A blue)
%         
%             imagesc(timeLock, sessA,allRats(1).grandMeanDSzblueA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stages 1-4 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%         subplot(2,4,2) %plot of stage 1-4 blue (cond B blue)
%         
%             imagesc(timeLock, sessB,allRats(1).grandMeanDSzblueB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stage 5 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%         
%      subplot(2,4,3) %plot of stage 1-4 blue (cond C blue)
%         
%             imagesc(timeLock, sessC,allRats(1).grandMeanDSzblueC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%        
%     subplot(2,4,4) %plot of stage 1-4 blue (cond D blue)
%         
%             imagesc(timeLock, sessD,allRats(1).grandMeanDSzblueD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessD); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%           
%                    
%       subplot(2,4,6) %plot of NS stage 5 blue (cond B blue)
%         
%             imagesc(timeLock, sessB,allRats(1).grandMeanNSzblueB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg NS response Stage 5 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%        subplot(2,4,7) %plot of NS stage 6-7 blue (cond C blue)
%         
%             imagesc(timeLock, sessC,allRats(1).grandMeanNSzblueC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg NS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%             
%         subplot(2,4,8) %plot of NS stage 8 blue (cond D blue)
%         
%             imagesc(timeLock, sessD,allRats(1).grandMeanNSzblueD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg DS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', sessD); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    
%% stage 1-4, 5, 6+ trial DS plots latency sorted
% 
% 
% %we'll pull from the subjDataAnalyzed struct to make our heatplots
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
% 
%     %initialize/clear arrays between subjects
%     currentSubj(1).NSzblueAllTrials= [];
%     currentSubj(1).NSzpurpleAllTrials= [];
%     currentSubj(1).NSpeLatencyAllTrials= [];
% 
%     sesCountA= 1;
%     sesCountB= 1;
%     sesCountC= 1;
%     sesCountD=1;
% 
%     subjSessA= [];
%     subjSessB= [];
%     subjSessC= [];
%     subjSessD= [];
%     
%     trialAcount= 1;
%     trialBcount=1;
%     trialCcount=1;
%     trialDcount=1;
%     
%     trialBNScount=1;
%     trialCNScount=1;
%     trialDNScount=1;
%     
%     DSloxAllTrialsA = [];
%     DSloxAllTrialsB= [];
%     DSloxAllTrialsC= [];
%     DSloxAllTrialsD= [];
%     
%     NSloxAllTrialsA= [];
%     NSloxAllTrialsB= [];
%     NSloxAllTrialsC= [];
%     NSloxAllTrialsD= [];
%     
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%        
%         clear NSselected
%         
%         %We can only include trials that have a PE latency, so we need to
%         %selectively extract these data first
%         
%             %get the DS cues
%         DSselected= currentSubj(session).periDS.DS;  % all the DS cues
% 
%         %First, let's exclude trials where animal was already in port
%         %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
%         %have a non-nan value and use these to exclude DS trials from this
%         %analysis (we'll make them nan)
%             
%         %We have to throw in an extra conditional in case we've excluded
%         %cues in our peri cue analysis due to being too close to the
%         %beginning or end. Otherwise, we can get an out of range error
%         %because the inPortDS array doesn't exclude these cues.
%         for inPortTrial = find(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS))
%             if inPortTrial < numel(DSselected) 
%                 DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;
%             end
%         end
%         %Then, let's exclude trials where animal didn't make a PE during
%         %the cue epoch. To do so, get indices of empty cells in
%         %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
%         %happened during the cue epoch) and then use these to set that DS =
%         %nan
%         
%         %same here, we need an extra conditional in case cues were excluded
%         for noPEtrial = find(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS))
%             if noPEtrial < numel(DSselected)
%                 DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
%             end
%         end
%         
%         %this may create some zeros, so let's make those nan as well
%         DSselected(DSselected==0) = nan;
%         
%         %lets convert this to an index of trials with a valid value 
%         DSselected= find(~isnan(DSselected));
%         
%             %Repeat above for NS 
%         if ~isempty(currentSubj(session).periNS.NS)
%              NSselected= currentSubj(session).periNS.NS;  
% 
%             %First, let's exclude trials where animal was already in port
%             %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
%             %have a non-nan value and use these to exclude NS trials from this
%             %analysis (we'll make them nan)
% 
%             NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;
% 
%             %Then, let's exclude trials where animal didn't make a PE during
%             %the cue epoch. To do so, get indices of empty cells in
%             %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
%             %happened during the cue epoch) and then use these to set that NS =
%             %nan
%             NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
% 
%        
%             %lets convert this to an index of trials with a valid value 
%             NSselected= find(~isnan(NSselected));
%         end %end NS conditional       
%         
%         %Condition A
%             if currentSubj(session).trainStage <5
%                 if sesCountA== 1 
%                     currentSubj(1).DSzblueAllTrialsA= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
%                     currentSubj(1).DSzpurpleAllTrialsA= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
%                     currentSubj(1).DSpeLatencyAllTrialsA= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                     
% %                     currentSubj(1).DSloxAllTrialsA= currentSubj(session).behavior.loxDS{DSselected};
%                     if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                         currentSubj(1).NSzblueAllTrialsA= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
%                         currentSubj(1).NSzpurpleAllTrialsA= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
%                         currentSubj(1).NSpeLatencyAllTrialsA= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                         
%                      else
% %                        continue %continue if no NS data
%                      end
%                 else %add subsequent sessions using cat()
%                     currentSubj(1).DSzblueAllTrialsA = cat(2, currentSubj.DSzblueAllTrialsA, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).DSzpurpleAllTrialsA = cat(2, currentSubj.DSzpurpleAllTrialsA, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).DSpeLatencyAllTrialsA = cat(2,currentSubj(1).DSpeLatencyAllTrialsA,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
% %                     currentSubj(1).DSloxAllTrialsA= cat(2,currentSubj(1).DSloxAllTrialsA,currentSubj(session).behavior.loxDS{DSselected});
% 
%                     if ~isempty(currentSubj(session).periNS.NS)
%                         currentSubj(1).NSzblueAllTrialsA = cat(2, currentSubj.NSzblueAllTrialsA, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
%                         currentSubj(1).NSzpurpleAllTrialsA = cat(2, currentSubj.NSzpurpleAllTrialsA, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
%                         currentSubj(1).NSpeLatencyAllTrialsA = cat(2,currentSubj(1).NSpeLatencyAllTrialsA,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                     else
% %                         continue %continue if no NS data
%                     end
%                 end %end sesCount conditional
% 
%                     % licks
%                     currentSubj(1).DSloxAllTrialsA{sesCountA}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
%                 
%                      %in order to sort licks according to trial by PE latency
%                      %later, we need to reshape the lox cell array from nested
%                      %{session}{cue} to just {cue}
%                       for cue = 1:numel(currentSubj(1).DSloxAllTrialsA{session})
%                           DSloxAllTrialsA{trialAcount} = currentSubj(1).DSloxAllTrialsA{session}{cue};
%                           trialAcount=trialAcount+1;
%                       end           
% 
% %                       trialAcount=1; %reset counter
% %                       % NS licks
% %                     currentSubj(1).NSloxAllTrialsA{session}= currentSubj(session).behavior.loxNSrel(NSselected);
% %                     
% %                     for cue= 1:numel(currentSubj(1).NSloxAllTrialsA{session})
% %                         NSloxAllTrialsA{trialAcount}= currentSubj(1).NSloxAllTrialsA{session}{cue};
% %                         trialAcount=trialAcount+1;
% %                     end
% %                         
%                       
%                 sesCountA= sesCountA+1;
%                 subjSessA= cat(2, subjSessA, currentSubj(session).trainDay); %day count for y axis
% 
%             end %end Cond A
%             
%             %Condition B
%                    if currentSubj(session).trainStage ==5
%                         if sesCountB== 1 
%                             currentSubj(1).DSzblueAllTrialsB= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
%                             currentSubj(1).DSzpurpleAllTrialsB= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
%                             currentSubj(1).DSpeLatencyAllTrialsB= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                              if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                                 currentSubj(1).NSzblueAllTrialsB= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
%                                 currentSubj(1).NSzpurpleAllTrialsB= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
%                                 currentSubj(1).NSpeLatencyAllTrialsB= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                              else
% %                                continue %continue if no NS data
%                              end
%                         else %add subsequent sessions using cat()
%                             currentSubj(1).DSzblueAllTrialsB = cat(2, currentSubj.DSzblueAllTrialsB, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                             currentSubj(1).DSzpurpleAllTrialsB = cat(2, currentSubj.DSzpurpleAllTrialsB, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                             currentSubj(1).DSpeLatencyAllTrialsB = cat(2,currentSubj(1).DSpeLatencyAllTrialsB,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
%                             if ~isempty(currentSubj(session).periNS.NS)
%                                 currentSubj(1).NSzblueAllTrialsB = cat(2, currentSubj.NSzblueAllTrialsB, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
%                                 currentSubj(1).NSzpurpleAllTrialsB = cat(2, currentSubj.NSzpurpleAllTrialsB, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
%                                 currentSubj(1).NSpeLatencyAllTrialsB = cat(2,currentSubj(1).NSpeLatencyAllTrialsB,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                             else
% %                                 continue %continue if nos NS data
%                             end
%                         end %end sesCount conditional
% 
%                         
%                          %licks
%                         currentSubj(1).DSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
% 
%                         currentSubj(1).NSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxNSrel(NSselected);
% 
%                         
%                          %in order to sort licks according to trial by PE latency
%                          %later, we need to reshape the lox cell array from nested
%                          %{session}{cue} to just {cue}
%                           for cue = 1:numel(currentSubj(1).DSloxAllTrialsB{sesCountB})
%                               DSloxAllTrialsB{trialBcount} = currentSubj(1).DSloxAllTrialsB{sesCountB}{cue};
%                               trialBcount=trialBcount+1;
%                           end           
%                                             
%                         for cue= 1:numel(currentSubj(1).NSloxAllTrialsB{sesCountB})
%                             NSloxAllTrialsB{trialBNScount}= currentSubj(1).NSloxAllTrialsB{sesCountB}{cue};
%                             trialBNScount=trialBNScount+1;
%                         end
% 
%                         
%                         sesCountB= sesCountB+1;
%                         subjSessB= cat(2, subjSessB, currentSubj(session).trainDay); %day count for y axis
% 
%                   end %end Cond B
%                   
%               %Condition C
%                if currentSubj(session).trainStage== 6 || currentSubj(session).trainStage ==7
%                    
%                     if sesCountC== 1 
%                         currentSubj(1).DSzblueAllTrialsC= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
%                         currentSubj(1).DSzpurpleAllTrialsC= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
%                         currentSubj(1).DSpeLatencyAllTrialsC= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                          if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                             currentSubj(1).NSzblueAllTrialsC= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
%                             currentSubj(1).NSzpurpleAllTrialsC= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
%                             currentSubj(1).NSpeLatencyAllTrialsC= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                          else
% %                            continue %continue if no NS data
%                          end
%                     else %add subsequent sessions using cat()
%                         currentSubj(1).DSzblueAllTrialsC = cat(2, currentSubj.DSzblueAllTrialsC, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSzpurpleAllTrialsC = cat(2, currentSubj.DSzpurpleAllTrialsC, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSpeLatencyAllTrialsC = cat(2, currentSubj(1).DSpeLatencyAllTrialsC, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
%                         if ~isempty(currentSubj(session).periNS.NS)
%                             currentSubj(1).NSzblueAllTrialsC = cat(2, currentSubj.NSzblueAllTrialsC, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
%                             currentSubj(1).NSzpurpleAllTrialsC = cat(2, currentSubj.NSzpurpleAllTrialsC, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
%                             currentSubj(1).NSpeLatencyAllTrialsC = cat(2,currentSubj(1).NSpeLatencyAllTrialsC,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                         else
% %                             continue %continue if nos NS data
%                         end
%                     end %end sesCount conditional
% 
%                         %licks
%                         currentSubj(1).DSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
% 
%                         currentSubj(1).NSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxNSrel(NSselected);
% 
%                         
%                          %in order to sort licks according to trial by PE latency
%                          %later, we need to reshape the lox cell array from nested
%                          %{session}{cue} to just {cue}
%                           for cue = 1:numel(currentSubj(1).DSloxAllTrialsC{sesCountC})
%                               DSloxAllTrialsC{trialCcount} = currentSubj(1).DSloxAllTrialsC{sesCountC}{cue};
%                               trialCcount=trialCcount+1;
%                           end           
%                                             
%                         for cue= 1:numel(currentSubj(1).NSloxAllTrialsC{sesCountC})
%                             NSloxAllTrialsC{trialCNScount}= currentSubj(1).NSloxAllTrialsC{sesCountC}{cue};
%                             trialCNScount=trialCNScount+1;
%                         end
% 
%                     sesCountC= sesCountC+1;
%                     subjSessC= cat(2, subjSessC, currentSubj(session).trainDay); %day count for y axis
% 
%               end %end Cond C
%               
%                      
%               %Condition D
%                if currentSubj(session).trainStage==8
%                    
%                     if sesCountD== 1 
%                         currentSubj(1).DSzblueAllTrialsD= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
%                         currentSubj(1).DSzpurpleAllTrialsD= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
%                         currentSubj(1).DSpeLatencyAllTrialsD= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
%                          if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
%                             currentSubj(1).NSzblueAllTrialsD= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
%                             currentSubj(1).NSzpurpleAllTrialsD= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
%                             currentSubj(1).NSpeLatencyAllTrialsD= currentSubj(session).behavior.NSpeLatency(NSselected); 
%                          else
% %                            continue %continue if no NS data
%                          end
%                     else %add subsequent sessions using cat()
%                         currentSubj(1).DSzblueAllTrialsD = cat(2, currentSubj.DSzblueAllTrialsD, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSzpurpleAllTrialsD = cat(2, currentSubj.DSzpurpleAllTrialsD, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                         currentSubj(1).DSpeLatencyAllTrialsD = cat(2, currentSubj(1).DSpeLatencyAllTrialsD, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
% 
%                         if ~isempty(currentSubj(session).periNS.NS)
%                             currentSubj(1).NSzblueAllTrialsD = cat(2, currentSubj.NSzblueAllTrialsD, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
%                             currentSubj(1).NSzpurpleAllTrialsD = cat(2, currentSubj.NSzpurpleAllTrialsD, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
%                             currentSubj(1).NSpeLatencyAllTrialsD = cat(2,currentSubj(1).NSpeLatencyAllTrialsD,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
%                         else
% %                             continue %continue if nos NS data
%                         end
%                     end %end sesCount conditional
% 
%                         %licks
%                         currentSubj(1).DSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
% 
%                         currentSubj(1).NSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxNSrel(NSselected);
% 
%                         
%                          %in order to sort licks according to trial by PE latency
%                          %later, we need to reshape the lox cell array from nested
%                          %{session}{cue} to just {cue}
%                           for cue = 1:numel(currentSubj(1).DSloxAllTrialsD{sesCountD})
%                               DSloxAllTrialsD{trialDcount} = currentSubj(1).DSloxAllTrialsD{sesCountD}{cue};
%                               trialDcount=trialDcount+1;
%                           end           
%                                             
%                         for cue= 1:numel(currentSubj(1).NSloxAllTrialsD{sesCountD})
%                             NSloxAllTrialsD{trialDNScount}= currentSubj(1).NSloxAllTrialsD{sesCountD}{cue};
%                             trialDNScount=trialDNScount+1;
%                         end
% 
%                     sesCountD= sesCountD+1;
%                     subjSessD= cat(2, subjSessD, currentSubj(session).trainDay); %day count for y axis
% 
%               end %end Cond D
%               
%               
%               
%     end %end session loop
%     
%     %Sort PE latencies and retrieve an index of the sorted order that
%     %we'll use to sort the photometry data and other behavioralevents(licks)
%     
%         %cond a
%     [DSpeLatencySortedA,DSsortIndA] = sort(currentSubj(1).DSpeLatencyAllTrialsA);       
% %     [NSpeLatencySortedA,NSsortIndA] =  %stages before 5 have no ns %sort(currentSubj(1).NSpeLatencyAllTrialsA);
% 
%          %cond b
%     [DSpeLatencySortedB,DSsortIndB] = sort(currentSubj(1).DSpeLatencyAllTrialsB);       
%     [NSpeLatencySortedB,NSsortIndB] = sort(currentSubj(1).NSpeLatencyAllTrialsB);
%         %cond c
%     [DSpeLatencySortedC,DSsortIndC] = sort(currentSubj(1).DSpeLatencyAllTrialsC);       
%     [NSpeLatencySortedC,NSsortIndC] = sort(currentSubj(1).NSpeLatencyAllTrialsC);
%        %cond D
%     [DSpeLatencySortedD,DSsortIndD] = sort(currentSubj(1).DSpeLatencyAllTrialsD);       
%     [NSpeLatencySortedD,NSsortIndD] = sort(currentSubj(1).NSpeLatencyAllTrialsD);
%     
%     
%     %Sort all trials by PE latency
%         %cond a
%     currentSubj(1).DSzblueAllTrialsA= currentSubj(1).DSzblueAllTrialsA(:,DSsortIndA);
%     currentSubj(1).DSzpurpleAllTrialsA= currentSubj(1).DSzpurpleAllTrialsA(:,DSsortIndA);
% %     currentSubj(1).NSzblueAllTrialsA = currentSubj(1).NSzblueAllTrialsA(:,NSsortIndA);
% %     currentSubj(1).NSzpurpleAllTrialsA= currentSubj(1).NSzpurpleAllTrialsA(:,NSsortIndA);
% 
%              % sort licks
%              currentSubj(1).DSloxAllTrialsA= DSloxAllTrialsA;
%              currentSubj(1).DSloxAllTrialsA= currentSubj(1).DSloxAllTrialsA(:,DSsortIndA);
% 
% 
%          %cond b
%     currentSubj(1).DSzblueAllTrialsB= currentSubj(1).DSzblueAllTrialsB(:,DSsortIndB);
%     currentSubj(1).DSzpurpleAllTrialsB= currentSubj(1).DSzpurpleAllTrialsB(:,DSsortIndB);
%     currentSubj(1).NSzblueAllTrialsB = currentSubj(1).NSzblueAllTrialsB(:,NSsortIndB);
%     currentSubj(1).NSzpurpleAllTrialsB= currentSubj(1).NSzpurpleAllTrialsB(:,NSsortIndB);
%     
%              % sort licks
%              currentSubj(1).DSloxAllTrialsB= DSloxAllTrialsB;
%              currentSubj(1).DSloxAllTrialsB= currentSubj(1).DSloxAllTrialsB(:,DSsortIndB);
%              
%              currentSubj(1).NSloxAllTrialsB= NSloxAllTrialsB;
%              currentSubj(1).NSloxAllTrialsB= currentSubj(1).NSloxAllTrialsB(:,NSsortIndB);
% 
%           %cond C
%     currentSubj(1).DSzblueAllTrialsC= currentSubj(1).DSzblueAllTrialsC(:,DSsortIndC);
%     currentSubj(1).DSzpurpleAllTrialsC= currentSubj(1).DSzpurpleAllTrialsC(:,DSsortIndC);
%     currentSubj(1).NSzblueAllTrialsC = currentSubj(1).NSzblueAllTrialsC(:,NSsortIndC);
%     currentSubj(1).NSzpurpleAllTrialsC= currentSubj(1).NSzpurpleAllTrialsC(:,NSsortIndC);
%                % sort licks
%              currentSubj(1).DSloxAllTrialsC= DSloxAllTrialsC;
%              currentSubj(1).DSloxAllTrialsC= currentSubj(1).DSloxAllTrialsC(:,DSsortIndC);
%              
%              currentSubj(1).NSloxAllTrialsC= NSloxAllTrialsC;
%              currentSubj(1).NSloxAllTrialsC= currentSubj(1).NSloxAllTrialsC(:,NSsortIndC);
%              
%       %cond D
%     currentSubj(1).DSzblueAllTrialsD= currentSubj(1).DSzblueAllTrialsD(:,DSsortIndD);
%     currentSubj(1).DSzpurpleAllTrialsD= currentSubj(1).DSzpurpleAllTrialsD(:,DSsortIndD);
%     currentSubj(1).NSzblueAllTrialsD = currentSubj(1).NSzblueAllTrialsD(:,NSsortIndD);
%     currentSubj(1).NSzpurpleAllTrialsD= currentSubj(1).NSzpurpleAllTrialsD(:,NSsortIndD);
%                % sort licks
%              currentSubj(1).DSloxAllTrialsD= DSloxAllTrialsD;
%              currentSubj(1).DSloxAllTrialsD= currentSubj(1).DSloxAllTrialsD(:,DSsortIndD);
%              
%              currentSubj(1).NSloxAllTrialsD= NSloxAllTrialsD;
%              currentSubj(1).NSloxAllTrialsD= currentSubj(1).NSloxAllTrialsD(:,NSsortIndD);
% 
% 
% 
%     %Transpose these data for readability
%         %cond a
%     currentSubj(1).DSzblueAllTrialsA= currentSubj(1).DSzblueAllTrialsA';
%     currentSubj(1).DSzpurpleAllTrialsA= currentSubj(1).DSzpurpleAllTrialsA';    
% %     currentSubj(1).NSzblueAllTrialsA= currentSubj(1).NSzblueAllTrialsA';
% %     currentSubj(1).NSzpurpleAllTrialsA= currentSubj(1).NSzpurpleAllTrialsA';
%         %cond b
%     currentSubj(1).DSzblueAllTrialsB= currentSubj(1).DSzblueAllTrialsB';
%     currentSubj(1).DSzpurpleAllTrialsB= currentSubj(1).DSzpurpleAllTrialsB';    
%     currentSubj(1).NSzblueAllTrialsB= currentSubj(1).NSzblueAllTrialsB';
%     currentSubj(1).NSzpurpleAllTrialsB= currentSubj(1).NSzpurpleAllTrialsB';
%         %cond c
%     currentSubj(1).DSzblueAllTrialsC= currentSubj(1).DSzblueAllTrialsC';
%     currentSubj(1).DSzpurpleAllTrialsC= currentSubj(1).DSzpurpleAllTrialsC';    
%     currentSubj(1).NSzblueAllTrialsC= currentSubj(1).NSzblueAllTrialsC';
%     currentSubj(1).NSzpurpleAllTrialsC= currentSubj(1).NSzpurpleAllTrialsC';
%         %cond D
%     currentSubj(1).DSzblueAllTrialsD= currentSubj(1).DSzblueAllTrialsD';
%     currentSubj(1).DSzpurpleAllTrialsD= currentSubj(1).DSzpurpleAllTrialsD';    
%     currentSubj(1).NSzblueAllTrialsD= currentSubj(1).NSzblueAllTrialsD';
%     currentSubj(1).NSzpurpleAllTrialsD= currentSubj(1).NSzpurpleAllTrialsD';
%     
%     
%        
%        %get trial count for y axis of heatplot
%    currentSubj(1).totalDScountA= 1:size(currentSubj(1).DSzblueAllTrialsA,1); 
%    currentSubj(1).totalDScountB= 1:size(currentSubj(1).DSzblueAllTrialsB,1); 
%    currentSubj(1).totalDScountC= 1:size(currentSubj(1).DSzblueAllTrialsC,1);
%    currentSubj(1).totalDScountD= 1:size(currentSubj(1).DSzblueAllTrialsD,1);
% 
%    
% %    currentSubj(1).totalNScountA= 1:size(currentSubj(1).NSzblueAllTrialsA,1); 
%    currentSubj(1).totalNScountB= 1:size(currentSubj(1).NSzblueAllTrialsB,1); 
%    currentSubj(1).totalNScountC= 1:size(currentSubj(1).NSzblueAllTrialsC,1);
%    currentSubj(1).totalNScountD= 1:size(currentSubj(1).NSzblueAllTrialsD,1);
% 
% 
% 
% 
%     
%        %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%     
%      %define DS color axes
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
%      
%         %cond A
%      topDSzblueA= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleA= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueA = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleA= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsA, 0, 2))));
%      
%         %cond B
%      topDSzblueB= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleB= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueB = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleB= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsB, 0, 2))));
%         %cond c
%      topDSzblueC= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleC= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueC = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleC= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsC, 0, 2))));
%      
%      bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC];
%      tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC];
%      
%        %cond D
%      topDSzblueD= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurpleD= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblueD = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurpleD= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsD, 0, 2))));
%      
%      bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzblueD, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC, bottomDSzpurpleD];
%      tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzblueD, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC, topDSzpurpleD];
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottoms);
%      topAllDS= max(tops);
%      
% %     %same, but defining color axes for NS
% %     if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
% %         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% %         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% % 
% %         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
% %         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));
% % 
% %         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
% %         topAllNS= max(topNSzblue, topNSzpurple);
% %     end
% %     %Establish a shared bottom and top for shared color axis of DS & NS
% %     if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
% %         bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
% %         topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
% %     else
%         bottomMeanShared= bottomAllDS;
%         topMeanShared= topAllDS;
% %     end
%     
%    
% 
%     timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
% %     %Plots!
% %     
% %         figure(figureCount);
% %         figureCount= figureCount+1;
% % 
% %            sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, ' response to DS across training stages- trials sorted by PE latency')); %add big title above all subplots
% % 
% % 
% %         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
% %         
% %             imagesc(timeLock,currentSubj(1).totalDScountA,currentSubj(1).DSzblueAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('Stage 1-4 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalDScountA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %             
% %         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
% %             
% %             imagesc(timeLock,currentSubj(1).totalDScountB,currentSubj(1).DSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('Stage 5 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalDScountB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %         
% %         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
% %             imagesc(timeLock,currentSubj(1).totalDScountC,currentSubj(1).DSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('Stage 6-8 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% % 
% %       subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
% %         
% %             imagesc(timeLock,currentSubj(1).totalDScountA,currentSubj(1).DSzpurpleAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
% %             title(strcat('Stage 1-4 DS response (405nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalDScountA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %             
% %         subplot(2,3,5) %plot of stage 5 purple (cond B purple)
% %             
% %             imagesc(timeLock,currentSubj(1).totalDScountB,currentSubj(1).DSzpurpleAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).DSzpurpleSessionMean));
% %             title(strcat('Stage 5 DS response (405nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalDScountB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %         
% %         subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
% %             imagesc(timeLock,currentSubj(1).totalDScountC,currentSubj(1).DSzpurpleAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).DSzpurpleSessionMean));
% %             title(strcat(' Stage 6-8 DS response (405nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% % 
% %   %Overlay scatter of PE latency
% %    subplot(2,3,1) %condA DS blue 
% %    hold on
% %    scatter(DSpeLatencySortedA,currentSubj(1).totalDScountA', 'm.');
% %    
% %    subplot(2,3,2) %condB DS blue 
% %    hold on
% %    scatter(DSpeLatencySortedB,currentSubj(1).totalDScountB', 'm.');
% %       
% %    subplot(2,3,3) %condC DS blue 
% %    hold on
% %    scatter(DSpeLatencySortedC,currentSubj(1).totalDScountC', 'm.');
% %    
% %    subplot(2,3,4) %cond A DS purple
% %    hold on
% %    scatter(DSpeLatencySortedA,currentSubj(1).totalDScountA', 'm.');
% %    
% %    subplot(2,3,5) %cond B DS purple
% %    hold on
% %    scatter(DSpeLatencySortedB,currentSubj(1).totalDScountB', 'm.');
% %    
% %    subplot(2,3,6) %cond C DS purple
% %    hold on
% %    scatter(DSpeLatencySortedC,currentSubj(1).totalDScountC', 'm.');
% %    
% %    
% %     %overlay scatter of Licks- 
% %        licksToPlot= 3;
% %        lickAlpha= 0.15;
% %     
% %        subplot(2,3,1) %condA DS blue 
% %        hold on
% %        for trial= (currentSubj(1).totalDScountA)
% %            %scatter all licks
% % %                s= scatter(currentSubj(1).DSloxAllTrialsA{trial},ones(numel(currentSubj(1).DSloxAllTrialsA{trial}),1)*currentSubj(1).totalDScountA(trial), 'k.');
% %            %scatter # of licksToPlot
% %            if numel(currentSubj(1).DSloxAllTrialsA{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).DSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountA(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %     
% %        subplot(2,3,2) %condB DS blue 
% %        hold on
% %        for trial= (currentSubj(1).totalDScountB)
% %                %scatter # of licksToPlot
% %            if numel(currentSubj(1).DSloxAllTrialsB{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).DSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountB(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %        
% %        subplot(2,3,3) %condC DS blue 
% %        hold on
% %        for trial= (currentSubj(1).totalDScountC)
% %                 %scatter # of licksToPlot
% %            if numel(currentSubj(1).DSloxAllTrialsC{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).DSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountC(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %     
% %        subplot(2,3,4) %condA DS purple 
% %        hold on
% %        for trial= (currentSubj(1).totalDScountA)
% %                %scatter # of licksToPlot
% %            if numel(currentSubj(1).DSloxAllTrialsA{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).DSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountA(trial), 'k.');
% %                 s.MarkerEdgeAlpha= 0.3; %make transparent
% %            end
% %        end
% %        
% %        subplot(2,3,5) %condB DS purple 
% %        hold on
% %        for trial= (currentSubj(1).totalDScountB)
% %                %scatter # of licksToPlot
% %            if numel(currentSubj(1).DSloxAllTrialsB{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).DSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountB(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %        
% %        subplot(2,3,6) %condC DS purple 
% %        hold on
% %        for trial= (currentSubj(1).totalDScountC)
% %               %scatter # of licksToPlot
% %            if numel(currentSubj(1).DSloxAllTrialsC{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).DSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountC(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %        
% %        
% %             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% % 
% %     
% %     
% %     %NS plots!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% % 
% %        figure(figureCount);
% %        figureCount= figureCount+1;
% % 
% %        sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, ' response to NS across training stages- trials sorted by PE latency')); %add big title above all subplots
% % 
% % 
% %         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
% %         
% % %             imagesc(timeLock,currentSubj(1).totalNScountA,currentSubj(1).NSzblueAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% % %             title(strcat('Stage 1-4 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% % %             xlabel('seconds from cue onset');
% % %             ylabel('trial (latency sorted)');
% % % %             set(gca, 'ytick', currentSubj(1).totalNScountA); %label trials appropriately
% % %             caxis manual;
% % %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % % 
% % %             c= colorbar; %colorbar legend
% % %             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %             
% %             
% %         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
% %             
% %             imagesc(timeLock,currentSubj(1).totalNScountB,currentSubj(1).NSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('Stage 5 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalNScountB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %         
% %         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
% %             imagesc(timeLock,currentSubj(1).totalNScountC,currentSubj(1).NSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('Stage 6-8 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% % 
% %       subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
% % %         
% % %             imagesc(timeLock,currentSubj(1).totalNScountA,currentSubj(1).NSzpurpleAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% % %             title(strcat('Stage 1-4 NS response (405nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% % %             xlabel('seconds from cue onset');
% % %             ylabel('trial (latency sorted)');
% % % %             set(gca, 'ytick', currentSubj(1).totalNScountA); %label trials appropriately
% % %             caxis manual;
% % %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % % 
% % %             c= colorbar; %colorbar legend
% % %             c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% % %               
% %             
% %             
% %         subplot(2,3,5) %plot of stage 5 purple (cond B purple)
% %             
% %             imagesc(timeLock,currentSubj(1).totalNScountB,currentSubj(1).NSzpurpleAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).NSzpurpleSessionMean));
% %             title(strcat('Stage 5 NS response (405nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalNScountB); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
% %         
% %         subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
% %             imagesc(timeLock,currentSubj(1).totalNScountC,currentSubj(1).NSzpurpleAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).NSzpurpleSessionMean));
% %             title(strcat(' Stage 6-8 NS response (405nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% % 
% %             
% %             
% %             %Overlay scatter of PE latency
% %    subplot(2,3,1) %condA NS blue 
% %    hold on
% % %    scatter(NSpeLatencySortedA,currentSubj(1).totalNScountA', 'm.');
% %    
% %    subplot(2,3,2) %condB NS blue 
% %    hold on
% %    scatter(NSpeLatencySortedB,currentSubj(1).totalNScountB', 'm.');
% %       
% %    subplot(2,3,3) %condC NS blue 
% %    hold on
% %    scatter(NSpeLatencySortedC,currentSubj(1).totalNScountC', 'm.');
% %    
% %    subplot(2,3,4) %cond A NS purple
% %    hold on
% % %    scatter(NSpeLatencySortedA,currentSubj(1).totalNScountA', 'm.');
% %    
% %    subplot(2,3,5) %cond B NS purple
% %    hold on
% %    scatter(NSpeLatencySortedB,currentSubj(1).totalNScountB', 'm.');
% %    
% %    subplot(2,3,6) %cond C NS purple
% %    hold on
% %    scatter(NSpeLatencySortedC,currentSubj(1).totalNScountC', 'm.');
% %    
% %             
% %      %overlay scatter of Licks- 
% %        licksToPlot= 3;
% %       lickAlpha= 0.35;
% % 
% %     
% %        subplot(2,3,1) %condA NS blue 
% % %        hold on
% % %        for trial= (currentSubj(1).totalNScountA)
% %            %scatter all licks
% % %                s= scatter(currentSubj(1).NSloxAllTrialsA{trial},ones(numel(currentSubj(1).NSloxAllTrialsA{trial}),1)*currentSubj(1).totalNScountA(trial), 'k.');
% %            %scatter # of licksToPlot
% % %            if numel(currentSubj(1).NSloxAllTrialsA{trial}) >= licksToPlot
% % %                 s= scatter(currentSubj(1).NSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountA(trial), 'k.');
% % %                 s.MarkerEdgeAlpha= 0.3; %make transparent
% % %            end
% % %        end
% %     
% %        subplot(2,3,2) %condB NS blue 
% %        hold on
% %        for trial= (currentSubj(1).totalNScountB)
% %                %scatter # of licksToPlot
% %            if numel(currentSubj(1).NSloxAllTrialsB{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).NSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountB(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %        
% %        subplot(2,3,3) %condC NS blue 
% %        hold on
% %        for trial= (currentSubj(1).totalNScountC)
% %                 %scatter # of licksToPlot
% %            if numel(currentSubj(1).NSloxAllTrialsC{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).NSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountC(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %     
% %        subplot(2,3,4) %condA NS purple 
% % %        hold on
% % %        for trial= (currentSubj(1).totalNScountA)
% % %                %scatter # of licksToPlot
% % %            if numel(currentSubj(1).NSloxAllTrialsA{trial}) >= licksToPlot
% % %                 s= scatter(currentSubj(1).NSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountA(trial), 'k.');
% % %                 s.MarkerEdgeAlpha= 0.3; %make transparent
% % %            end
% %        
% %        subplot(2,3,5) %condB NS purple 
% %        hold on
% %        for trial= (currentSubj(1).totalNScountB)
% %                %scatter # of licksToPlot
% %            if numel(currentSubj(1).NSloxAllTrialsB{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).NSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountB(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %        
% %        subplot(2,3,6) %condC NS purple 
% %        hold on
% %        for trial= (currentSubj(1).totalNScountC)
% %               %scatter # of licksToPlot
% %            if numel(currentSubj(1).NSloxAllTrialsC{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).NSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountC(trial), 'k.');
% %                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %            end
% %        end
% %             
% %             
% %             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% % 
% %             
%             
%     % ~~~~ One figure with only Blue response to both DS & NS ~~~~~~~~~~~~~~~~~~~~
%             
%               figure(figureCount);
%         figureCount= figureCount+1;
% 
%            sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, ' response to DS or NS across training stages- trials sorted by PE latency')); %add big title above all subplots
% 
% 
%         subplot(2,4,1) %plot of stage 1-4 blue (cond A blue)
%         
%             imagesc(timeLock,currentSubj(1).totalDScountA,currentSubj(1).DSzblueAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 1-4 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,4,2) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,currentSubj(1).totalDScountB,currentSubj(1).DSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 5 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,4,3) %plot of stage 6-7 blue (cond C blue)
%             imagesc(timeLock,currentSubj(1).totalDScountC,currentSubj(1).DSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 6-7 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%          subplot(2,4,4) %plot of stage 8 blue (cond D blue)
%             imagesc(timeLock,currentSubj(1).totalDScountD,currentSubj(1).DSzblueAllTrialsD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 8 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%         subplot(2,4,6) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,currentSubj(1).totalNScountB,currentSubj(1).NSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('Stage 5 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,4,7) %plot of stage 6-7 blue (cond C blue)
%             imagesc(timeLock,currentSubj(1).totalNScountC,currentSubj(1).NSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('Stage 6-7 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
%             
%         subplot(2,4,8) %plot of stage 8 blue (cond D blue)
%             imagesc(timeLock,currentSubj(1).totalNScountD,currentSubj(1).NSzblueAllTrialsD) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('Stage 8 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%             
% 
%       %Overlay scatter of PE latency
%            subplot(2,4,1) %condA DS blue 
%            hold on
%            scatter(DSpeLatencySortedA,currentSubj(1).totalDScountA', 'm.');
% 
%            subplot(2,4,2) %condB DS blue 
%            hold on
%            scatter(DSpeLatencySortedB,currentSubj(1).totalDScountB', 'm.');
% 
%            subplot(2,4,3) %condC DS blue 
%            hold on
%            scatter(DSpeLatencySortedC,currentSubj(1).totalDScountC', 'm.');
%                  
%            subplot(2,4,4) %condD DS blue 
%            hold on
%            scatter(DSpeLatencySortedD,currentSubj(1).totalDScountD', 'm.');
%            
%            subplot(2,4,6) %condB NS blue 
%            hold on
%            scatter(NSpeLatencySortedB,currentSubj(1).totalNScountB', 'm.');
% 
%            subplot(2,4,7) %condC NS blue 
%            hold on
%            scatter(NSpeLatencySortedC,currentSubj(1).totalNScountC', 'm.');
%            
%            subplot(2,4,8) %condC NS blue 
%            hold on
%            scatter(NSpeLatencySortedD,currentSubj(1).totalNScountD', 'm.');
% %             
% %     %overlay scatter of Licks- 
% %            licksToPlot= 3;
% %            lickAlpha= 0.15;
% % 
% %            subplot(2,4,1) %condA DS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalDScountA)
% %                %scatter all licks
% %                    s= scatter(currentSubj(1).DSloxAllTrialsA{trial},ones(numel(currentSubj(1).DSloxAllTrialsA{trial}),1)*currentSubj(1).totalDScountA(trial), 'k.');
% %                %scatter # of licksToPlot
% % %                if numel(currentSubj(1).DSloxAllTrialsA{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).DSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountA(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% % 
% %            subplot(2,4,2) %condB DS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalDScountB)
% %                %scatter all licks
% %                s= scatter(currentSubj(1).DSloxAllTrialsB{trial},ones(numel(currentSubj(1).DSloxAllTrialsB{trial}),1)*currentSubj(1).totalDScountB(trial), 'k.');
% % 
% %                    %scatter # of licksToPlot
% % %                if numel(currentSubj(1).DSloxAllTrialsB{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).DSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountB(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% % 
% %            subplot(2,4,3) %condC DS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalDScountC)
% %                %scatter all licks
% %                s= scatter(currentSubj(1).DSloxAllTrialsC{trial},ones(numel(currentSubj(1).DSloxAllTrialsC{trial}),1)*currentSubj(1).totalDScountC(trial), 'k.');
% % 
% %                     %scatter # of licksToPlot
% % %                if numel(currentSubj(1).DSloxAllTrialsC{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).DSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountC(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% % 
% %           subplot(2,4,4) %condD DS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalDScountD)
% %                %scatter all licks
% %                s= scatter(currentSubj(1).DSloxAllTrialsD{trial},ones(numel(currentSubj(1).DSloxAllTrialsD{trial}),1)*currentSubj(1).totalDScountD(trial), 'k.');
% % 
% %                     %scatter # of licksToPlot
% % %                if numel(currentSubj(1).DSloxAllTrialsD{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).DSloxAllTrialsD{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountD(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% % 
% %            
% %            
% %            subplot(2,4,6) %condB NS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalNScountB)
% %               
% %                %scatter all licks
% %                s= scatter(currentSubj(1).NSloxAllTrialsB{trial},ones(numel(currentSubj(1).NSloxAllTrialsB{trial}),1)*currentSubj(1).totalNScountB(trial), 'k.');
% % 
% %                
% %                    %scatter # of licksToPlot
% % %                if numel(currentSubj(1).NSloxAllTrialsB{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).NSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountB(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% % 
% %            subplot(2,4,7) %condC NS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalNScountC)
% %                 %scatter all licks
% %                s= scatter(currentSubj(1).NSloxAllTrialsC{trial},ones(numel(currentSubj(1).NSloxAllTrialsC{trial}),1)*currentSubj(1).totalNScountC(trial), 'k.');
% % 
% %                
% %                     %scatter # of licksToPlot
% % %                if numel(currentSubj(1).NSloxAllTrialsC{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).NSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountC(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% %            
% %            subplot(2,4,8) %condD NS blue 
% %            hold on
% %            for trial= (currentSubj(1).totalNScountD)
% %                
% %                    %scatter all licks
% %                s= scatter(currentSubj(1).NSloxAllTrialsD{trial},ones(numel(currentSubj(1).NSloxAllTrialsD{trial}),1)*currentSubj(1).totalNScountD(trial), 'k.');
% % 
% %                     %scatter # of licksToPlot
% % %                if numel(currentSubj(1).NSloxAllTrialsD{trial}) >= licksToPlot
% % %                     s= scatter(currentSubj(1).NSloxAllTrialsD{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountD(trial), 'k.');
% %                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% % %                end
% %            end
% %            
%            set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%            
% end%end subj loop

%% ~~~ End~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Save the analyzed data 
%save the subjDataAnalyzed struct for later analysis
 
%saving as v7.3 takes longer, but necessary if >2gb
save(strcat(experimentName,'-', date, 'subjDataAnalyzed.mat'), 'subjDataAnalyzed', '-v7.3'); %the second argument here is the variable being saved, the first is the filename %v7.3 .mat for files >2gb

allRats.preCueFrames= preCueFrames;
allRats.postCueFrames= postCueFrames;
allRats.timeLock= timeLock;
save(strcat(experimentName,'_allRats.mat'), 'allRats');

disp(strcat('all done, expect ', num2str(figureCount-1), ' figures'));
figureCount=1;

%%  Speed test /optimizing

profile viewer;
% %things that should be optimized:


%% Example structure of loop through subjects and sessions 
% for subj= 1:numel(subjects) %for each subject
%    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%    end %end session loop
% end %end subject loop


