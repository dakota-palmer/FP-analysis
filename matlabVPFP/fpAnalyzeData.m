%fp data analysis 
%12/4/19
clear
clc
close all

% Make sure the figPath is correct!

figPath = 'C:\Users\capn1\Desktop\testFigs\'; %location for output figures to be saved

% %% Load struct containing data organized by subject
disp('***select a .mat file generated by fpExtractData.m')

load(uigetfile('*.mat')); %choose the subjData file to open for your experiment %by default only show .mat files

profile on; %For optimization/tracking performance of the code- this starts the Matlab profiler

subjects= fieldnames(subjData); %access subjData struct with dynamic fieldnames; these are determined by fpExtractData and the metadata.xlsx

figureCount= 1 ; %keep track of figure # throughout to prevent overwriting

fs= 40; %This is important- if you change sampling frequency of photometry recordings for some reason, change this too! TODO: just save this in subjData as more metadata

%% ~~~Photometry plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% Within-subjects raw photometry plots 
%In this section, we'll plot the "raw" (it's been preprocessed and
%downsampled) 405nm and 465nm photometry traces from each session. This makes 
%one figure per subject with all session traces subplotted so may be slow if you have a lot of sessions

for subj= 1:numel(subjects) %for each subject
    
    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
    
    disp(strcat('plotting photometry data for_', subjects{subj}));
    
    figure(figureCount) %one figure per subject, with all sessions subplotted
    figureCount= figureCount+1;
    
   sgtitle(strcat(currentSubj(1).experiment, subjects{subj}, 'downsampled photometry traces')); %add big title above all subplots
    
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
      
       % Raw session plots- within subjects
        subplot(numel(subjData.(subjects{subj})),1,session); %one subplot per session
        hold on
        plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
        plot(currentSubj(session).cutTime, currentSubj(session).repurple,'m'); %plot 405nm trace
        title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
        xlabel('time (s)');
        ylabel('mV');
        legend('blue (465)',' purple (405)');
   end  
        %make figure full screen, save, and close this figure
        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%         saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'_downsampled_session_traces','.fig'));
        close; %close 
end

%% Create subjDataAnalyzed struct to hold analyzed data
%In this section, we'll initialize a subjDataAnalyzed struct to hold any
%relevant analyzed data separately from raw data. We will populate it with
%some metadata before doing any analyses. This metadata all originates from
%the metadata.xlsx file and the subjData struct generated by
%fpExtractData.m

%Fill with metadata
 for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       experimentName= currentSubj(session).experiment; 
       
       subjDataAnalyzed.(subjects{subj})(session).experiment= currentSubj(session).experiment;
       subjDataAnalyzed.(subjects{subj})(session).rat= currentSubj(session).rat;
       subjDataAnalyzed.(subjects{subj})(session).fileName= currentSubj(session).fileName;
       subjDataAnalyzed.(subjects{subj})(session).trainDay= currentSubj(session).trainDay;
       subjDataAnalyzed.(subjects{subj})(session).trainStage= currentSubj(session).trainStage;
       subjDataAnalyzed.(subjects{subj})(session).box= currentSubj(session).box;       
   end %end session loop
end %end subject loop

%% ~~~Behavioral Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


%% Identify PEs and licks occuring during the DS 

% Here, we'll loop through every cue in every session, finding the cue
% onset time and the cue's duration. Then, we'll check for PEs and licks
% that occur during this duration and assign them to that cue.

disp('classifying events during cue epoch');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
  
   for session = 1:numel(currentSubj) %for each training session this subject completed    
  
        clear cutTime poxDS loxDS outDS %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

           %initialize cell arrays, so they're all the same size for
            %convenience
            currentSubj(session).behavior.poxDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.outDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.loxDS= cell(1,numel(currentSubj(session).DS));

        %First, let's establish the cue duration based on training stage
        if currentSubj(session).trainStage == 1
            cueLength= 60*fs; %60s on stage 1, multiply by fs to get #frames
        elseif currentSubj(session).trainStage ==2
            cueLength= 30*fs;
        elseif currentSubj(session).trainStage ==3
            cueLength= 20*fs;
        else %on subsequent stages, cueLength is 10s
            cueLength =10*fs; 
        end
        
        for cue=1:length(currentSubj(session).DS) %for each DS cue in this session

            %each entry in DS is a timestamp of the DS onset, let's get its
            %corresponding index from cutTime and use that to pull
            %surrounding data
            DSonset = find(cutTime==currentSubj(session).DSshifted(cue,1));
                     
            
            %find an save pox during the cue duration
            poxDScount= 1; %counter for indexing
            
            for i = 1:numel(currentSubj(session).pox) % for every port entry logged during this session
               if (cutTime(DSonset)<currentSubj(session).pox(i)) && (currentSubj(session).pox(i)<cutTime(DSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                    currentSubj(session).behavior.poxDS{1,cue}(poxDScount,1)= currentSubj(session).pox(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                    poxDScount=poxDScount+1; %iterate the counter
               end
            end
           
            
            %find and save port exits during the cue
            outDScount= 1;
            for i = 1:numel(currentSubj(session).out) % for every port entry logged during this session
               if (cutTime(DSonset)<currentSubj(session).out(i)) && (currentSubj(session).out(i)<cutTime(DSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                    currentSubj(session).behavior.outDS{1,cue}(outDScount,1)= currentSubj(session).out(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                    outDScount=outDScount+1; %iterate the counter
               end
            end
            
            
            %find and save licks during the cue duration
            loxDScount= 1; %counter for indexing
            
            for i = 1:numel(currentSubj(session).lox) % for every port entry logged during this session
               if (cutTime(DSonset)<currentSubj(session).lox(i)) && (currentSubj(session).lox(i)<cutTime(DSonset+cueLength)) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                    currentSubj(session).behavior.loxDS{1,cue}(loxDScount,1)= currentSubj(session).lox(i); %cell array containing all pox during the cue, empty [] if no licks during the cue
                    loxDScount=loxDScount+1; %iterate the counter
               end
            end
                        
        end %end cue loop
               
        subjDataAnalyzed.(subjects{subj})(session).behavior= currentSubj(session).behavior; %save the results

   end %end session loop
     
end %end subject loop


%% Identify PEs and licks occuring during the NS 

% Here, we'll loop through every cue in every session, finding the cue
% onset time and the cue's duration. Then, we'll check for PEs and licks
% that occur during this duration and assign them to that cue.

disp('classifying events during NS cue epoch');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
  
   for session = 1:numel(currentSubj) %for each training session this subject completed    
  
        clear cutTime poxNS loxNS outNS %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

           %initialize cell arrays, so they're all the same size for
            %convenience
            currentSubj(session).behavior.poxNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.outNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.loxNS= cell(1,numel(currentSubj(session).NS));

        %First, let's establish the cue duration based on training stage
        if currentSubj(session).trainStage == 1
            cueLength= 60*fs; %60s on stage 1, multiply by fs to get #frames
        elseif currentSubj(session).trainStage ==2
            cueLength= 30*fs;
        elseif currentSubj(session).trainStage ==3
            cueLength= 20*fs;
        else %on subsequent stages, cueLength is 10s
            cueLength =10*fs; 
        end
        
        if ~isnan(currentSubj(session).NS) %can only run if NS data is present in session        
        
            for cue=1:length(currentSubj(session).NS) %for each NS cue in this session

                %each entry in NS is a timestamp of the NS onset, let's get its
                %corresponding index from cutTime and use that to pull
                %surrounding data
                NSonset = find(cutTime==currentSubj(session).NSshifted(cue,1));


                %find an save pox during the cue duration
                poxNScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).pox) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).pox(i)) && (currentSubj(session).pox(i)<cutTime(NSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.poxNS{1,cue}(poxNScount,1)= currentSubj(session).pox(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        poxNScount=poxNScount+1; %iterate the counter
                   end
                end


                %find and save port exits during the cue
                outNScount= 1;
                for i = 1:numel(currentSubj(session).out) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).out(i)) && (currentSubj(session).out(i)<cutTime(NSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.outNS{1,cue}(outNScount,1)= currentSubj(session).out(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        outNScount=outNScount+1; %iterate the counter
                   end
                end


                %find and save licks during the cue duration
                loxNScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).lox) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).lox(i)) && (currentSubj(session).lox(i)<cutTime(NSonset+cueLength)) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.loxNS{1,cue}(loxNScount,1)= currentSubj(session).lox(i); %cell array containing all pox during the cue, empty [] if no licks during the cue
                        loxNScount=loxNScount+1; %iterate the counter
                   end
                end

            end %end cue loop            
        end %end NS conditional

        %save the results
        subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS= currentSubj(session).behavior.poxNS; 
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS= currentSubj(session).behavior.outNS;
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS= currentSubj(session).behavior.loxNS;
        
   end %end session loop
     
end %end subject loop


%% Identify trials where animal was waiting in port at cue onset

%here, we'll go through all cues from each session, finding the difference
%between the cue onset time and every logged port entry and port exit
%timestamp. We'll find the port entry and port exit that is closest (minimum difference) to the
%cue onset, then we'll compare these two. We will only look in one
%direction (after the cue onset time) by turning any negative differences
%into large positive differences. If the closest out pulse is closer to the cue onset
%than the closest port entry pulse, then the animal was already in the port
%on that trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       clear poxDiffDS outDiffDS poxDiffNS outDiffNS
       
       %loop through DS cues
        for cue = 1:numel(currentSubj(session).DS) %for each DS
            %for each pox timestamp, get the difference between the pox and this DS cue's onset
            for i = 1:numel(currentSubj(session).pox) 
                poxDiffDS(i) = currentSubj(session).pox(i)- currentSubj(session).DS(cue,1);
            end
            
            %get rid of negative values by making them very large
            %this way we're only looking at TTLs after cue onset
            poxDiffDS(poxDiffDS<0) = 99999; 
            
            [~,minPoxInd] = min(poxDiffDS);
                           
            currentSubj(session).pox(minPoxInd);

            for i= 1:numel(currentSubj(session).out)
                outDiffDS(i)= currentSubj(session).out(i)- currentSubj(session).DS(cue,1);
            end

            outDiffDS(outDiffDS<0)= 99999; %make any negative differences very large
            
            %if the closest TTL pulse to cue onset was an out, the animal was in the port already
            if min(outDiffDS)<min(poxDiffDS)
                
                currentSubj(session).inPortDS(1,cue)= cue;
%                 disp(strcat(subjects{subj}, 'session', num2str(session), '_DS_', num2str(cue), ' inPortDS '));

            else
                currentSubj(session).inPortDS(1,cue)= NaN;
            end
            
       end %end DS loop
       
   %Repeat for NS
   
        for cue = 1:numel(currentSubj(session).NS) %for each NS
            
            %for each pox timestamp, get the difference between the pox and this NS cue's onset
            for i = 1:numel(currentSubj(session).pox) 
                poxDiffNS(i) = currentSubj(session).pox(i)- currentSubj(session).NS(cue,1);
            end
            
            %get rid of negative values by making them very large
            %this way we're only looking at TTLs after cue onset
            poxDiffNS(poxDiffNS<0) = 99999; 
            
            [~,minPoxInd] = min(poxDiffNS);
                           
            currentSubj(session).pox(minPoxInd);

            for i= 1:numel(currentSubj(session).out)
                outDiffNS(i)= currentSubj(session).out(i)- currentSubj(session).NS(cue,1);
            end

            outDiffNS(outDiffNS<0)= 99999; %make any negative differences very large
            
            %if the closest TTL pulse to cue onset was an out, the animal was in the port already
            if min(outDiffNS)<min(poxDiffNS)
                
                currentSubj(session).inPortNS(1,cue)= cue;
%                 disp(strcat(subjects{subj}, 'session', num2str(session), '_NS_', num2str(cue), ' inPortNS '));

            else
                currentSubj(session).inPortNS(1,cue)= NaN;
            end
            
       end %end NS loop
       
       
       subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS= currentSubj(session).inPortDS;
       subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS= currentSubj(session).inPortNS;
       
   end %end session loop
end %end subject loop

%% Calculate DS PE latency
%relies on previous behavioral analyses sections
%here, we will calculate latency to enter port on every DS trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       %First, let's exclude trials where there was 1) no PE in the cue
       %epoch or 2) animal was already in the port at cue onset
        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
       
       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
                DSonset= DSselected(cue);
                firstPox = min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS{cue}); %min of poxDS= first PE after DS onset
                
                currentSubj(session).DSpeLatency(1,cue)= firstPox-DSonset;
%                  if currentSubj(session).DSpeLatency(1,cue)== 0 || currentSubj(session).DSpeLatency(1,cue)<0
%                     disp(currentSubj(session).DSpeLatency(1,cue) ) %Flag abnomal latency values
%                  end
           else %else if we want to skip over this cue, make latency nan
               currentSubj(session).DSpeLatency(1,cue) = nan;
           end               
       end %end DSselected loop
          
       subjDataAnalyzed.(subjects{subj})(session).behavior.DSpeLatency= currentSubj(session).DSpeLatency;
       
   end %end session loop
     
end %end subject loop


%% Calculate NS PE latency
%relies on previous behavioral analyses sections
%here, we will calculate latency to enter port on every NS trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       %First, let's exclude trials where there was 1) no PE in the cue
       %epoch or 2) animal was already in the port at cue onset
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that NS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
       
       
       for cue = 1:numel(NSselected)
            
           if ~isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
                NSonset= NSselected(cue);
                firstPox = min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS{cue}); %min of poxNS= first PE after NS onset
                
                currentSubj(session).NSpeLatency(1,cue)= firstPox-NSonset;
                
           else %else if we want to skip over this cue, make latency nan
               currentSubj(session).NSpeLatency(1,cue) = nan;
           end               
       end %end NSselected loop
          
       subjDataAnalyzed.(subjects{subj})(session).behavior.NSpeLatency= currentSubj(session).NSpeLatency;

   end %end session loop
     
end %end subject loop

%% Calculate DS PE ratio
%relies on previous behavioral analyses sections
%here, we will calculate DS pe ratio

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
        DSselected= currentSubj(session).DS;  

       
        %We could exclude trials where animal was already in port, but
        %won't due this because they still receive a reward and MEDPC still
        %counts it toward the ratio
%         DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        currentSubj(session).DSpeRatio= numel(DSselected(~isnan(DSselected)))/numel(currentSubj(session).DS);
        
        
       subjDataAnalyzed.(subjects{subj})(session).behavior.DSpeRatio= currentSubj(session).DSpeRatio;

   end %end session loop
      
end %end subj loop

%% Calculate NS PE ratio
%relies on previous behavioral analyses sections
%here, we will calculate NS pe ratio

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
        NSselected= currentSubj(session).NS;  

       
        %We could exclude trials where animal was already in port, but
        %won't due this because they still receive a reward and MEDPC still
        %counts it toward the ratio
%         NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that NS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
        
        if ~isnan(currentSubj(session).NS) %if there's NS data present, calculate ratio
            currentSubj(session).NSpeRatio= numel(NSselected(~isnan(NSselected)))/numel(currentSubj(session).NS);
        else % if no NS data present, make ratio nan
            currentSubj(session).NSpeRatio= nan;
        end %end ns conditional
        
       subjDataAnalyzed.(subjects{subj})(session).behavior.NSpeRatio= currentSubj(session).NSpeRatio;

        
   end %end session loop
      
end %end subj loop


%% ~~~Event-Triggered Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%In these sections, we will do an event-triggered analyses by extracting data 
%from the photometry traces immediately surrounding relevant behavioral events (e.g. cue onset, port entry, lick)
%To do so, we'll find the onset timestamp for each event (eventTime) and use this
%timestamp to extract photometry data surrounding it
%(preEventTime:postEventTime). This will be saved to the subjDataAnalyzed
%struct. 


%here we are establishing some variables for our event triggered-analysis
periCueTime = 20;% t in seconds to examine before/after cue (e.g. 20 will get data 20s both before and after the cue) %TODO: use cue length to taper window cueLength/fs+10; %20;        
periCueFrames = periCueTime*fs; %translate this time in seconds to a number of 'frames' or datapoints  

slideTime = 400; %define time window before cue onset to get baseline mean/stdDev for calculating sliding z scores- 400 for 10s (remember 400/40hz ~10s)


%% TIMELOCK TO DS
for subj= 1:numel(subjects) %for each subject

    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct

    %In this section, go cue-by-cue examining how fluorescence intensity changes in response to cue onset (either DS or NS)
    %Use an event-triggered sort of approach viewing data before and after cue onset where time 0 = cue onset time
    %Also, a sliding z-score will be calculated for each timepoint like in (Richard et al., 2018)- using data comprising 10s prior to that timepoint as a baseline  
    
    disp(strcat('running DS-triggered analysis subject_',  subjects{subj}));

        
    for session = 1:numel(currentSubj) %for each training session this subject completed              
        clear cutTime  %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

        for cue=1:length(currentSubj(session).DS) %DS CUES %For each DS cue, conduct event-triggered analysis of data surrounding that cue's onset

            %each entry in DS is a timestamp of the DS onset 
            DSonset = find(cutTime==currentSubj(session).DSshifted(cue,1));

            %define the frames (datapoints) around each cue to analyze
            preEventTimeDS = DSonset-periCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTimeDS = DSonset+periCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTimeDS< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to beginning, continuing'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTimeDS> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to end, continuing'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %blueA
            baselineMeanblue=mean(currentSubj(session).reblue((DSonset-slideTime):DSonset)); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue=std(currentSubj(session).reblue((DSonset-slideTime):DSonset)); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple=mean(currentSubj(session).repurple((DSonset-slideTime):DSonset)); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple=std(currentSubj(session).repurple((DSonset-slideTime):DSonset)); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDS.DS(cue) = currentSubj(session).DS(cue); %this way only included cues are saved

            subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeDS:postEventTimeDS);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeDS:postEventTimeDS))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeDS:postEventTimeDS))- baselineMeanpurple))/(baselineStdpurple);

                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple, 3);
            
            %lets save the baseline mean and std used for z score calc- so
            %that we can use this same baseline for other analyses
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue)= baselineMeanblue;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue)= baselineStdblue;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue)= baselineMeanpurple;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue)= baselineStdpurple;

        end %end DS cue loop
   end %end session loop
end %end subject loop
        
%% TIMELOCK TO NS
    %Same approach as above, but for NS; done a bit differently because not every session will have the NS
        disp(strcat('running NS-triggered analysis subject_',  subjects{subj}));

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct

       clear cutTime  %this is cleared between sessions to prevent spillover
       
       cutTime= currentSubj(session).cutTime; %save this as an array, immensely speeds things up because we have to go through each timestamp to find the closest one to the cues

  
      NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

%       disp(strcat('running NS-triggered analysis subject ', num2str(subj), '/', num2str(numel(subjects)), ' session ', num2str(session), '/', num2str(numel(currentSubj))));

      if isnan(currentSubj(session).NS)  %If there's no NS present, save data as empty arrays
          
        subjDataAnalyzed.(subjects{subj})(session).periNS.NS = [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple=[]; 

        %get the mean response to the DS for this session
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean= [];
      else %if the NS is present on this session, do the analysis and save results

            for cue=1:length(currentSubj(session).NS) %NS CUES %For each NS cue, conduct event-triggered analysis of data surrounding that cue's onset
                
                NSonset = find(cutTime==currentSubj(session).NSshifted(cue,1)); %get the corresponding cutTime index of the NS timestamp


                %define the frames (datapoints) around each cue to analyze
                preEventTimeNS = NSonset-periCueFrames; %earliest timepoint to examine is the shifted NS onset time - the # of frames we defined as periCueFrames (now this is equivalent to 20s before the shifted cue onset)
                postEventTimeNS = NSonset+periCueFrames; %latest timepoint to examine is the shifted NS onset time + the # of frames we defined as periCueFrames (now this is equivalent to 20s after the shifted cue onset)

               if preEventTimeDS< 1 %If cue is too close to beginning, skip over it
                  disp(strcat('****NS cue ', num2str(cue), ' too close to beginning, continuing'));
                  NSskipped= NSskipped+1;%iterate the counter for skipped NS cues
                  continue%continue out of the loop and move onto the next NS cue
                end

               if postEventTimeNS> length(currentSubj(session).cutTime)-slideTime %if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                  disp(strcat('****NS cue ', num2str(cue), ' too close to end, continuing'));
                  NSskipped= NSskipped+1;  %iterate the counter for skipped NS cues
                  continue %continue out of the loop and move onto the next NS cue
               end

                % Calculate average baseline mean&stdDev 10s prior to DS for z-score
                %blueA
                baselineMeanblue=mean(currentSubj(session).reblue((NSonset-slideTime):NSonset)); %baseline mean blue 10s prior to DS onset for boxA
                baselineStdblue=std(currentSubj(session).reblue((NSonset-slideTime):NSonset)); %baseline stdDev blue 10s prior to DS onset for boxA
                %purpleA
                baselineMeanpurple=mean(currentSubj(session).repurple((NSonset-slideTime):NSonset)); %baseline mean purple 10s prior to DS onset for boxA
                baselineStdpurple=std(currentSubj(session).repurple((NSonset-slideTime):NSonset)); %baseline stdDev purple 10s prior to DS onset for boxA

                %save the data in the subjDataAnalyzed struct under the periNS field
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NS(cue)= currentSubj(session).NS(cue); %this way only analyzed cues are included
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeNS:postEventTimeNS);
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeNS:postEventTimeNS);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeNS:postEventTimeNS);
                    %z score calculation
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeNS:postEventTimeNS))-baselineMeanblue))/(baselineStdblue);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeNS:postEventTimeNS))- baselineMeanpurple))/(baselineStdpurple);

                    %get the mean response to the DS for this session
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue, 3);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple, 3);
                

                %lets save the baseline mean and std used for z score calc- so
                %that we can use this same baseline for other analyses
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue)= baselineMeanblue;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue)= baselineStdblue;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue)= baselineMeanpurple;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue)= baselineStdpurple;

             
            end % end NS cue loop
      end %end if NS ~nan conditional 
   end %end session loop
end %end subject loop

%% TIMELOCK TO FIRST PE AFTER DS (when sucrose should be dispensed)
%DS trials where animal was in port at cue onset are excluded

disp('conducting peri-DSpox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
               
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstPox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstPox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstPox = interp1(cutTime,cutTime, firstPox, 'nearest');

                %get the index of this timestamp in cutTime
                firstPoxind= find(cutTime==firstPox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstPoxind-periCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstPoxind+periCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstPoxdS ', num2str(cue), ' too close to beginning, continueing out'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****firstPoxDS cue ', num2str(cue), ' too close to end, continueing out'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSselected= DSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);

                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple, 3);
           end
       
       end %end DSselected loop
       
   end %end session loop
end %end subject loop


%% TIMELOCK TO FIRST PE AFTER NS (no sucrose)


disp('conducting peri-NSpox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

       if ~isempty(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS) %can only run for sessions that have NS data
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(NSselected)
            
           if isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch, but save empty arrays
               
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue(1:periCueFrames*2+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple(1:periCueFrames*2+1,1,cue)= nan;

                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue(1:periCueFrames*2+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple(1:periCueFrames*2+1,1,cue)= nan;
% 
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSselected= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple= [];
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblueMean = [];
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurpleMean = [];
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblueMean = [];
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurpleMean = [];

           else %if this is a selected NS
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstPox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstPox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstPox = interp1(cutTime,cutTime, firstPox, 'nearest');

                %get the index of this timestamp in cutTime
                firstPoxind= find(cutTime==firstPox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstPoxind-periCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstPoxind+periCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstPoxNS ', num2str(cue), ' too close to beginning, continueing out'));
                NSskipped= NSskipped+1;
            continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
            disp(strcat('****firstPoxDS cue ', num2str(cue), ' too close to end, continueing out'));
            NSskipped= NSskipped+1;  %iterate the counter for skipped DS cues
            continue %continue out of the loop and move onto the next DS cue
            end

              % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periNS field

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSselected= NSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);

                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple, 3);
           end
       
       end %end DSselected loop
       end %end NS conditional
   end %end session loop
end %end subject loop





subjectsAnalyzed = fieldnames(subjDataAnalyzed); %now, let's save an array containing all of the analyzed subject IDs (may be useful later if we decide to exclude subjects from analysis)
%% ~~~Heat plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% HEAT PLOT OF AVG RESPONSE TO CUE (by session)

%Here, we'll make a figure for each subject with 4 subplots based on avg daily 
%response to cue- Avg blue z score response to DS, Avg blue z score response 
%to NS, Avg purple z score response to DS, Avg purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots
%first, we need to collect the avg cue response from all sessions and reshape for plotting

for subj= 1:numel(subjectsAnalyzed) %for each subject analyzed
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    %DS - extract data for plots
    %avg cue response sorted by trial, timelocked to DS

    for session = 1:numel(currentSubj) %for each training session this subject completed
        if session ==1 %for the first session, get this sessions periDS blue z score response
                currentSubj(1).DSzblueSessionMean= currentSubj(session).periDS.DSzblueMean; 
                currentSubj(1).DSzpurpleSessionMean= currentSubj(session).periDS.DSzpurpleMean;
        else % add on periDS response for subsequent sessions
                currentSubj(1).DSzblueSessionMean= cat(2, currentSubj(1).DSzblueSessionMean, currentSubj(session).periDS.DSzblueMean);
                currentSubj(1).DSzpurpleSessionMean= cat(2, currentSubj(1).DSzpurpleSessionMean, currentSubj(session).periDS.DSzpurpleMean);
        end
    end %end session loop
    
    %Transpose for readability
    currentSubj(1).DSzblueSessionMean= currentSubj(1).DSzblueSessionMean';
    currentSubj(1).DSzpurpleSessionMean= currentSubj(1).DSzpurpleSessionMean';

    %get list of session days for heatplot y axis (transposed for readability)
    subjTrial= cat(2, currentSubj.trainDay).';

    %NS- extract data for plots
    %session axis (Y) is handled a bit differently because we only want to show sessions that have NS cues
    
    %photometry signals sorted by trial, timelocked to NS
    
    for session = 1:numel(currentSubj) %for each training session this subject completed
        if session ==1 %for the first session, get this sessions periDS blue z score response
            currentSubj(1).NSzblueSessionMean= currentSubj(session).periNS.NSzblueMean; 
            currentSubj(1).NSzpurpleSessionMean= currentSubj(session).periNS.NSzpurpleMean;
        else % add on periDS response for subsequent sessions
            currentSubj(1).NSzblueSessionMean= cat(2, currentSubj(1).NSzblueSessionMean, currentSubj(session).periNS.NSzblueMean);
            currentSubj(1).NSzpurpleSessionMean= cat(2, currentSubj(1).NSzpurpleSessionMean, currentSubj(session).periNS.NSzpurpleMean);
        end
    end %end session loop
    
    
    %Transpose for readability
    currentSubj(1).NSzblueSessionMean= currentSubj(1).NSzblueSessionMean';
    currentSubj(1).NSzpurpleSessionMean= currentSubj(1).NSzpurpleSessionMean';
   
    %get list of session days for heatplot y axis
    subjTrialNS=[]; %keep track of sessions that have valid NS trials
    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
        if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
             subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay);
        end
    end %end session loop
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
    
     %define DS color axes
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
        bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomMeanShared= bottomAllDS;
        topMeanShared= topAllDS;
    end
    
    
    %Heatplots!       
    %DS z plot
    figure(figureCount);
    hold on;
    subplot(2,2,1); %subplot for shared colorbar

    %plot blue DS

    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatDSzblueMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzblueSessionMean);
    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg blue z score response surrounding DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzpurpleSessionMean); 

    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg purple z score response surrounding DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
    

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving




    %     %NS z plot
    hold on;
    subplot(2,2,2); %subplot for shared colorbar

    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatNSzblueMean= imagesc(timeLock,subjTrialNS,currentSubj(1).NSzblueSessionMean);
    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), 'avg blue z score response to NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrialNS); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple NS (subplotted for shared colorbar)
    subplot(2,2,4);
    heatNSzpurpleMean= imagesc(timeLock,subjTrialNS,currentSubj(1).NSzpurpleSessionMean); 

    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), ' avg purple z score response to NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrialNS); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
    saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZSessionAvg','.fig')); %save the current figure in fig format
    figureCount=figureCount+1; %iterate the figure count


end %end subject loop

%% HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION- sorted by trial 

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS, blue z score response to NS, purple z score response to
%DS, purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        %collect all z score responses to every single DS across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
            currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
        else %add subsequent sessions using cat()
            currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
            currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 

        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
    
    figureCount= figureCount+1;
end %end subject loop


%% LATENCY SORTED HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION

%Same as before, but now sorted by PE latency

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

        %initialize arrays for convenience
        currentSubj(1).NSzblueAllTrials= [];
        currentSubj(1).NSzpurpleAllTrials= [];
        currentSubj(1).NSpeLatencyAllTrials= [];

    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        clear NSselected
        
        %We can only include trials that have a PE latency, so we need to
        %selectively extract these data first
        
            %get the DS cues
        DSselected= currentSubj(session).periDS.DS;  %this alone is working

        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        %lets convert this to an index of trials with a valid value 
        DSselected= find(~isnan(DSselected));
        
            %Repeat above for NS 
        if ~isempty(currentSubj(session).periNS.NS)
             NSselected= currentSubj(session).periNS.NS;  

            %First, let's exclude trials where animal was already in port
            %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
            %have a non-nan value and use these to exclude NS trials from this
            %analysis (we'll make them nan)

            NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

            %Then, let's exclude trials where animal didn't make a PE during
            %the cue epoch. To do so, get indices of empty cells in
            %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
            %happened during the cue epoch) and then use these to set that NS =
            %nan
            NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;

       
            %lets convert this to an index of trials with a valid value 
            NSselected= find(~isnan(NSselected));
        end %end NS conditional       
        
        %collect all z score responses to every single DS across all sessions
        %we'll use DSselected and NSselected as indices to pull only data
        %from trials with port entries
        if session==1 %for first session, initialize 
           currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
           currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
           currentSubj(1).DSpeLatencyAllTrials= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
         
           if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                currentSubj(1).NSpeLatencyAllTrials= currentSubj(session).behavior.NSpeLatency(NSselected); 
           else
               continue %continue if no NS data
           end
        else %add subsequent sessions using cat()
            currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSpeLatencyAllTrials = cat(2,currentSubj(1).DSpeLatencyAllTrials,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
        
            if ~isempty(currentSubj(session).periNS.NS)
                currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                currentSubj(1).NSpeLatencyAllTrials = cat(2,currentSubj(1).NSpeLatencyAllTrials,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
            else
                continue %continue if nos NS data
            end
        end
        
%         DSzzblueAllTrials(:,:,~DSselected) = nan;
        
        [~,DSsortInd] = sort(currentSubj(1).DSpeLatencyAllTrials);       
        
        [~,NSsortInd] = sort(currentSubj(1).NSpeLatencyAllTrials);
        
    end %end session loop
    
    %Sort all trials by PE latency
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials(:,DSsortInd);
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials(:,DSsortInd);
    currentSubj(1).NSzblueAllTrials = currentSubj(1).NSzblueAllTrials(:,NSsortInd);
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials(:,NSsortInd);

    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding DS trials with valid PE - sorted  by PE latency (Lo-Hi)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding DS trials with valid PE - sorted by PE latency (Lo-Hi) ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding NS trials with valid PE - sorted by PE latency (Lo-Hi) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding NS trials with valid PE - sorted by PE latency (Lo-Hi) ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
    end   
    
    figureCount= figureCount+1;
end %end subject loop

%% HEAT PLOT OF RESPONSE TO FIRST PE IN CUE EPOCH

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS firstPox, blue z score response to NS firstPox, purple z score response to
%DS firstPox, purple z score response to NS firstPox.

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        %collect all z score responses to every single DSfirstPox across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSzpoxblueAllTrials= squeeze(currentSubj(session).periDSpox.DSzpoxblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSzpoxpurpleAllTrials= squeeze(currentSubj(session).periDSpox.DSzpoxpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSzpoxblueAllTrials= squeeze(currentSubj(session).periNSpox.NSzpoxblue); 
            currentSubj(1).NSzpoxpurpleAllTrials= squeeze(currentSubj(session).periNSpox.NSzpoxpurple);
        else %add subsequent sessions using cat()
            currentSubj(1).DSzpoxblueAllTrials = cat(2, currentSubj.DSzpoxblueAllTrials, (squeeze(currentSubj(session).periDSpox.DSzpoxblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpoxpurpleAllTrials = cat(2, currentSubj.DSzpoxpurpleAllTrials, (squeeze(currentSubj(session).periDSpox.DSzpoxpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSzpoxblueAllTrials = cat(2, currentSubj.NSzpoxblueAllTrials, (squeeze(currentSubj(session).periNSpox.NSzpoxblue))); 
            currentSubj(1).NSzpoxpurpleAllTrials = cat(2, currentSubj.NSzpoxpurpleAllTrials, (squeeze(currentSubj(session).periNSpox.NSzpoxpurple))); 
        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzpoxblueAllTrials= currentSubj(1).DSzpoxblueAllTrials';
    currentSubj(1).DSzpoxpurpleAllTrials= currentSubj(1).DSzpoxpurpleAllTrials';    
    currentSubj(1).NSzpoxblueAllTrials= currentSubj(1).NSzpoxblueAllTrials';
    currentSubj(1).NSzpoxpurpleAllTrials= currentSubj(1).NSzpoxpurpleAllTrials';
      
    
    %remove nan trials (NSzpox arrays retain nan values bc of the 3d structure)
    currentSubj(1).NSzpoxblueAllTrials= currentSubj(1).NSzpoxblueAllTrials(all(~isnan(currentSubj(1).NSzpoxblueAllTrials),2),:); 
    currentSubj(1).NSzpoxpurpleAllTrials= currentSubj(1).NSzpoxblueAllTrials(all(~isnan(currentSubj(1).NSzpoxblueAllTrials),2),:); 

    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzpoxblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzpoxblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpoxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpoxpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpoxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzpoxblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpoxpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzpoxblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpoxblueAllTrials);
    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE in DS epoch')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from PE');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding DS');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpoxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpoxpurpleAllTrials); 

    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first PE in DS epoch')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from PE');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding DS');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzpoxblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpoxblueAllTrials);
        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE in NS epoch ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding NS');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpoxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpoxpurpleAllTrials); 

        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first PE in NS epoch ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from PE ');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding NS');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_perifirstPoxZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
    
    figureCount= figureCount+1;
end %end subject loop

%% ~~~Behavioral plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% PLOT PORT ENTRY COUNT ACROSS DAYS FOR ALL SUBJECTS - not very meaningful,  but good template for DS PE ratio or latency

%In this section, we'll loop through our subjData struct, extracting a port entry
%count for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting port entry counts')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        poxCount(session)= numel(currentSubj(session).pox); %get the total number of port entries across days
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with poxCount
   end
   hold on;
   plot(days, poxCount)
end

title(strcat(currentSubj(session).experiment,' port entry count across days'));
xlabel('training day');
ylabel('port entry count');
legend(subjects); %add rats to legend

%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'port_entries_by_session','.fig'));
%         close; %close 

%% PLOT AVERAGE PORT ENTRY COUNT BETWEEN DAYS FOR ALL ANIMALS

%In this section, we'll loop through our subjData struct to get a port
%entry count for each session. Then, we'll calculate an avg port entry
%count for each subject across sessions, along with an SEM for each subject
%with n= number of sessions. This information will be used to make a
%scatter plot of individual port entry counts by day, along with the mean +/- SEM.

clear poxCount; %used the same variable name as previous section, so clear it

disp('plotting avg port entry counts by animal');

%get the figure ready before starting subj loop
figure(figureCount) %one figure with avg poxCount for all subjects
figureCount= figureCount+1;
title(strcat(currentSubj(session).experiment,'avg port entry count by subject +/- SEM'));
xlabel('subject');
ylabel(' port entry count');

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       
       %Get number of port entries for all sessions
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       poxCount{1,subj}(session,1)= numel(currentSubj(session).pox);%get the total number of port entries across days %use a cell array in case # of sessions differs between subjects
       
       subjectLabel{1,subj}(session,1)= currentSubj(session).rat; %label each data point with a subject ID %use a cell array in case subjects have different # of sessions
       
   end %end session loop
   
   %Get the mean and SEM for each subject
   poxCountMean(1, subj)= mean(poxCount{1,subj}(:,1)); %calculate avg poxCount across sessions for each subject
   poxCountSEM(1,subj)= std(poxCount{1,subj}(:,1))/sqrt(numel(currentSubj)); %calculate SEM for each subject: standard deviation of number of port entries across sessions / number of sessions for this subject


   %now plot the data
   hold on;
   
   scatter(subjectLabel{1,subj}, poxCount{1,subj}(:,:)); %scatter daily port entry counts by subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj), poxCountMean(1,subj)], 'k'); %overlay mean of each subject
     
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)-poxCountSEM(1,subj), poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--');%overlay - sem of each subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)+poxCountSEM(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--');%overlay + sem of each subject
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [poxCountMean(1,subj),poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--'); %connect -SEM to mean
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [ poxCountMean(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--'); %connect +SEM to mean
end

%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'average_port_entries_by_subject','.fig'));
%         close; %close 



%% ~~~Power analysis~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Try to estimate effect size. Effect we're looking at is the difference in
%z score 465nm(blue) response to DS cue vs. NS cue over some period of time. 
%In order to do so, we need to get an avg response to each cue across all subjects. Then, we'll 
%get an avg std of the response and use this to calculate pooledStd
%across subjects

%Need to define a timescale within which to look for cue-related effect
%Here, we will use a 1s time window after cue onset
cueOnsetTime= (periCueTime*fs); %this is the index of the cue onset time from the peri-cue analyses
effectDuration= 1; % Define a time window of interest after cue onset within which we will look for an effect
effectWindow= cueOnsetTime+1:cueOnsetTime+(effectDuration*fs); %Indices of the time window for the effect

%Because 405nm and 465nm signals are inversely related, looking for an
%effect between these signals doesn't seem appropriate. We could look for
%a difference between response to DS vs. response to NS. We could also look
%for a difference between cue-related response and 'spontaneous'
%activity during ITI. I think there must be some normalized metric between
%subjects to estimate an effect size (e.g. z score)
for subj= 1:numel(subjectsAnalyzed) %for each subject
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
   disp(strcat('working on effect size estimate for subj', num2str(subj), ' / ', num2str(numel(subjectsAnalyzed))));
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       %raw blue and purple signals don't mean much as their value is arbitrary, can't really compare the two directly 
       %instead, need to look at change in signal over time
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue= currentSubj(session).DSblue(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple= currentSubj(session).DSpurple(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurpleMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
       %Z score is a normalized metric which seems appropriate for analyzing this
       %type of data. While z score already incorporates within-subject std
       %into its calculation, we will use a pooledStd to incorporate
       %between-subject std.
       
       %get the z score values during the 'effect' time window
       %for now, interested in blue signal
       
       %Extract the blue z score response to cue in a specific time window of interest
       %for all DS cues (and then the avg response to all cues)...
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblue= currentSubj(session).periDS.DSzblue(effectWindow, 1, :);
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
       %then calculate the std of this response to cues (and then the avg std of response to all cues)
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periDS.DSzblue(effectWindow,1,:)); %this gives us std of response to each cue
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueAvgStd= mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueStd); %this gives us the avg std of response to each cue
       
       %repeat above but for response to NS cue
       if isempty(currentSubj(session).periNS.NSzblue) %if there's no valid NS, there's no effect to look for
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean= [];
           
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd= [];
       else %if an NS is present, extract cue-related activity in the 'effect' time window
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue= currentSubj(session).periNS.NSzblue(effectWindow,1,:);
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue,3));
       
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periNS.NSzblue(effectWindow,1,:)); %this gives us std of response to each cue
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd= mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd); %this gives us the avg std of response to each cue
       end
              
   end %end session loop
   
  %get a grand mean of 'effect' (here the z score in the blue channel) across all cues and all sessions for each subject
  grandMeanEffectDSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueMean));  
  grandMeanEffectNSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean));
   
  %get a grand avg std of the z score for each subject
  grandStdDSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueAvgStd));  
  grandStdNSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd));  

end %end subject loop

  %now avg everything across subjects; use nanmean since some NS dat   a may be nan
  grandMeanEffectDSzblueAllSubjects= nanmean(grandMeanEffectDSzblue); %avg response to DS
  grandMeanEffectNSzblueAllSubjects= nanmean(grandMeanEffectNSzblue); %avg response to NS

  grandStdDSzblueAllSubjects= nanmean(grandStdDSzblue); %avg std in response to DS
  grandStdNSzblueAllSubjects= nanmean(grandStdNSzblue); %avg std in response to NS
  
  
  %now, calculate a pooledStd between the DS and NS
  pooledStdAllSubjects= sqrt(((grandStdDSzblueAllSubjects^2)+(grandStdNSzblueAllSubjects^2))/2); 

 %now, estimate Cohen's D (mean1-mean2)/pooledStd
 
 cohensDzBlue= abs((grandMeanEffectDSzblueAllSubjects-grandMeanEffectNSzblueAllSubjects)/pooledStdAllSubjects)
 %May need to refine the time period over which to look for an effect (1s seems too broad, 
 %heatplots show response only ~500ms after cue). Could also look for a max
 %response and then use those instead of getting an avg response.
 
 %just for fun, what n would we need for .80 power given this effect size?
 nCuePresentationsNeeded = sampsizepwr('t',[grandMeanEffectDSzblueAllSubjects, pooledStdAllSubjects], grandMeanEffectNSzblueAllSubjects, .80,[])
  
 %VPFP-quantneuro: that's a lot of trials... 1398/30 per day ~ 47 days of training

 
 %lets save this too
for subj= 1:numel(subjectsAnalyzed) %for each subject
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.cohensDzBlue= cohensDzBlue;
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.nCuePresentationsNeeded= nCuePresentationsNeeded;
end %end subject loop


%% ~~~Inferential stats~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% I think the data here will be parametric - at least in latter stages of
% training, there seem to be consistent cue responses 

% Since I'd like to see how the neural cue response changes with training, I would like to
% use n-way ANOVA to look at the main effect of cue, the main effect of session,
% and any interaction

%% ANOVA blueZ
% Trying to do N-way anova of blue z score response to DS vs. NS
% in a predefined time window of interest following the cue
%The time window is the same as in the power analysis above, and we'll pull
%from calculations made in the power analysis to get the avg. response to
%both cues
% For now, factors of interest: Cue, Subject, and Session (time)... and
% interactions

anovanSessionCount =1; %initialize an iterator for indexing

%Let's get our data into the right shape
%for simplicity, we'll loop through the data twice to get DS and NS data
for subj= 1:numel(subjectsAnalyzed) %for each subject
    
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
    for session = 1:numel(currentSubj) %for each training session this subject completed

        %in order to make a comparison, we still need to select data only
        %from sessions that have both the DS and NS
        
        if ~isempty(currentSubj(session).effectSize.effectWindowNSzblueMean)
            anovanMeanZblue(anovanSessionCount,1)= currentSubj(session).effectSize.effectWindowDSzblueMean; %get mean blue z score response to DS
            anovanSessionLabel(anovanSessionCount,1)= currentSubj(session).trainDay;
            anovanSubjLabel(anovanSessionCount,1)= currentSubj(session).rat;
            anovanCueLabel(anovanSessionCount,1)= 1; %1 for DS

            anovanSessionCount= anovanSessionCount+1; %iterate the session count
        end
    end %end session loop  
end %end subject loop

%for simplicity, let's loop again through subjs/sessions for the NS data
for subj= 1:numel(subjectsAnalyzed)
    
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj});
    
    for session= 1:numel(currentSubj)
        if ~isempty(currentSubj(session).effectSize.effectWindowNSzblueMean) %only assign NS data if it's present
            anovanMeanZblue(anovanSessionCount,1)= currentSubj(session).effectSize.effectWindowNSzblueMean; %get mean blue z score response to NS
            anovanSessionLabel(anovanSessionCount,1)= currentSubj(session).trainDay;
            anovanSubjLabel(anovanSessionCount,1)= currentSubj(session).rat;
            anovanCueLabel(anovanSessionCount,1)= 2; %2 for NS
            
            anovanSessionCount= anovanSessionCount+1; %iterate the session count
        end        
    end %end session loop
end %end subject loop

%example 3 way anova
% y = [52.7 57.5 45.9 44.5 53.0 57.0 45.9 44.0]'; %raw data
% g1 = [1 2 1 2 1 2 1 2]; %label 1
% g2 = {'hi';'hi';'lo';'lo';'hi';'hi';'lo';'lo'}; %label 2
% g3 = {'may';'may';'may';'may';'june';'june';'june';'june'}; %label 3
% p = anovan(y,{g1,g2,g3})

[anovanP, anovanTbl, anovanStats]= anovan(anovanMeanZblue,{anovanCueLabel,anovanSubjLabel,anovanSessionLabel}, 'model', 'interaction', 'varnames', {'cue', 'subject', 'session'});


% disp(anovanTbl);

%% ~~~Artifact identification/elimination~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Maybe we should just exclude extreme trials/ trials where artifacts are present
%Trying to visualize outliers here first
    
%% Histograms of individual trial z score response
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     
%     %histogram plot of the blue z score response to DS, #bins = # cue presentations
%     figure;
%     subplot(2,1,1);
%     histogram(currentSubj(1).periDS.DSzblueAllTrials, currentSubj(1).periDS.totalDScount(end), 'facecolor', 'b');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     %hist the purple z score response to DS #bins = # cue presentations
%     subplot(2,1,2)
%     histogram(currentSubj(1).periDS.DSzpurpleAllTrials, currentSubj(1).periDS.totalDScount(end) , 'facecolor', 'm');
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     
% end

% % % HISTOGRAM OF RESPONSE OVER TIME
% % march through timestamps on button press
% % for subj= 1:numel(subjectsAnalyzed) %for each subject
% %     
% %     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
% %     
% %     timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% %     
% %     histogram plot of the blue z score response to DS
% %     figure(figureCount);
% %     figureCount= figureCount+1;
% %     disp('***displaying histograms of z score response to cue thru time');
% %     for timestamp= 1:numel(timeStep)
% %             subplot(2,1,1);
% %             histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %         
% %             hist the purple z score response to DS 
% %             subplot(2,1,2)
% %             histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %             pause(0.008); %this will automatically iterate (seconds); to wait for user input use pause()
% %     end
% %     close;
% % end

%% Looping histogram of z score DS response over time
% %TODO: save to movie
% timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% 
% figure(figureCount);
% figureCount=figureCount+1;
% hold on;
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
% histTitle= sgtitle(strcat('z score in response to DS at T= ')); %add big title above all subplots
% 
% 
% % while 1 %infinite loop while true
%     disp('***displaying histograms of z score response to cue thru time, press key to stop');
%     
%     %loop through all timestamps, for each timestamp loop through subjects
%     %and plot the peri-cue z score values first in the blue channel then in
%     %the purple channel (looped twice in order to organize subplots so that
%     %blue is on top of purple for each subject)
%     
%     for timestamp= 1:numel(timeStep)
%         subplotCount= 1; %reset all the subplots between timestamps
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);   
%                 subplotCount=subplotCount+1;
%                 
%                 histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z'));
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% 
%         end
%         
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 %hist the purple z score response to DS #bins = # cue presentations
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);
%                 subplotCount=subplotCount+1;
%                 histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z'));
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%         end
%         
%         pause(0.005); %this will automatically iterate (seconds); to wait for user input use pause()
% 
%     end
% % end
% 
% close;
    
%% Artifact elimination
% 
% %Artifacts should be considered fast deflections in both shannels in the same
% %direction, or we could just use the 405nm to keep it simple
% 
% %define a threshold criteria for the isosbestic channel based on std,
% %and discard frames where the isosbestic signal deviates above this threshold
% 
% %keep in mind that 405nm signal could vary with ca++ events
% 
% %this strategy seeems imperfect- good datapoints may be removed due to
% %bleaching and it doesn't capture all artifacts... instead of looking
% %at global std, need to do some kind of sliding calculation to look at
% %local std
%     
% for subj= 1:numel(subjects)
%     
%     currentSubj= subjData.(subjects{subj});
%     
%     disp(strcat('artifact elimination_', subjects{subj}));
%     
%     
%     figure(figureCount);
%     figureCount=figureCount+1;
%     sgtitle(strcat('Rat #',num2str(currentSubj(1).rat), 'artifact detection'));
%     
%     subplotCount=1;
% 
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%        artifactThreshold = std(currentSubj(session).repurple)*2;
%        
%        subjDataAnalyzed.(subjects{subj})(session).photometrySignals.artifactThreshold= artifactThreshold; %save this value
%       
%     for timestamp= 1:numel(currentSubj(session).repurple)
%         if timestamp== 1
%             currentSubj(session).dPurple(timestamp)= 0; %no change possible on the first timestamp
%         else
%             currentSubj(session).dPurple(timestamp) = currentSubj(session).repurple(timestamp)-currentSubj(session).repurple(timestamp-1);
%         end  
%     end
%     
%     dPurple= currentSubj(session).dPurple;
%     
%     %let's define a threshold beyond which we want to exclude data (noise)
%     dThreshold = std(currentSubj(session).dPurple)*8;
%     dMean= mean(currentSubj(session).dPurple);
%     
%     %identify points that exceed this threshold
%     dArtifactIndex= find(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     dArtifactsVals= dPurple(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     subplot(numel(currentSubj),3,subplotCount);
%     subplotCount=subplotCount+1;
%     hold on;
%     plot(currentSubj(session).dPurple, 'm');
%     
%     title('dPurple');
%     %overlay threshold
%     plot([1,numel(currentSubj(session).dPurple)], [dMean - dThreshold, dMean - dThreshold], 'k--');
%     plot([1,numel(currentSubj(session).dPurple)], [dMean + dThreshold, dMean + dThreshold], 'k--');
%     %overlay points beyond threshold
%     scatter(dArtifactIndex, dArtifactsVals, 'rx')
%    
%     
%     % let's put these excluded timestamps over the raw purple trace to compare
%     
%        subplot(numel(currentSubj), 3, subplotCount);
%        subplotCount= subplotCount+1;
%        hold on;
%        plot(currentSubj(session).repurple, 'm'); %plot 405 signal
%        title('repurple, artifact timestamps calculated based on dPurple');
%        
%        %overlay + and - the threshold relative to the mean 405 signal
%        plot([1,numel(currentSubj(session).repurple)], [mean(currentSubj(session).repurple) + artifactThreshold, mean(currentSubj(session).repurple) + artifactThreshold], 'k--')
%        plot([1,numel(currentSubj(session).repurple)], [mean(currentSubj(session).repurple) - artifactThreshold, mean(currentSubj(session).repurple) - artifactThreshold], 'k--')
% 
%        scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+mean(currentSubj(session).repurple), 'rx'); 
%     
%        %plot blue too
%        plot(currentSubj(session).reblue);
%     
% 
%     
% 
%     %conservative threshold works well here- just looking for extreme
%     %artifacts- big, abrupt changes
%     
%     %seems to work for most trials, but @ threshold = 10 std trhis misses a pretty big case for
%     %VP-VTA-FP rat 9 trial 32
%     
%     %TODO: this is calculating dF timestamp by timestamp, but maybe we want to reject
%     %rapid increases over a specific time period or do some kind of sliding
%     %calculation
% 
%     %Let's actually remove the artifacts now
%     
%     cutTime= currentSubj(session).cutTime;
%     
%     %get the actual timestamp values to be excluded from cutTime
%     excludedTimestamps = cutTime(dArtifactIndex);
%         
%     %extract all timestmap values from cutTime that aren't equal to these
%     %excluded timestamps
%     
%     %make these excluded timestamps NaN
%     cutTime(dArtifactIndex)= NaN;
%     %extract timestamps that aren't NaN
%     timeNoArtifact= cutTime(~isnan(cutTime));
%     
% %     disp(strcat('excluded_', num2str(numel(excludedTimestamps)), ' timestamps w/ artifacts '));
%     
%     %now use the same strategy to extract photometry signals
%     reblueNoArtifact= currentSubj(session).reblue(~isnan(cutTime));
%     repurpleNoArtifact= currentSubj(session).repurple(~isnan(cutTime));
%     
%     
%    subplot(numel(currentSubj), 3, subplotCount);
%    subplotCount= subplotCount+1;
%    hold on;
%    plot(repurpleNoArtifact, 'm'); %plot 405 signal
%    title('artifacts removed- this method isnt working');
% 
%    scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+mean(currentSubj(session).repurple), 'rx'); 
% 
%    %plot blue too
%    plot(reblueNoArtifact, 'b');
% 
%    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%    
%    %this method doesn't seem to work well enough- but at least we have
%    %decent timestamps of artifacts... we maybe we can use this to exclude TRIALS
%    %instead of trying to remove the artifacts themselves?
%    
%    %maybe it would be best to just exlucde trials with huge z scores
%    
%    %Maybe instead of excluding trials, change the baseline z score calc in
%    %some way (exclude timestamps?)
%    
%    %save the artifact indices for each session
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.dArtifactTimes= excludedTimestamps; %this is a list of the excluded timestamps
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.cutTimeNoArtifacts= cutTime; %this is a time axis where timestamps with artifacts= NaN
% 
%    end %end session loop
%    
%     %save figure
% %    saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_ArtifactID','.tiff')); %save the current figure in fig format
% 
% end %end subj loop
   
%% HEAT PLOT WITH ARTIFACT TRIALS EXCLUDED
% 
% %Now that we have timestamps of 'artifacts', check if the peri-event window
% %includes an artifact. If so, exclude this trial.
% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
% currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     for session = 1:numel(currentSubj) %for each training session this subject completed
% 
%         %go through each session and check to see if periDS window contains an
%         %excluded timestamp (due to artifact being detected)
%         DSincluded = size(currentSubj(session).periDS.periDSwindow,3);
% 
%         DSexcluded= []; %keep track of which cues were excluded for this session
% 
%             for cue = 1:DSincluded
%                 preEventTimeDS= currentSubj(session).periDS.periDSwindow(:,1,cue);
%                 postEventTimeDS= currentSubj(session).periDS.periDSwindow(:,end,cue);
% 
%                 for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                     %if artifact occurs between preEventTime and postEventTime
%                     if artifact>preEventTimeDS && artifact<postEventTimeDS
%                         disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding DS_', num2str(cue), ' from heat plot'))
%                         DSexcluded= [DSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                         continue; %if this cue has an artifact, we don't need to keep checking anymore
%                     end
%                 end
%             end
% 
%             currentSubj(session).periDS.DSexcludedArtifact= DSexcluded; %save list of excluded cues for each session
% 
%             %now that we have excluded cues, let's go in and extract only data
%             %from included cues
% 
%             for excludedTrial = DSexcluded
%                 %make all the dat in excluded trials = nan
%                 currentSubj(session).periDS.DSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                 currentSubj(session).periDS.DSzpurple(:,:,excludedTrial)=nan; 
%             end
% 
% 
%       %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single DS)
%             if session==1
%                 currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%             else
%                 currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                 currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%             end
% 
%             %repeat above steps for NS
%             
%         if ~isempty(currentSubj(session).periNS.periNSwindow) %only run if there's NS data present
%             NSincluded = size(currentSubj(session).periNS.periNSwindow,3);
% 
%             NSexcluded= []; %keep track of which cues were excluded for this session
% 
%                 for cue = 1:NSincluded
%                     preEventTimeNS= currentSubj(session).periNS.periNSwindow(:,1,cue);
%                     postEventTimeNS= currentSubj(session).periNS.periNSwindow(:,end,cue);
% 
%                     for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                         %if artifact occurs between preEventTime and postEventTime
%                         if artifact>preEventTimeNS && artifact<postEventTimeNS
%                             disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding NS_', num2str(cue), ' from heat plot'))
%                             NSexcluded= [NSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                             continue; %if this cue has an artifact, we don't need to keep checking anymore
%                         end
%                     end
%                 end
% 
%                 currentSubj(session).periNS.NSexcludedArtifact= NSexcluded; %save list of excluded cues for each session
% 
%                 %now that we have excluded cues, let's go in and extract only data
%                 %from included cues
% 
%                 for excludedTrial = NSexcluded
%                     %make all the dat in excluded trials = nan
%                     currentSubj(session).periNS.NSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                     currentSubj(session).periNS.NSzpurple(:,:,excludedTrial)=nan; 
%                 end
% 
% 
%           %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single NS)
%                 if session==1
%                     currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                     currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 else
%                     currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                 end
%                  
%         else %if there's no NS data present
%             currentSubj(1).NSzblueAllTrials= [];
%             currentSubj(1).NSzpurpleAllTrials= [];    
%         end %end NS conditional
%         
%     end %end session loop
% 
%     %Transpose these data for readability
%     currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
%     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';
%    
%     if ~isempty(currentSubj(1).NSzblueAllTrials)
%         currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
%         currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
%     end
%      %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%      
%      %define DS color axes
%      
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 4;
%      
%      %need to use nanmean now bc we have nans on excluded trials
%      topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
%      topAllDS= max(topDSzblue, topDSzpurple);
%      
%         %same defining color axes for NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%         topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%         bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%         topAllNS= max(topNSzblue, topNSzpurple);
%     end
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%         bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
%         bottomAllShared= bottomAllDS;
%         topAllShared= topAllDS;
%     end
%            
%     
%     %get a trial count to use for the heatplot ytick
%     currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
%     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1); 
% 
%     %save for later 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
%     
%     %TODO: split up yticks by session (this would show any clear differences between days)
%     
%      %Heatplots!       
%     %DS z plot
%     figure(figureCount);
%     hold on;
%     subplot(2,2,1); %subplot for shared colorbar
% 
%     %plot blue DS
% 
%     timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
%     heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
%     title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
% 
%     %   plot purple DS (subplotted for shared colorbar)
%     subplot(2,2,3);
%     heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 
% 
%     title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% 
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
% 
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
%     
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%     saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials_ArtifactRemoved','.fig')); %save the current figure in fig format
% 
%       if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
%         
%         %plot blue NS
%         subplot(2,2,2); %subplot for shared colorbar
% 
%         heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
%         title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%         
%         
%            %   plot purple NS (subplotted for shared colorbar)
%         subplot(2,2,4);
%         heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 
% 
%         title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
% 
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
% 
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%         saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
%     end
%     
%     
%     
%     figureCount= figureCount+1;

% end%end subj loop

%% experimenting with nonlinear colormap

% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%   
% % First, Id pick an existing colormap, such as Parula. Specify the max and min values of your data (e.g. 34 and -350), and then select the value at which you would like more color variation (e.g. perhaps 34 or 0). You can play with the scaling intensity parameter to see what looks nice.
%   cMap = parula(256);
%   dataMax = topAllShared;
%   dataMin = bottomAllShared;
%   centerPoint = 1; %mean(mean(currentSubj(1).periDS.DSzpurpleAllTrials,1));
%   scalingIntensity = 1; %mean(std(currentSubj(1).periDS.DSzpurpleAllTrials));
% % Then perform some operations to create your colormap. I have done this by altering the indices x at which each existing color lives, and then interpolating to expand or shrink certain areas of the spectrum.
%   x = 1:length(cMap); 
%   x = x - (centerPoint-dataMin)*length(x)/(dataMax-dataMin);
%   x = scalingIntensity * x/max(abs(x));
% % Next, select some function or operations to transform the original linear indices into nonlinear. In the last line, I then use interp1 to create the new colormap from the original colormap and the transformed indices.
%   x = sign(x).* exp(abs(x));
%   x = x - min(x); x = x*511/max(x)+1; 
%   newMap = interp1(x, cMap, 1:512);
% % Then plot! 
% %   figure; imagesc(X);
% %   figure; imagesc(X); colormap(newMap);
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colorbar; title(strcat('auto colormap rat_ ', num2str(currentSubj(1).rat)));
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colormap(newMap); colorbar;
%   title(strcat('nonlinear colormap; center= ', num2str(centerPoint), '; scaling = ', num2str(scalingIntensity), '; rat_', num2str(currentSubj(1).rat)));
%  
%   
%     figureCount= figureCount+1;
% end %end subj loop


%% ~~~ End~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Save the analyzed data 
%save the subjDataAnalyzed struct for later analysis
save(strcat(experimentName,'-', date, 'subjDataAnalyzed'), 'subjDataAnalyzed'); %the second argument here is the variable being saved, the first is the filename

disp(strcat('all done, expect ', num2str(figureCount-1), ' figures'));
figureCount=1;


%%  Speed test /optimizing

profile viewer;
% %things that should be optimized:


%% Example structure of loop through subjects and sessions 
% for subj= 1:numel(subjects) %for each subject
%    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%    end %end session loop
% end %end subject loop


