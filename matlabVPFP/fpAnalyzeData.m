%fp data analysis 
%12/4/19
clear
clc
close all

% Make sure the figPath is correct!

figPath = 'C:\Users\Dakota\Desktop\testFigs\'; %location for output figures to be saved

% %% Load struct containing data organized by subject
disp('***select a .mat file generated by fpExtractData.m')

load(uigetfile('*.mat')); %choose the subjData file to open for your experiment %by default only show .mat files

profile on; %For optimization/tracking performance of the code- this starts the Matlab profiler

subjects= fieldnames(subjData); %access subjData struct with dynamic fieldnames; these are determined by fpExtractData and the metadata.xlsx

figureCount= 1 ; %keep track of figure # throughout to prevent overwriting

fs= 40; %This is important- if you change sampling frequency of photometry recordings for some reason, change this too! TODO: just save this in subjData as more metadata

%% ~~~Behavioral plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% PLOT PORT ENTRY COUNT ACROSS DAYS FOR ALL SUBJECTS - not very meaningful,  but good template for DS PE ratio or latency

%In this section, we'll loop through our subjData struct, extracting a port entry
%count for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting port entry counts')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
      
       %Plot number of port entries across all sessions
       
        poxCount(session)= numel(currentSubj(session).pox); %get the total number of port entries across days
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with poxCount
   end
   hold on;
   plot(days, poxCount)
end

title(strcat(currentSubj(session).experiment,' port entry count across days'));
xlabel('training day');
ylabel('port entry count');
legend(subjects); %add rats to legend

%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'port_entries_by_session','.fig'));
%         close; %close 

%% PLOT AVERAGE PORT ENTRY COUNT BETWEEN DAYS FOR ALL ANIMALS

%In this section, we'll loop through our subjData struct to get a port
%entry count for each session. Then, we'll calculate an avg port entry
%count for each subject across sessions, along with an SEM for each subject
%with n= number of sessions. This information will be used to make a
%scatter plot of individual port entry counts by day, along with the mean +/- SEM.

clear poxCount; %used the same variable name as previous section, so clear it

disp('plotting avg port entry counts by animal');

%get the figure ready before starting subj loop
figure(figureCount) %one figure with avg poxCount for all subjects
figureCount= figureCount+1;
title(strcat(currentSubj(session).experiment,'avg port entry count by subject +/- SEM'));
xlabel('subject');
ylabel(' port entry count');

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       
       %Get number of port entries for all sessions
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
       
       poxCount{1,subj}(session,1)= numel(currentSubj(session).pox);%get the total number of port entries across days %use a cell array in case # of sessions differs between subjects
       
       subjectLabel{1,subj}(session,1)= currentSubj(session).rat; %label each data point with a subject ID %use a cell array in case subjects have different # of sessions
       
   end %end session loop
   
   %Get the mean and SEM for each subject
   poxCountMean(1, subj)= mean(poxCount{1,subj}(:,1)); %calculate avg poxCount across sessions for each subject
   poxCountSEM(1,subj)= std(poxCount{1,subj}(:,1))/sqrt(numel(currentSubj)); %calculate SEM for each subject: standard deviation of number of port entries across sessions / number of sessions for this subject


   %now plot the data
   hold on;
   
   scatter(subjectLabel{1,subj}, poxCount{1,subj}(:,:)); %scatter daily port entry counts by subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj), poxCountMean(1,subj)], 'k'); %overlay mean of each subject
     
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)-poxCountSEM(1,subj), poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--');%overlay - sem of each subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)+poxCountSEM(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--');%overlay + sem of each subject
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [poxCountMean(1,subj),poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--'); %connect -SEM to mean
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [ poxCountMean(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--'); %connect +SEM to mean
end

%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'average_port_entries_by_subject','.fig'));
%         close; %close 


%% ~~~Photometry plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% Within-subjects raw photometry plots 
%In this section, we'll plot the "raw" (it's been preprocessed and
%downsampled) 405nm and 465nm photometry traces from each session. This makes 
%one figure per subject with all session traces subplotted so may be slow if you have a lot of sessions

for subj= 1:numel(subjects) %for each subject
    disp(strcat('plotting photometry data for_', subjects{subj}));
    
    figure(figureCount) %one figure per subject, with all sessions subplotted
    figureCount= figureCount+1;
    
   sgtitle(strcat(currentSubj(1).experiment, subjects{subj}, 'downsampled photometry traces')); %add big title above all subplots
    
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
      
       % Raw session plots- within subjects
        subplot(numel(subjData.(subjects{subj})),1,session); %one subplot per session
        hold on
        plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
        plot(currentSubj(session).cutTime, currentSubj(session).repurple,'m'); %plot 405nm trace
        title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
        xlabel('time (s)');
        ylabel('mV');
        legend('blue (465)',' purple (405)');
   end  
        %make figure full screen, save, and close this figure
        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%         saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'_downsampled_session_traces','.fig'));
%         close; %close 
end

%% Create subjDataAnalyzed struct to hold analyzed data
%In this section, we'll initialize a subjDataAnalyzed struct to hold any
%relevant analyzed data separately from raw data. We will populate it with
%some metadata before doing any analyses. This metadata all originates from
%the metadata.xlsx file and the subjData struct generated by
%fpExtractData.m

%Fill with metadata
 for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       experimentName= currentSubj(session).experiment; 
       
       subjDataAnalyzed.(subjects{subj})(session).experiment= currentSubj(session).experiment;
       subjDataAnalyzed.(subjects{subj})(session).rat= currentSubj(session).rat;
       subjDataAnalyzed.(subjects{subj})(session).fileName= currentSubj(session).fileName;
       subjDataAnalyzed.(subjects{subj})(session).trainDay= currentSubj(session).trainDay;
       subjDataAnalyzed.(subjects{subj})(session).trainStage= currentSubj(session).trainStage;
       subjDataAnalyzed.(subjects{subj})(session).box= currentSubj(session).box;       
   end %end session loop
end %end subject loop

%% ~~~Event-Triggered Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%In these sections, we will do an event-triggered analyses by extracting data 
%from the photometry traces immediately surrounding relevant behavioral events (e.g. cue onset, port entry, lick)
%To do so, we'll find the onset timestamp for each event (eventTime) and use this
%timestamp to extract photometry data surrounding it
%(preEventTime:postEventTime). This will be saved to the subjDataAnalyzed
%struct. 
%% TIMELOCK TO DS
for subj= 1:numel(subjects) %for each subject

    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct

    %In this section, go cue-by-cue examining how fluorescence intensity changes in response to cue onset (either DS or NS)
    %Use an event-triggered sort of approach viewing data before and after cue onset where time 0 = cue onset time
    %Also, a sliding z-score will be calculated for each timepoint like in (Richard et al., 2018)- using data comprising 10s prior to that timepoint as a baseline  

    %here we are establishing some variables for our event triggered-analysis
    periCueTime = 20;% t in seconds to examine before/after cue (e.g. 20 will get data 20s both before and after the cue) %TODO: use cue length to taper window cueLength/fs+10; %20;        
    periCueFrames = periCueTime*fs; %translate this time in seconds to a number of 'frames' or datapoints  

    slideTime = 400; %define time window before cue onset to get baseline mean/stdDev for calculating sliding z scores- 400 for 10s (remember 400/40hz ~10s)

    disp(strcat('running DS-triggered analysis subject_',  subjects{subj}));

        
    for session = 1:numel(currentSubj) %for each training session this subject completed              
        clear cutTime timeDiff %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

        for cue=1:length(currentSubj(session).DS) %DS CUES %For each DS cue, conduct event-triggered analysis of data surrounding that cue's onset

            %each entry in DS is a timestamp of the DS onset before downsampling- this needs to be aligned with our current time axis  
            DSonset = currentSubj(session).DS(cue,1); 

            %find closest value (min difference) in cutTime (the current time axis) to DSonset by subtraction
            for ts = 1:length(currentSubj(session).cutTime) %for each timestamp in cutTime 
                timeDiff(1,ts) = abs(DSonset-cutTime(ts)); %get the absolute difference between this cue's actual timestamp and each resampled timestamp- define this as timeDiff
            end

            [~,DSonsetShifted] = min(timeDiff); %Find the timestamp with the minimum difference- this is the index of the closest timestamp in cutTime to the actual DSonset- define this as DSonsetShifted

            %calculate the difference between the shifted onset time and the actual onset time (just for QA- we wouldn't want this to be too large)
            timeShift= currentSubj(session).cutTime(DSonsetShifted)-currentSubj(session).DS(cue,1);  
            if abs(timeShift) >0.2 %this will flag cues whose time shift deviates above a threshold (in seconds- 0.5s)
                disp(strcat('>>Error *big cue time shift cue# ', num2str(cue), 'shifted DS ', num2str(currentSubj(session).cutTime(DSonsetShifted)), ' - actual DS ', num2str(DS(cue,1)), ' = ', num2str(timeShift), '*'));
            end

            %define the frames (datapoints) around each cue to analyze
            preEventTimeDS = DSonsetShifted-periCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTimeDS = DSonsetShifted+periCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTimeDS< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to beginning, breaking out'));
                DSskipped= DSskipped+1;
            break
            end

            if postEventTimeDS> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
            disp(strcat('****DS cue ', num2str(cue), ' too close to end, breaking out'));
            DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
            break %break out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %blueA
            baselineMeanblue=mean(currentSubj(session).reblue((DSonsetShifted-slideTime):DSonsetShifted)); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue=std(currentSubj(session).reblue((DSonsetShifted-slideTime):DSonsetShifted)); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple=mean(currentSubj(session).repurple((DSonsetShifted-slideTime):DSonsetShifted)); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple=std(currentSubj(session).repurple((DSonsetShifted-slideTime):DSonsetShifted)); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDS.DS= currentSubj(session).DS;

            subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeDS:postEventTimeDS);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeDS:postEventTimeDS))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeDS:postEventTimeDS))- baselineMeanpurple))/(baselineStdpurple);

                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple, 3);

        end %end DS cue loop
   end %end session loop
end %end subject loop
        
%% TIMELOCK TO NS
    %Same approach as above, but for NS; done a bit differently because not every session will have the NS
        disp(strcat('running NS-triggered analysis subject_',  subjects{subj}));

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct

       clear cutTime timeDiff %this is cleared between sessions to prevent spillover
       
       cutTime= currentSubj(session).cutTime; %save this as an array, immensely speeds things up because we have to go through each timestamp to find the closest one to the cues

  
      NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

%       disp(strcat('running NS-triggered analysis subject ', num2str(subj), '/', num2str(numel(subjects)), ' session ', num2str(session), '/', num2str(numel(currentSubj))));

      if isnan(currentSubj(session).NS)  %If there's no NS present, save data as empty arrays
          
        subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple=[]; 

        %get the mean response to the DS for this session
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean= [];
      else %if the NS is present on this session, do the analysis and save results

            for cue=1:length(currentSubj(session).NS) %NS CUES %For each NS cue, conduct event-triggered analysis of data surrounding that cue's onset
                NSonset = currentSubj(session).NS(cue,1); %each entry in NS is a timestamp of the NS onset before downsampling- this needs to be aligned with our current time axis   

                %find closest value (min difference) in cutTime (the current time axis) to NSonset by subtraction
                for ts = 1:length(currentSubj(session).cutTime) %for each timestamp in cutTime 
                    timeDiff(1,ts) = abs(NSonset-cutTime(ts)); %get the absolute difference between this cue's actual timestamp and each resampled timestamp- define this as timeDiff
                end

                %Find the timestamp with the minimum difference- this is the index of the closest timestamp in cutTime to the actual NSonset- define this as NSonsetShifted
                [~,NSonsetShifted] = min(timeDiff); 

                %calculate the difference between the shifted onset time and the actual onset time (just for QA- we wouldn't want this to be too large)
                timeShift= currentSubj(session).cutTime(NSonsetShifted)-currentSubj(session).NS(cue,1);  
                if abs(timeShift) >0.2 %this will flag cues whose time shift deviates above a threshold (in seconds- 0.5s)
                    disp(strcat('>>Error *big cue time shift cue# ', num2str(cue), 'shifted NS ', num2str(currentSubj(session).cutTime(NSonsetShifted)), ' - actual DS ', num2str(NS(cue,1)), ' = ', num2str(timeShift), '*'));
                end

                %define the frames (datapoints) around each cue to analyze
                preEventTimeNS = NSonsetShifted-periCueFrames; %earliest timepoint to examine is the shifted NS onset time - the # of frames we defined as periCueFrames (now this is equivalent to 20s before the shifted cue onset)
                postEventTimeNS = NSonsetShifted+periCueFrames; %latest timepoint to examine is the shifted NS onset time + the # of frames we defined as periCueFrames (now this is equivalent to 20s after the shifted cue onset)

               if preEventTimeDS< 1 %If cue is too close to beginning, skip over it
                  disp(strcat('****NS cue ', num2str(cue), ' too close to beginning, breaking out'));
                  NSskipped= NSskipped+1;%iterate the counter for skipped NS cues
                  break%break out of the loop and move onto the next NS cue
                end

               if postEventTimeNS> length(currentSubj(session).cutTime)-slideTime %if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                  disp(strcat('****NS cue ', num2str(cue), ' too close to end, breaking out'));
                  NSskipped= NSskipped+1;  %iterate the counter for skipped NS cues
                  break %break out of the loop and move onto the next NS cue
               end

                % Calculate average baseline mean&stdDev 10s prior to DS for z-score
                %blueA
                baselineMeanblue=mean(currentSubj(session).reblue((NSonsetShifted-slideTime):NSonsetShifted)); %baseline mean blue 10s prior to DS onset for boxA
                baselineStdblue=std(currentSubj(session).reblue((NSonsetShifted-slideTime):NSonsetShifted)); %baseline stdDev blue 10s prior to DS onset for boxA
                %purpleA
                baselineMeanpurple=mean(currentSubj(session).repurple((NSonsetShifted-slideTime):NSonsetShifted)); %baseline mean purple 10s prior to DS onset for boxA
                baselineStdpurple=std(currentSubj(session).repurple((NSonsetShifted-slideTime):NSonsetShifted)); %baseline stdDev purple 10s prior to DS onset for boxA

                %save the data in the subjDataAnalyzed struct under the periNS field
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NS= currentSubj(session).NS;
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeNS:postEventTimeNS);
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeNS:postEventTimeNS);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeNS:postEventTimeNS);
                    %z score calculation
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeNS:postEventTimeNS))-baselineMeanblue))/(baselineStdblue);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeNS:postEventTimeNS))- baselineMeanpurple))/(baselineStdpurple);

                    %get the mean response to the DS for this session
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue, 3);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple, 3);
            end % end NS cue loop
      end %end if NS ~nan conditional 
   end %end session loop
end %end subject loop

subjectsAnalyzed = fieldnames(subjDataAnalyzed); %now, let's save an array containing all of the analyzed subject IDs (may be useful later if we decide to exclude subjects from analysis)
%% ~~~Heat plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% HEAT PLOT OF AVG RESPONSE TO CUE (by session)

%Here, we'll make a figure for each subject with 4 subplots based on avg daily 
%response to cue- Avg blue z score response to DS, Avg blue z score response 
%to NS, Avg purple z score response to DS, Avg purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots
%first, we need to collect the avg cue response from all sessions and reshape for plotting

for subj= 1:numel(subjectsAnalyzed) %for each subject analyzed
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

    %DS - extract data for plots
    %avg cue response sorted by trial, timelocked to DS

    for session = 1:numel(currentSubj) %for each training session this subject completed
        if session ==1 %for the first session, get this sessions periDS blue z score response
                currentSubj(1).DSzblueSessionMean= currentSubj(session).periDS.DSzblueMean; 
                currentSubj(1).DSzpurpleSessionMean= currentSubj(session).periDS.DSzpurpleMean;
        else % add on periDS response for subsequent sessions
                currentSubj(1).DSzblueSessionMean= cat(2, currentSubj(1).DSzblueSessionMean, currentSubj(session).periDS.DSzblueMean);
                currentSubj(1).DSzpurpleSessionMean= cat(2, currentSubj(1).DSzpurpleSessionMean, currentSubj(session).periDS.DSzpurpleMean);
        end
    end %end session loop
    
    %Transpose for readability
    currentSubj(1).DSzblueSessionMean= currentSubj(1).DSzblueSessionMean';
    currentSubj(1).DSzpurpleSessionMean= currentSubj(1).DSzpurpleSessionMean';

    %get list of session days for heatplot y axis (transposed for readability)
    subjTrial= cat(2, currentSubj.trainDay).';

    %NS- extract data for plots
    %session axis (Y) is handled a bit differently because we only want to show sessions that have NS cues
    
    %photometry signals sorted by trial, timelocked to NS
    
    for session = 1:numel(currentSubj) %for each training session this subject completed
        if session ==1 %for the first session, get this sessions periDS blue z score response
            currentSubj(1).NSzblueSessionMean= currentSubj(session).periNS.NSzblueMean; 
            currentSubj(1).NSzpurpleSessionMean= currentSubj(session).periNS.NSzpurpleMean;
        else % add on periDS response for subsequent sessions
            currentSubj(1).NSzblueSessionMean= cat(2, currentSubj(1).NSzblueSessionMean, currentSubj(session).periNS.NSzblueMean);
            currentSubj(1).NSzpurpleSessionMean= cat(2, currentSubj(1).NSzpurpleSessionMean, currentSubj(session).periNS.NSzpurpleMean);
        end
    end %end session loop
    
    
    %Transpose for readability
    currentSubj(1).NSzblueSessionMean= currentSubj(1).NSzblueSessionMean';
    currentSubj(1).NSzpurpleSessionMean= currentSubj(1).NSzpurpleSessionMean';
   
    %get list of session days for heatplot y axis
    subjTrialNS=[]; %keep track of sessions that have valid NS trials
    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
        if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
             subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay);
        end
    end %end session loop
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
    
     %define DS color axes
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
        bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomMeanShared= bottomAllDS;
        topMeanShared= topAllDS;
    end
    
    
    %Heatplots!       
    %DS z plot
    figure(figureCount);
    hold on;
    subplot(2,2,1); %subplot for shared colorbar

    %plot blue DS

    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatDSzblueMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzblueSessionMean);
    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg blue z score response surrounding DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzpurpleSessionMean); 

    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg purple z score response surrounding DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
    

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving




    %     %NS z plot
    hold on;
    subplot(2,2,2); %subplot for shared colorbar

    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatNSzblueMean= imagesc(timeLock,subjTrialNS,currentSubj(1).NSzblueSessionMean);
    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), 'avg blue z score response to NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrialNS); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple NS (subplotted for shared colorbar)
    subplot(2,2,4);
    heatNSzpurpleMean= imagesc(timeLock,subjTrialNS,currentSubj(1).NSzpurpleSessionMean); 

    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), ' avg purple z score response to NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrialNS); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
    saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZSessionAvg','.fig')); %save the current figure in fig format
    figureCount=figureCount+1; %iterate the figure count


end %end subject loop

%% HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS, blue z score response to NS, purple z score response to
%DS, purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        %collect all z score responses to every single DS across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
            currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
        else %add subsequent sessions using cat()
            currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
            currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 

        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))))
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
    
    figureCount= figureCount+1;
end %end subject loop

%% HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION- WITH SHARED COLORBAR ACROSS SUBJECTS
% %This probably isn't useful 
%
% for subj= 1:numel(subjectsAnalyzed) %for each subject
% currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%         
%         %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single DS)
%         if session==1
%             subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%             subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%         else
%             subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials = cat(2, subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%             subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials = cat(2, subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%         end
%         
%     end %end session loop
%     
%     %Transpose these data for readability
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials= subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials';
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials= subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials';
%     
%     %get bottom and top for color axis of DS heatplot
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllDS = min(min(min(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials)), min(min(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials))); %find the lowest value 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllDS = max(max(max(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials)), max(max(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzpurpleAllTrials))); %find the highest value
%     
%     
%     %get bottom and top for color axis of NS heatplot
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periNS.bottomAllNS= [];
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periNS.topAllNS= [];
%     
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periNS.bottomAllNS) %if there is an NS
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= min(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllDS, subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllNS); %find the absolute min value
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= max(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllDS, subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllNS); %find the absolute min value
%     else
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllDS;
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllDS;
%     end
%         
%     %This time, save the bottom & top for this subject in an array to compare between all subjects
%     bottomAllBetweenSubjects(1,subj)= subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared;
%     topAllBetweenSubjects(1,subj)= subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared;
% 
%     %get a trial count to use for the heatplot ytick
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= 1:size(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.DSzblueAllTrials,1); 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).perNS.totalNScount= 1:size(subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periNS.NSzblueAllTrials,1);
% 
%     
%     %TODO: split up yticks by session (this would show any clear differences between days)
%     
% end %end subj loop
% 
% %This time, find the min and max values between all subjects for
% %colormap before making heatplots for each subject
% 
% bottomAllBetweenSubjects= min(bottomAllBetweenSubjects);
% topAllBetweenSubjects= max(topAllBetweenSubjects);
% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     
%      %Heatplots!       
%     %DS z plot
%     figure(figureCount);
%     hold on;
%     subplot(2,2,1); %subplot for shared colorbar
% 
%     %plot blue DS
% 
%     timeLock = [-periDSFrames:periDSFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
%     heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzblueAllTrials);
%     title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS- colormap normalized between subjects ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), ')'));
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
%     caxis manual;
%     caxis([bottomAllBetweenSubjects topAllBetweenSubjects]); %use a shared color axis to encompass all values
% 
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
% 
%     %   plot purple DS (subplotted for shared colorbar)
%     subplot(2,2,3);
%     heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); 
% 
%     title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS- colormap normalized between subjects ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), ')'));
% 
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
% 
%     caxis manual;
%     caxis([bottomAllBetweenSubjects topAllBetweenSubjects]); %use a shared color axis to encompass all values
%     
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%     
%     
%     figureCount= figureCount+1;
% end %end subject loop

%% ~~~Power analysis~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Try to estimate effect size. Effect we're looking at is the difference in
%z score 465nm(blue) response to DS cue vs. NS cue over some period of time. 
%In order to do so, we need to get an avg response to each cue across all subjects. Then, we'll 
%get an avg std of the response and use this to calculate pooledStd
%across subjects

%Need to define a timescale within which to look for cue-related effect
%Here, we will use a 1s time window after cue onset
effectStartTime= ((periCueTime*fs)/2);
effectDuration= 1; %1s
effectWindow= effectStartTime+1:effectStartTime+(effectDuration*fs);


%Because 405nm and 465nm signals are inversely related, looking for an
%effect between these signals doesn't seem appropriate. We could look for
%a difference between response to DS vs. response to NS. We could also look
%for a difference between cue-related response and 'spontaneous'
%activity during ITI. I think there must be some normalized metric between
%subjects to estimate an effect size (e.g. z score)
for subj= 1:numel(subjectsAnalyzed) %for each subject
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
   disp(strcat('working on effect size estimate for subj', num2str(subj), ' / ', num2str(numel(subjectsAnalyzed))));
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       %raw blue and purple signals don't mean much as their value is arbitrary, can't really compare the two directly 
       %instead, need to look at change in signal over time
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue= currentSubj(session).DSblue(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple= currentSubj(session).DSpurple(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurpleMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
       %Z score is a normalized metric which seems appropriate for analyzing this
       %type of data. While z score already incorporates within-subject std
       %into its calculation, we will use a pooledStd to incorporate
       %between-subject std.
       
       %get the z score values during the 'effect' time window
       %for now, interested in blue signal
       
       %Extract the blue z score response to cue in a specific time window of interest
       %for all DS cues (and then the avg response to all cues)...
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblue= currentSubj(session).periDS.DSzblue(effectWindow, 1, :);
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
       %then calculate the std of this response to cues (and then the avg std of response to all cues)
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periDS.DSzblue(effectWindow,1,:)); %this gives us std of response to each cue
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblueAvgStd= mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblueStd); %this gives us the avg std of response to each cue
       
       %repeat above but for response to NS cue
       if isempty(currentSubj(session).periNS.NSzblue) %if there's no valid NS, there's no effect to look for
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblue= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueMean= [];
           
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueStd= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueAvgStd= [];
       else %if an NS is present, extract cue-related activity in the 'effect' time window
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblue= currentSubj(session).periNS.NSzblue(effectWindow,1,:);
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblue,3));
       
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periNS.NSzblue(effectWindow,1,:)); %this gives us std of response to each cue
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueAvgStd= mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueStd); %this gives us the avg std of response to each cue
       end
              
   end %end session loop
   
  %get a grand mean of 'effect' (here the z score in the blue channel) across all cues and all sessions for each subject
  grandMeanEffectDSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblueMean));  
  grandMeanEffectNSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueMean));
   
  %get a grand avg std of the z score for each subject
  grandStdDSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectDSzblueAvgStd));  
  grandStdNSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectNSzblueAvgStd));  

end %end subject loop

  %now avg everything across subjects; use nanmean since some NS data may be nan
  grandMeanEffectDSzblueAllSubjects= nanmean(grandMeanEffectDSzblue); %avg response to DS
  grandMeanEffectNSzblueAllSubjects= nanmean(grandMeanEffectNSzblue); %avg response to NS

  grandStdDSzblueAllSubjects= nanmean(grandStdDSzblue); %avg std in response to DS
  grandStdNSzblueAllSubjects= nanmean(grandStdNSzblue); %avg std in response to NS
  
  
  %now, calculate a pooledStd between the DS and NS
  pooledStdAllSubjects= sqrt(((grandStdDSzblueAllSubjects^2)+(grandStdNSzblueAllSubjects^2))/2); 

 %now, estimate Cohen's D (mean1-mean2)/pooledStd
 
 cohensDzBlue= abs((grandMeanEffectDSzblueAllSubjects-grandMeanEffectNSzblueAllSubjects)/pooledStdAllSubjects)
 %May need to refine the time period over which to look for an effect (1s seems too broad, 
 %heatplots show response only ~500ms after cue). Could also look for a max
 %response and then use those instead of getting an avg response.
 
 %just for fun, what n would we need for .80 power?
 nCuePresentationsNeeded = sampsizepwr('t',[grandMeanEffectDSzblueAllSubjects, pooledStdAllSubjects], grandMeanEffectNSzblueAllSubjects, .80,[])
  
 %VPFP-quantneuro: that's a lot of trials... 1398/30 per day ~ 47 days of training

 
 %lets save this too
for subj= 1:numel(subjectsAnalyzed) %for each subject
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.cohensDzBlue= cohensDzBlue;
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.nCuePresentationsNeeded= nCuePresentationsNeeded;
end %end subject loop


%% ~~~Inferential stats~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% I think the data here will be parametric - at least in latter stages of
% training, there seem to be consistent cue responses 

% Since I'd like to see how the neural cue response changes with training, I would like to
% use n-way ANOVA to look at the main effect of cue, the main effect of session,
% and any interaction

%% ~~~Artifact identification/elimination~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Maybe we should just exclude extreme trials/ trials where artifacts are present
%Trying to visualize outliers here first
    
%% Histograms of individual trial z score response
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     
%     %histogram plot of the blue z score response to DS, #bins = # cue presentations
%     figure;
%     subplot(2,1,1);
%     histogram(currentSubj(1).periDS.DSzblueAllTrials, currentSubj(1).periDS.totalDScount(end), 'facecolor', 'b');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     %hist the purple z score response to DS #bins = # cue presentations
%     subplot(2,1,2)
%     histogram(currentSubj(1).periDS.DSzpurpleAllTrials, currentSubj(1).periDS.totalDScount(end) , 'facecolor', 'm');
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     
% end

% % % HISTOGRAM OF RESPONSE OVER TIME
% % march through timestamps on button press
% % for subj= 1:numel(subjectsAnalyzed) %for each subject
% %     
% %     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
% %     
% %     timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% %     
% %     histogram plot of the blue z score response to DS
% %     figure(figureCount);
% %     figureCount= figureCount+1;
% %     disp('***displaying histograms of z score response to cue thru time');
% %     for timestamp= 1:numel(timeStep)
% %             subplot(2,1,1);
% %             histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %         
% %             hist the purple z score response to DS 
% %             subplot(2,1,2)
% %             histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %             pause(0.008); %this will automatically iterate (seconds); to wait for user input use pause()
% %     end
% %     close;
% % end

%% Looping histogram of z score DS response over time
% %TODO: save to movie
% timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% 
% figure(figureCount);
% figureCount=figureCount+1;
% hold on;
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
% histTitle= sgtitle(strcat('z score in response to DS at T= ')); %add big title above all subplots
% 
% 
% % while 1 %infinite loop while true
%     disp('***displaying histograms of z score response to cue thru time, press key to stop');
%     
%     %loop through all timestamps, for each timestamp loop through subjects
%     %and plot the peri-cue z score values first in the blue channel then in
%     %the purple channel (looped twice in order to organize subplots so that
%     %blue is on top of purple for each subject)
%     
%     for timestamp= 1:numel(timeStep)
%         subplotCount= 1; %reset all the subplots between timestamps
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);   
%                 subplotCount=subplotCount+1;
%                 
%                 histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z'));
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% 
%         end
%         
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 %hist the purple z score response to DS #bins = # cue presentations
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);
%                 subplotCount=subplotCount+1;
%                 histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z'));
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%         end
%         
%         pause(0.005); %this will automatically iterate (seconds); to wait for user input use pause()
% 
%     end
% % end
% 
% close;
    
%% Artifact elimination
% 
% %Artifacts should be considered fast deflections in both shannels in the same
% %direction, or we could just use the 405nm to keep it simple
% 
% %define a threshold criteria for the isosbestic channel based on std,
% %and discard frames where the isosbestic signal deviates above this threshold
% 
% %keep in mind that 405nm signal could vary with ca++ events
% 
% %this strategy seeems imperfect- good datapoints may be removed due to
% %bleaching and it doesn't capture all artifacts... instead of looking
% %at global std, need to do some kind of sliding calculation to look at
% %local std
%     
% for subj= 1:numel(subjects)
%     
%     currentSubj= subjData.(subjects{subj});
%     
%     disp(strcat('artifact elimination_', subjects{subj}));
%     
%     
%     figure(figureCount);
%     figureCount=figureCount+1;
%     sgtitle(strcat('Rat #',num2str(currentSubj(1).rat), 'artifact detection'));
%     
%     subplotCount=1;
% 
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%        artifactThreshold = std(currentSubj(session).repurple)*2;
%        
%        subjDataAnalyzed.(subjects{subj})(session).photometrySignals.artifactThreshold= artifactThreshold; %save this value
%       
%     for timestamp= 1:numel(currentSubj(session).repurple)
%         if timestamp== 1
%             currentSubj(session).dPurple(timestamp)= 0; %no change possible on the first timestamp
%         else
%             currentSubj(session).dPurple(timestamp) = currentSubj(session).repurple(timestamp)-currentSubj(session).repurple(timestamp-1);
%         end  
%     end
%     
%     dPurple= currentSubj(session).dPurple;
%     
%     %let's define a threshold beyond which we want to exclude data (noise)
%     dThreshold = std(currentSubj(session).dPurple)*8;
%     dMean= mean(currentSubj(session).dPurple);
%     
%     %identify points that exceed this threshold
%     dArtifactIndex= find(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     dArtifactsVals= dPurple(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     subplot(numel(currentSubj),3,subplotCount);
%     subplotCount=subplotCount+1;
%     hold on;
%     plot(currentSubj(session).dPurple, 'm');
%     
%     title('dPurple');
%     %overlay threshold
%     plot([1,numel(currentSubj(session).dPurple)], [dMean - dThreshold, dMean - dThreshold], 'k--');
%     plot([1,numel(currentSubj(session).dPurple)], [dMean + dThreshold, dMean + dThreshold], 'k--');
%     %overlay points beyond threshold
%     scatter(dArtifactIndex, dArtifactsVals, 'rx')
%    
%     
%     % let's put these excluded timestamps over the raw purple trace to compare
%     
%        subplot(numel(currentSubj), 3, subplotCount);
%        subplotCount= subplotCount+1;
%        hold on;
%        plot(currentSubj(session).repurple, 'm'); %plot 405 signal
%        title('repurple, artifact timestamps calculated based on dPurple');
%        
%        %overlay + and - the threshold relative to the mean 405 signal
%        plot([1,numel(currentSubj(session).repurple)], [mean(currentSubj(session).repurple) + artifactThreshold, mean(currentSubj(session).repurple) + artifactThreshold], 'k--')
%        plot([1,numel(currentSubj(session).repurple)], [mean(currentSubj(session).repurple) - artifactThreshold, mean(currentSubj(session).repurple) - artifactThreshold], 'k--')
% 
%        scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+mean(currentSubj(session).repurple), 'rx'); 
%     
%        %plot blue too
%        plot(currentSubj(session).reblue);
%     
% 
%     
% 
%     %conservative threshold works well here- just looking for extreme
%     %artifacts- big, abrupt changes
%     
%     %seems to work for most trials, but @ threshold = 10 std trhis misses a pretty big case for
%     %VP-VTA-FP rat 9 trial 32
%     
%     %TODO: this is calculating dF timestamp by timestamp, but maybe we want to reject
%     %rapid increases over a specific time period or do some kind of sliding
%     %calculation
% 
%     %Let's actually remove the artifacts now
%     
%     cutTime= currentSubj(session).cutTime;
%     
%     %get the actual timestamp values to be excluded from cutTime
%     excludedTimestamps = cutTime(dArtifactIndex);
%         
%     %extract all timestmap values from cutTime that aren't equal to these
%     %excluded timestamps
%     
%     %make these excluded timestamps NaN
%     cutTime(dArtifactIndex)= NaN;
%     %extract timestamps that aren't NaN
%     timeNoArtifact= cutTime(~isnan(cutTime));
%     
% %     disp(strcat('excluded_', num2str(numel(excludedTimestamps)), ' timestamps w/ artifacts '));
%     
%     %now use the same strategy to extract photometry signals
%     reblueNoArtifact= currentSubj(session).reblue(~isnan(cutTime));
%     repurpleNoArtifact= currentSubj(session).repurple(~isnan(cutTime));
%     
%     
%    subplot(numel(currentSubj), 3, subplotCount);
%    subplotCount= subplotCount+1;
%    hold on;
%    plot(repurpleNoArtifact, 'm'); %plot 405 signal
%    title('artifacts removed- this method isnt working');
% 
%    scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+mean(currentSubj(session).repurple), 'rx'); 
% 
%    %plot blue too
%    plot(reblueNoArtifact, 'b');
% 
%    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%    
%    %this method doesn't seem to work well enough- but at least we have
%    %decent timestamps of artifacts... we maybe we can use this to exclude TRIALS
%    %instead of trying to remove the artifacts themselves?
%    
%    %maybe it would be best to just exlucde trials with huge z scores
%    
%    %Maybe instead of excluding trials, change the baseline z score calc in
%    %some way (exclude timestamps?)
%    
%    %save the artifact indices for each session
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.dArtifactTimes= excludedTimestamps; %this is a list of the excluded timestamps
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.cutTimeNoArtifacts= cutTime; %this is a time axis where timestamps with artifacts= NaN
% 
%    end %end session loop
%    
%     %save figure
% %    saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_ArtifactID','.tiff')); %save the current figure in fig format
% 
% end %end subj loop
   
%% HEAT PLOT WITH ARTIFACT TRIALS EXCLUDED
% 
% %Now that we have timestamps of 'artifacts', check if the peri-event window
% %includes an artifact. If so, exclude this trial.
% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
% currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     for session = 1:numel(currentSubj) %for each training session this subject completed
% 
%         %go through each session and check to see if periDS window contains an
%         %excluded timestamp (due to artifact being detected)
%         DSincluded = size(currentSubj(session).periDS.periDSwindow,3);
% 
%         DSexcluded= []; %keep track of which cues were excluded for this session
% 
%             for cue = 1:DSincluded
%                 preEventTimeDS= currentSubj(session).periDS.periDSwindow(:,1,cue);
%                 postEventTimeDS= currentSubj(session).periDS.periDSwindow(:,end,cue);
% 
%                 for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                     %if artifact occurs between preEventTime and postEventTime
%                     if artifact>preEventTimeDS && artifact<postEventTimeDS
%                         disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding DS_', num2str(cue), ' from heat plot'))
%                         DSexcluded= [DSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                         break; %if this cue has an artifact, we don't need to keep checking anymore
%                     end
%                 end
%             end
% 
%             currentSubj(session).periDS.DSexcludedArtifact= DSexcluded; %save list of excluded cues for each session
% 
%             %now that we have excluded cues, let's go in and extract only data
%             %from included cues
% 
%             for excludedTrial = DSexcluded
%                 %make all the dat in excluded trials = nan
%                 currentSubj(session).periDS.DSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                 currentSubj(session).periDS.DSzpurple(:,:,excludedTrial)=nan; 
%             end
% 
% 
%       %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single DS)
%             if session==1
%                 currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%             else
%                 currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                 currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%             end
% 
%             %repeat above steps for NS
%             
%         if ~isempty(currentSubj(session).periNS.periNSwindow) %only run if there's NS data present
%             NSincluded = size(currentSubj(session).periNS.periNSwindow,3);
% 
%             NSexcluded= []; %keep track of which cues were excluded for this session
% 
%                 for cue = 1:NSincluded
%                     preEventTimeNS= currentSubj(session).periNS.periNSwindow(:,1,cue);
%                     postEventTimeNS= currentSubj(session).periNS.periNSwindow(:,end,cue);
% 
%                     for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                         %if artifact occurs between preEventTime and postEventTime
%                         if artifact>preEventTimeNS && artifact<postEventTimeNS
%                             disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding NS_', num2str(cue), ' from heat plot'))
%                             NSexcluded= [NSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                             break; %if this cue has an artifact, we don't need to keep checking anymore
%                         end
%                     end
%                 end
% 
%                 currentSubj(session).periNS.NSexcludedArtifact= NSexcluded; %save list of excluded cues for each session
% 
%                 %now that we have excluded cues, let's go in and extract only data
%                 %from included cues
% 
%                 for excludedTrial = NSexcluded
%                     %make all the dat in excluded trials = nan
%                     currentSubj(session).periNS.NSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                     currentSubj(session).periNS.NSzpurple(:,:,excludedTrial)=nan; 
%                 end
% 
% 
%           %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single NS)
%                 if session==1
%                     currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                     currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 else
%                     currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                 end
%                  
%         else %if there's no NS data present
%             currentSubj(1).NSzblueAllTrials= [];
%             currentSubj(1).NSzpurpleAllTrials= [];    
%         end %end NS conditional
%         
%     end %end session loop
% 
%     %Transpose these data for readability
%     currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
%     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';
%    
%     if ~isempty(currentSubj(1).NSzblueAllTrials)
%         currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
%         currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
%     end
%      %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%      
%      %define DS color axes
%      
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 4;
%      
%      %need to use nanmean now bc we have nans on excluded trials
%      topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
%      topAllDS= max(topDSzblue, topDSzpurple);
%      
%         %same defining color axes for NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%         topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%         bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%         topAllNS= max(topNSzblue, topNSzpurple);
%     end
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%         bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
%         bottomAllShared= bottomAllDS;
%         topAllShared= topAllDS;
%     end
%            
%     
%     %get a trial count to use for the heatplot ytick
%     currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
%     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1); 
% 
%     %save for later 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
%     
%     %TODO: split up yticks by session (this would show any clear differences between days)
%     
%      %Heatplots!       
%     %DS z plot
%     figure(figureCount);
%     hold on;
%     subplot(2,2,1); %subplot for shared colorbar
% 
%     %plot blue DS
% 
%     timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
%     heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
%     title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
% 
%     %   plot purple DS (subplotted for shared colorbar)
%     subplot(2,2,3);
%     heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 
% 
%     title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% 
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
% 
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
%     
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%     saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials_ArtifactRemoved','.fig')); %save the current figure in fig format
% 
%       if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
%         
%         %plot blue NS
%         subplot(2,2,2); %subplot for shared colorbar
% 
%         heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
%         title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%         
%         
%            %   plot purple NS (subplotted for shared colorbar)
%         subplot(2,2,4);
%         heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 
% 
%         title(strcat(currentSubj(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
% 
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
% 
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%         saveas(gcf, strcat(figPath, currentSubj(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
%     end
%     
%     
%     
%     figureCount= figureCount+1;

end%end subj loop

%% experimenting with nonlinear colormap

% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%   
% % First, Id pick an existing colormap, such as Parula. Specify the max and min values of your data (e.g. 34 and -350), and then select the value at which you would like more color variation (e.g. perhaps 34 or 0). You can play with the scaling intensity parameter to see what looks nice.
%   cMap = parula(256);
%   dataMax = topAllShared;
%   dataMin = bottomAllShared;
%   centerPoint = 1; %mean(mean(currentSubj(1).periDS.DSzpurpleAllTrials,1));
%   scalingIntensity = 1; %mean(std(currentSubj(1).periDS.DSzpurpleAllTrials));
% % Then perform some operations to create your colormap. I have done this by altering the indices x at which each existing color lives, and then interpolating to expand or shrink certain areas of the spectrum.
%   x = 1:length(cMap); 
%   x = x - (centerPoint-dataMin)*length(x)/(dataMax-dataMin);
%   x = scalingIntensity * x/max(abs(x));
% % Next, select some function or operations to transform the original linear indices into nonlinear. In the last line, I then use interp1 to create the new colormap from the original colormap and the transformed indices.
%   x = sign(x).* exp(abs(x));
%   x = x - min(x); x = x*511/max(x)+1; 
%   newMap = interp1(x, cMap, 1:512);
% % Then plot! 
% %   figure; imagesc(X);
% %   figure; imagesc(X); colormap(newMap);
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colorbar; title(strcat('auto colormap rat_ ', num2str(currentSubj(1).rat)));
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colormap(newMap); colorbar;
%   title(strcat('nonlinear colormap; center= ', num2str(centerPoint), '; scaling = ', num2str(scalingIntensity), '; rat_', num2str(currentSubj(1).rat)));
%  
%   
%     figureCount= figureCount+1;
% end %end subj loop


%% ~~~ End~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Save the analyzed data 
%save the subjDataAnalyzed struct for later analysis
save(strcat(experimentName,'-', date, 'subjDataAnalyzed'), 'subjDataAnalyzed'); %the second argument here is the variable being saved, the first is the filename

disp(strcat('all done, expect ', num2str(figureCount-1), ' figures'));
figureCount=1;


%%  Speed test /optimizing

profile viewer;
% %things that should be optimized:


%% Example structure of loop through subjects and sessions 
% for subj= 1:numel(subjects) %for each subject
%    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%    for session = 1:numel(currentSubj)) %for each training session this subject completed
%    end %end session loop
% end %end subject loop


