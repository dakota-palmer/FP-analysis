%fp data analysis 
%1/20/20
clear
clc
close all

% Make sure the figPath is correct!

figPath = 'C:\Users\capn1\Desktop\testFigs\'; %location for output figures to be saved

% %% Load struct containing data organized by subject
disp('***select a .mat file generated by fpExtractData.m')

load(uigetfile('*.mat')); %choose the subjData file to open for your experiment %by default only show .mat files

profile on; %For optimization/tracking performance of the code- this starts the Matlab profiler

subjects= fieldnames(subjData); %access subjData struct with dynamic fieldnames; these are determined by fpExtractData and the metadata.xlsx

figureCount= 1 ; %keep track of figure # throughout to prevent overwriting

fs= 40; %This is important- if you change sampling frequency of photometry recordings for some reason, change this too! TODO: just save this in subjData as more metadata

%% Remove excluded subjects

excludedSubjs= {'rat10'}; %cell array with strings of excluded subj fieldnames

subjData= rmfield(subjData,excludedSubjs);

subjects= fieldnames(subjData); %get an updated list of included subjs

subjIncluded= subjects;

%% ~~~Photometry plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% Within-subjects raw photometry plots - all in 1 figure
%In this section, we'll plot the "raw" (it's been preprocessed and
%downsampled) 405nm and 465nm photometry traces from each session. This makes 
%one figure per subject with all session traces subplotted so may be slow if you have a lot of sessions
%useful if you have a few sessions, but too unwieldy with >10sessions

% for subj= 1:numel(subjects) %for each subject
%     
%     currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%     
%     disp(strcat('plotting photometry data for_', subjects{subj}));
%     
%     figure(figureCount) %one figure per subject, with all sessions subplotted
%     figureCount= figureCount+1;
%     
%    sgtitle(strcat(subjData.(subjects{subj})(1).experiment, subjects{subj}, 'downsampled photometry traces')); %add big title above all subplots
%     
%    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
%        
%        currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
%       
%        
%      
%        
%        % Raw session plots- within subjects
%         subplot(numel(subjData.(subjects{subj})),1,session); %one subplot per session
%         hold on
%         plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
%         plot(currentSubj(session).cutTime, currentSubj(session).repurple,'m'); %plot 405nm trace
%         title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
%         xlabel('time (s)');
%         ylabel('mV');
%         legend('blue (465)',' purple (405)');
%    end  
%         %make figure full screen, save, and close this figure
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% %         saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'_downsampled_session_traces','.fig'));
%         close; %close 
% end


%% Within-subjects raw photometry plots- separate figures
for subj= 1:numel(subjects) %for each subject
    
%     currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%     
%     disp(strcat('plotting photometry data for_', subjects{subj}));
%            
%    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
%        
%        
%         figure(figureCount) %one figure per SESSION
%         figureCount= figureCount+1;
%        
%        
%        currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct
%       
%        
%       
%        
%        % Raw session plots- within subjects
%         hold on;
%         plot(currentSubj(session).cutTime, currentSubj(session).reblue, 'b'); %plot 465nm trace
%         plot(currentSubj(session).cutTime, currentSubj(session).repurple,'m'); %plot 405nm trace
%         title(strcat('Rat #',num2str(currentSubj(session).rat),' training day :', num2str(currentSubj(session).trainDay), ' downsampled ', ' box ', num2str(currentSubj(session).box)));
%         xlabel('time (s)');
%         ylabel('mV');
%         legend('blue (465)',' purple (405)');
%         
%         
%          %make figure full screen, save, and close this figure
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% % %         waitforbuttonpress();
% %         saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'session',num2str(currentSubj(session).trainDay),'_downsampled_trace','.fig'));
%         close; %close
%    end  
    
end


%% ~~~Photometry Signal processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Photobleach correction
 %Going for something like (Patel et al 2019 bioRxiv)
for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       clear cutTime reblue repurple
       
       cutTime= currentSubj(session).cutTime;
       reblue= currentSubj(session).reblue;
       repurple= currentSubj(session).repurple;
       
       
%        
     %let's fit an exponential function to the blue and purple signals

     %First order exponential fit
% ft=fittype('exp1');
% currentSubj(session).blueFit=fit(cutTime',reblue,ft);
% currentSubj(session).purpleFit=fit(cutTime',repurple,ft);

    %matlab's built in detrend function 
% detrendblue= detrend(reblue, 2);
% detrendpurple= detrend(repurple, 2);
%      
%      figure(figureCount);
%      figureCount=figureCount+1;
%      subplot(2,1,1);
%      plot(currentSubj(session).blueFit, cutTime, reblue)
%      hold on;
% %      plot(cutTime,detrendblue,'k');
%      subplot(2,1,2);
%      plot(currentSubj(session).purpleFit, 'k', cutTime, repurple, 'm')
%      hold on;
% %      plot(cutTime,detrendpurple,'k');
%      
%      set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving/closing
%      
% %      waitforbuttonpress;
%      close;

     
         %matlab's built in moving median function
         %inspired by(Patel, McAlinden, Matheison, &
         %Sakata, 2019 BioRxiv) but not really what they did
    medianblue= movmedian(reblue,800);
    medianpurple= movmedian(repurple, 800); %40=1s %800 = 20s
    
    dffblue= (reblue-medianblue)./medianblue;
    dffpurple= (repurple-medianpurple)./medianpurple;
    
    figure(figureCount);
    figureCount= figureCount+1;
    subplot(4,1,1);
    title('blue moving median')
    hold on;
    plot(cutTime,reblue);
    plot(cutTime,medianblue, 'k');
    subplot(4,1,2);
    hold on;
    title('blue dF/F (value-median/median)');
    plot(cutTime,dffblue);
    subplot(4,1,3);
    title('purple moving median')
    hold on;
    plot(cutTime, repurple, 'm');
    plot(cutTime, medianpurple, 'k');
    subplot(4,1,4);
    hold on;
    title('purple dF/F (value-median/median)');
    plot(cutTime,dffpurple, 'm');
    
    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving/closing
    
%     waitforbuttonpress;
    close;
    
          
    subjDataAnalyzed.(subjects{subj})(session).photometry.bluedff= dffblue;
    subjDataAnalyzed.(subjects{subj})(session).photometry.purpledff= dffpurple;
   end %end session loop
end %end subject loop
 
 
%% ~~~Photometry Analysis ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% CROSS CORRELATION OF PHOTOMETRY SIGNALS

%For a given session, let's get a correlation coefficient of Blue & Purple
%signal over time
for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   
%    figure(figureCount); %1 fig per subject
%    figureCount= figureCount+1;
   
   for session = 1:numel(currentSubj) %for each training session this subject completed

%        currentSubj(session).signalCorrelation= xcorr(currentSubj(session).reblue,currentSubj(session).repurple,0,'coeff');
        
        cutTime = currentSubj(session).cutTime;
        r= [];
        p= [];

        
        %Try sliding corrcoef calc
%         slideFrames= 10*fs;
%         for ts = 1:numel(cutTime) %for each timestamp
%             
%             if ts-slideFrames> 0 && ts+slideFrames<numel(cutTime)
%                 startTime= ts-slideFrames;
%                 endTime= ts+slideFrames;
% 
%                 [R,P] = corrcoef(currentSubj(session).reblue(startTime:endTime), currentSubj(session).repurple(startTime:endTime));
%                 r(ts)= R(2);
%                 p(ts)= P(2);
%             end
%         end
%         
%         plot(r);
% figure;

%         currentSubj(session).signalCorrelation= corrcoef(currentSubj(session).reblue,currentSubj(session).repurple);
%         [r, lags]= xcorr(currentSubj(session).reblue, currentSubj(session).repurple, 'unbiased');
%         hold on;
%         
%         [r, lags]= xcorr(currentSubj(session).reblue, currentSubj(session).repurple, 'coeff');


        %xcorr on the raw signals returns a triangle shaped plot with a
        %peak at 0, possibly due to DC offset component in signals... Will
        %try to remove this by subtracting mean

        
%         [r, lags]= xcorr(currentSubj(session).reblue-mean(currentSubj(session).reblue), currentSubj(session).repurple-mean(currentSubj(session).repurple), 'coeff');
%         stem(lags, r);

        %still getting a weird shape, let's try this on a rolling z score?
               
% %trying movcorr function
% r2= [];
% p2=[];
%     [r2, p2, n]=movcorr(currentSubj(session).reblue, currentSubj(session).repurple, 400); %sliding 10s pearson
% 
%     subplot(4,1,1);
%     plot(cutTime, currentSubj(session).reblue, 'b');
%     subplot(4,1,2);
%     plot(cutTime, currentSubj(session).repurple, 'm');
%     subplot(4,1,3);
%     plot(cutTime, r2, 'k');
%     title('sliding r')
%     hold on
%     plot([1, cutTime(end)], [0, 0], 'k--');
%     hold off
%     subplot(4,1,4);
%     plot(cutTime,p2, 'r');
%     title('p value');
%     hold on
%     plot([1, cutTime(end)], [0.05, 0.05], 'k--');
%     hold off
%            
%     figure;
%     plot(r2);
%        scatter(currentSubj(session).trainDay,currentSubj(session).signalCorrelation(2));
   end %end session loop
end %end subject loop


%% Trying correlation with dff calculated in previous section
for subj= 1:numel(subjects)
    for session= 1:numel(subjDataAnalyzed.(subjects{subj}))
        
        cutTime= subjData.(subjects{subj})(session).cutTime;
        currentSubj= subjDataAnalyzed.(subjects{subj}); %easy indexing into subject
              %going to try on dff calculated by previous section
%         [r, lags]= xcorr(currentSubj(session).photometry.bluedff,currentSubj(session).photometry.purpledff, 'coeff');
%         stem(lags, r);
        
       
        
%         %trying movcorr function
%     [r, p, n]=movcorr(currentSubj(session).photometry.bluedff, currentSubj(session).photometry.purpledff, 400); %sliding 10s pearson
% 
%     figure(figureCount);
%     figureCount= figureCount+1;
%     
%     subplot(4,1,1);
%     plot(cutTime, currentSubj(session).photometry.bluedff, 'b');
%     hold on;
%     title('blue dff');
%     subplot(4,1,2);
%     plot(cutTime, currentSubj(session).photometry.purpledff, 'm');
%     hold on;
%     title('purple dff');
%     subplot(4,1,3);
%     plot(cutTime, r, 'k');
%     title('sliding r')
%     hold on
%     plot([1, cutTime(end)], [0, 0], 'k--');
%     hold off
%     subplot(4,1,4);
%     plot(cutTime,p, 'r');
%     title('p value');
%     hold on
%     plot([1, cutTime(end)], [0.05, 0.05], 'k--');
%     hold off
%     
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving/closing
%     waitforbuttonpress;
%     close;

    end %end session loop
end %end subj loop


%% Create subjDataAnalyzed struct to hold analyzed data
%In this section, we'll initialize a subjDataAnalyzed struct to hold any
%relevant analyzed data separately from raw data. We will populate it with
%some metadata before doing any analyses. This metadata all originates from
%the metadata.xlsx file and the subjData struct generated by
%fpExtractData.m

%Fill with metadata
 for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       experimentName= currentSubj(session).experiment; 
       
       subjDataAnalyzed.(subjects{subj})(session).experiment= currentSubj(session).experiment;
       
       subjDataAnalyzed.(subjects{subj})(session).date= currentSubj(session).date;
       
       subjDataAnalyzed.(subjects{subj})(session).rat= currentSubj(session).rat;
       subjDataAnalyzed.(subjects{subj})(session).fileName= currentSubj(session).fileName;
       subjDataAnalyzed.(subjects{subj})(session).trainDay= currentSubj(session).trainDay;
       subjDataAnalyzed.(subjects{subj})(session).trainStage= currentSubj(session).trainStage;
       subjDataAnalyzed.(subjects{subj})(session).box= currentSubj(session).box;       
   end %end session loop
end %end subject loop

%% ~~~Reward identification ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %fpr stages with variable reward identity (3 pumps, 3 rewards)
    %indicated by 1, 2, or 3 DS TTL pulses in rapid succession
    
    ttlWindow= 2; %time window within which to look for DS TTL pulse bursts ... %2s should be enough
    
    %TODO: consider moving this to fpextractdata.m
    
 for subj= 1:numel(subjects) %for each subject
       for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
           currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
                      
           if ~isnan(currentSubj(session).pump2) %make sure this is a valid stage with multiple rewards
               
                %first lets save reward identity for each pump
               subjDataAnalyzed.(subjects{subj})(session).reward.pump1= currentSubj(session).pump1;
               subjDataAnalyzed.(subjects{subj})(session).reward.pump2= currentSubj(session).pump2;
               subjDataAnalyzed.(subjects{subj})(session).reward.pump3= currentSubj(session).pump3;
               
               %now we've got to classify DS trials as either pump1,2,or 3
               %based on ttl pulses
               
%                DSttl= currentSubj(session).DS;
               
               DScount = 1; %keep track of the actual ds trial count (because we'll have a bunch of extra TTL pulses simply denoting reward identity)
               
               ttlCount= 1; %use this to skip over TTL pulses in the same trial
              
               for cue= 1:numel(currentSubj(session).DS) %for each DS TTL pulse
                   
                   if ttlCount < numel(currentSubj(session).DS) %since we are adding to ttlCount this just prevents us from going beyond the max index
                   
                       ttlWindowStartTime= currentSubj(session).DS(ttlCount)-ttlWindow;
                       ttlWindowEndTime= currentSubj(session).DS(ttlCount)+ttlWindow;

                       ttlPump= currentSubj(session).DS(currentSubj(session).DS > ttlWindowStartTime & currentSubj(session).DS < ttlWindowEndTime);

                       %save the DS onset as the first TTL pulse in this window (the minimum timestamp)
                       subjDataAnalyzed.(subjects{subj})(session).reward.DS(DScount,1)= min(ttlPump); 
                       
                       %get this shifted timestamp too (because its used in timelocking)
                       subjDataAnalyzed.(subjects{subj})(session).reward.DSshifted(DScount,1)= subjData.(subjects{subj})(session).DSshifted(ttlCount);


                       %save the pump identity based on the # of TTL pulses in this window (numel)

                        if numel(ttlPump) == 1
                            subjDataAnalyzed.(subjects{subj})(session).reward.DSreward(DScount,1)= 1;                                                       
                            DScount= DScount+1;
                            ttlCount= ttlCount+1;
                        elseif numel(ttlPump) ==2
                            subjDataAnalyzed.(subjects{subj})(session).reward.DSreward(DScount,1)= 2;
                            DScount= DScount+1;
                            ttlCount = ttlCount+2; %skip over the next cue ttl pulse because it is in the same trial
                        elseif numel(ttlPump) ==3
                            subjDataAnalyzed.(subjects{subj})(session).reward.DSreward(DScount,1)= 3;
                            DScount= DScount+1;
                            ttlCount = ttlCount+3; %skip over the next two cue ttl pulses because these are in the same trial 
                        end
                                               
                   end %end ttlCount conditional
               end %end cue loop
          
                  
               %for simplicity let's overwrite the original DS trial record with
               %the updated one %TODO: think about other ways to address this
               subjData.(subjects{subj})(session).DS= subjDataAnalyzed.(subjects{subj})(session).reward.DS;
               subjData.(subjects{subj})(session).DSreward= subjDataAnalyzed.(subjects{subj})(session).reward.DSreward;
               subjData.(subjects{subj})(session).DSshifted= subjDataAnalyzed.(subjects{subj})(session).reward.DSshifted;

         
               
            else %if there's no variable reward in this session, make empty
                       
                subjDataAnalyzed.(subjects{subj})(session).reward= [];              
               
            end %end if pump 2 isnan conditional (alternative to stage conditional)

       
       end %end session loop

       
end %end subject loop



%% ~~~Behavioral Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


%% Lick bout classification

%In this section, we will loop through all licks for each session and
%define lick bouts based on the parameters below. We will use lickInd as a
%counter to keep track of which lick we should be on as we loop through,
%since bout size differs. We will look for licks within a certain interlick
%interval (ILI) of each lick. If we find any, they'll be saved to the bout
%array. We will then keep looking for licks within the ILI of the final
%lick in the bout until we don't find any more, at which point we'll change
%the boutDone conditional to finish evaluating this bout. If this bout
%meets some criteria (e.g. has at least 3 bouts), we will save it and
%advance onto the next bout.

%first let's define some parameters 
interLickThreshold = 1.0; %threshold in seconds between licks beyond which = new bout
licksPerBoutThreshold= 3; %need this many licks to be called a bout

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
      
   
   for session = 1:numel(currentSubj) %for each training session this subject completed
     
      boutCount=1; %counter for bouts
      lickInd= 1; %counter used to skip over licks in the current bout

      bout= []; %array containing licks for the current bout
      lickBouts= {}; %cell array containing lick bouts
       
      boutDone= 0; %logic gate between bouts
      
       for lick = 1:numel(currentSubj(session).lox)
           
           if lickInd< numel(currentSubj(session).lox) %make sure the index is valid (since we're adding to lickInd)
            
               if boutDone ==0 %if we are still filling the current bout
               
             
                       if isempty(bout) %start assigning licks to this bout if bout is empty
                           boutStart= currentSubj(session).lox(lickInd); %-interBoutThreshold;
                           boutEnd= currentSubj(session).lox(lickInd)+interLickThreshold;

                           %extract licks that occur between the bout start and end
                           %because we are using >= boutStart, there will
                           %always be at least 1 lick (the first one at boutStart)
                           %included in the bout... that is why we'll be
                           %using numel(bout>1) as a logic gate instead of
                           %~isempty
                           bout= currentSubj(session).lox(currentSubj(session).lox >=boutStart & currentSubj(session).lox <boutEnd);
                       end
                       
                       if  numel(bout>1) %if the bout has already been started and licks were found beyond the initial lick, continue filling the bout with licks
                           %now use bout(end) to see if there are more
                           %licks within the desired interlick interval
                           %(ili) threshold of the final lick in the bout
                           boutStart= bout(end);
                           boutEnd= bout(end)+interLickThreshold;
                           
                           bout= cat(1, bout,currentSubj(session).lox(currentSubj(session).lox>boutStart & currentSubj(session).lox<boutEnd)); 
                           lickInd = find(currentSubj(session).lox==bout(end)); %as the loop continues, skip over licks already assigned to a bout


                            %if there are no more licks within the desired
                            %ILI, make the bout complete
                            if isempty(currentSubj(session).lox(currentSubj(session).lox>boutStart & currentSubj(session).lox<boutEnd))
                                boutDone=1; 
                            end
                       end
                       
                       if numel(bout)==1 %if there aren't any licks except for the first one in this bout time window, advance lickInd by 1 and make the bout complete
                           lickInd=lickInd+1;
                           boutDone=1;
                       end                      
               end %end boutDone=0 conditional
               
               if boutDone==1 %if this bout is complete, let's save it and advance the boutCount
                   
                       if numel(bout) > licksPerBoutThreshold %Only if this 'bout' contains at least the number of licks required, call it a bout and save it
                          lickBouts{boutCount}= bout;
                          boutCount=boutCount+1;
                          bout=[];
                       
                       else %if there aren't enough licks to consider this a real bout, make bout empty again for the next loop
                           bout=[];
                       end
                       
                       boutDone=0; %reset the boutDone conditional
               end %end boutDone conditional
           end %end index check conditional
       end %end lick loop
       
       currentSubj(session).lickBouts= lickBouts;
       
   end %end session loop
   
   %save the lick bout data
   subjDataAnalyzed.(subjects{subj})(session).behavior.lickBouts= currentSubj(session).lickBouts;
   
% %   % %    %visualization
% %    figure(figureCount);
% %    figureCount= figureCount+1;
% %    
% %    for currentBout = 1:numel(currentSubj(session).lickBouts)
% %        hold on;
% %        title('lick bout # over time');
% %        scatter(currentSubj(session).lickBouts{currentBout},ones(size(currentSubj(session).lickBouts{currentBout}))*currentBout);
% %    end
% %    
end %end subject loop





%% Identify PEs and licks occuring during the DS 

% Here, we'll loop through every cue in every session, finding the cue
% onset time and the cue's duration. Then, we'll check for PEs and licks
% that occur during this duration and assign them to that cue.

%TODO: for licks, maybe not the best way to see licks for a particular reward
%since it's only getting licks in the cue duration... May be better to
%collect all licks between the current cue onset and the next cue's onset

%Parameters
preCueTime= 5; %t in seconds to examine before cue
postCueTime= 10; %t in seconds to examine after cue

preCueFrames= preCueTime*fs;
postCueFrames= postCueTime*fs;

periCueFrames= preCueFrames+postCueFrames;

slideTime = 400; %define time window before cue onset to get baseline mean/stdDev for calculating sliding z scores- 400 for 10s (remember 400/40hz ~10s)


disp('classifying events during cue epoch');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
  
   for session = 1:numel(currentSubj) %for each training session this subject completed    
  
        clear cutTime poxDS loxDS outDS %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

           %initialize cell arrays, so they're all the same size for
            %convenience
            currentSubj(session).behavior.poxDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.outDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.loxDS= cell(1,numel(currentSubj(session).DS));
            currentSubj(session).behavior.loxDSrel= cell(1,numel(currentSubj(session).DS));

        %First, let's establish the cue duration based on training stage
        if currentSubj(session).trainStage == 1
            cueLength= 60*fs; %60s on stage 1, multiply by fs to get #frames
        elseif currentSubj(session).trainStage ==2
            cueLength= 30*fs;
        elseif currentSubj(session).trainStage ==3
            cueLength= 20*fs;
        else %on subsequent stages, cueLength is 10s
            cueLength =10*fs; 
        end
        
        for cue=1:length(currentSubj(session).DS) %for each DS cue in this session

            %each entry in DS is a timestamp of the DS onset, let's get its
            %corresponding index from cutTime and use that to pull
            %surrounding data
            DSonset = find(cutTime==currentSubj(session).DSshifted(cue,1));
                     
          if DSonset + cueLength < numel(cutTime) %make sure cue isn't too close to the end of session  
                %find an save pox during the cue duration
                poxDScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).pox) % for every port entry logged during this session
                   if (cutTime(DSonset)<currentSubj(session).pox(i)) && (currentSubj(session).pox(i)<cutTime(DSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.poxDS{1,cue}(poxDScount,1)= currentSubj(session).pox(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        poxDScount=poxDScount+1; %iterate the counter
                   end
                end


                %find and save port exits during the cue
                outDScount= 1;
                for i = 1:numel(currentSubj(session).out) % for every port entry logged during this session
                   if (cutTime(DSonset)<currentSubj(session).out(i)) && (currentSubj(session).out(i)<cutTime(DSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.outDS{1,cue}(outDScount,1)= currentSubj(session).out(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        outDScount=outDScount+1; %iterate the counter
                   end
                end


                %find and save licks during the cue duration
                loxDScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).lox) % for every port entry logged during this session %cue onset + cueLength if within cue ; cueonset + periCueFrames if within the heatplot window
                   if (cutTime(DSonset)<currentSubj(session).lox(i)) && (currentSubj(session).lox(i)<cutTime(DSonset+postCueFrames)) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                       %save absolute timestamps  
                       currentSubj(session).behavior.loxDS{1,cue}(loxDScount,1)= currentSubj(session).lox(i); %cell array containing all pox during the cue, empty [] if no licks during the cue
                        
                       %save timestamps of lick relative to cue onset
                       currentSubj(session).behavior.loxDSrel{1,cue}(loxDScount,1)= currentSubj(session).lox(i)-cutTime(DSonset)
                       
                       loxDScount=loxDScount+1; %iterate the counter
                   end
                end
          end %end cue too close to end conditional
        end %end cue loop
               
        subjDataAnalyzed.(subjects{subj})(session).behavior= currentSubj(session).behavior; %save the results

   end %end session loop
     
end %end subject loop


%% Identify PEs and licks occuring during the NS 

% Here, we'll loop through every cue in every session, finding the cue
% onset time and the cue's duration. Then, we'll check for PEs and licks
% that occur during this duration and assign them to that cue.

disp('classifying events during NS cue epoch');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
  
   for session = 1:numel(currentSubj) %for each training session this subject completed    
  
        clear cutTime poxNS loxNS outNS %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

           %initialize cell arrays, so they're all the same size for
            %convenience
            currentSubj(session).behavior.poxNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.outNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.loxNS= cell(1,numel(currentSubj(session).NS));
            currentSubj(session).behavior.loxNSrel= cell(1,numel(currentSubj(session).NS));

        %First, let's establish the cue duration based on training stage
        if currentSubj(session).trainStage == 1
            cueLength= 60*fs; %60s on stage 1, multiply by fs to get #frames
        elseif currentSubj(session).trainStage ==2
            cueLength= 30*fs;
        elseif currentSubj(session).trainStage ==3
            cueLength= 20*fs;
        else %on subsequent stages, cueLength is 10s
            cueLength =10*fs; 
        end
        
        if ~isnan(currentSubj(session).NS) %can only run if NS data is present in session        
        
            for cue=1:length(currentSubj(session).NS) %for each NS cue in this session

                %each entry in NS is a timestamp of the NS onset, let's get its
                %corresponding index from cutTime and use that to pull
                %surrounding data
                NSonset = find(cutTime==currentSubj(session).NSshifted(cue,1));


                %find an save pox during the cue duration
                poxNScount= 1; %counter for indexing
                for i = 1:numel(currentSubj(session).pox) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).pox(i)) && (currentSubj(session).pox(i)<cutTime(NSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.poxNS{1,cue}(poxNScount,1)= currentSubj(session).pox(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        poxNScount=poxNScount+1; %iterate the counter
                   end
                end


                %find and save port exits during the cue
                outNScount= 1;
                for i = 1:numel(currentSubj(session).out) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).out(i)) && (currentSubj(session).out(i)<cutTime(NSonset+cueLength)) %if the port entry occurs between this cue's onset and this cue's onset, assign it to this cue 
                        currentSubj(session).behavior.outNS{1,cue}(outNScount,1)= currentSubj(session).out(i); %cell array containing all pox during the cue, empty [] if no pox during the cue
                        outNScount=outNScount+1; %iterate the counter
                   end
                end


                %find and save licks during the cue duration
                loxNScount= 1; %counter for indexing

                for i = 1:numel(currentSubj(session).lox) % for every port entry logged during this session
                   if (cutTime(NSonset)<currentSubj(session).lox(i)) && (currentSubj(session).lox(i)<cutTime(NSonset+postCueFrames)) %if the lick occurs between this cue's onset and this cue's onset, assign it to this cue 
                       %absolute lick timestamps 
                       currentSubj(session).behavior.loxNS{1,cue}(loxNScount,1)= currentSubj(session).lox(i); %cell array containing all pox during the cue, empty [] if no licks during the cue
                        
                       %lick timestamp relative to cue onset
                       currentSubj(session).behavior.loxNSrel{1,cue}(loxNScount,1)= currentSubj(session).lox(i)-cutTime(NSonset);
                       loxNScount=loxNScount+1; %iterate the counter
                   end
                end

            end %end cue loop            
        end %end NS conditional

        %save the results
        subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS= currentSubj(session).behavior.poxNS'; 
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS= currentSubj(session).behavior.outNS;
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNS= currentSubj(session).behavior.loxNS;
        
        subjDataAnalyzed.(subjects{subj})(session).behavior.loxNSrel= currentSubj(session).behavior.loxNSrel;
        
        %debugging - view these side by side to verify pox during NS epoch
        %are being assigned
%         openvar('currentSubj(session).NS')
%         openvar('currentSubj(session).pox')
%         openvar('subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS')

        
   end %end session loop
     
end %end subject loop


%% Identify trials where animal was waiting in port at cue onset

%here, we'll go through all cues from each session, finding the difference
%between the cue onset time and every logged port entry and port exit
%timestamp. We'll find the port entry and port exit that is closest (minimum difference) to the
%cue onset, then we'll compare these two. We will only look in one
%direction (after the cue onset time) by turning any negative differences
%into large positive differences. If the closest out pulse is closer to the cue onset
%than the closest port entry pulse, then the animal was already in the port
%on that trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       clear poxDiffDS outDiffDS poxDiffNS outDiffNS
       
       %loop through DS cues
        for cue = 1:numel(currentSubj(session).DS) %for each DS
            %for each pox timestamp, get the difference between the pox and this DS cue's onset
            for i = 1:numel(currentSubj(session).pox) 
                poxDiffDS(i) = currentSubj(session).pox(i)- currentSubj(session).DS(cue,1);
            end
            
            %get rid of negative values by making them very large
            %this way we're only looking at TTLs after cue onset
            poxDiffDS(poxDiffDS<0) = 99999; 
            
            [~,minPoxInd] = min(poxDiffDS);
                           
            currentSubj(session).pox(minPoxInd);

            for i= 1:numel(currentSubj(session).out)
                outDiffDS(i)= currentSubj(session).out(i)- currentSubj(session).DS(cue,1);
            end

            outDiffDS(outDiffDS<0)= 99999; %make any negative differences very large
            
            %if the closest TTL pulse to cue onset was an out, the animal was in the port already
            if min(outDiffDS)<min(poxDiffDS)
                
                currentSubj(session).inPortDS(1,cue)= cue;
%                 disp(strcat(subjects{subj}, 'session', num2str(session), '_DS_', num2str(cue), ' inPortDS '));

            else
                currentSubj(session).inPortDS(1,cue)= NaN;
            end
            
       end %end DS loop
       
   %Repeat for NS
   
        for cue = 1:numel(currentSubj(session).NS) %for each NS
            
            %for each pox timestamp, get the difference between the pox and this NS cue's onset
            for i = 1:numel(currentSubj(session).pox) 
                poxDiffNS(i) = currentSubj(session).pox(i)- currentSubj(session).NS(cue,1);
            end
            
            %get rid of negative values by making them very large
            %this way we're only looking at TTLs after cue onset
            poxDiffNS(poxDiffNS<0) = 99999; 
            
            [~,minPoxInd] = min(poxDiffNS);
                           
            currentSubj(session).pox(minPoxInd);

            for i= 1:numel(currentSubj(session).out)
                outDiffNS(i)= currentSubj(session).out(i)- currentSubj(session).NS(cue,1);
            end

            outDiffNS(outDiffNS<0)= 99999; %make any negative differences very large
            
            %if the closest TTL pulse to cue onset was an out, the animal was in the port already
            if min(outDiffNS)<min(poxDiffNS)
                
                currentSubj(session).inPortNS(1,cue)= cue;
%                 disp(strcat(subjects{subj}, 'session', num2str(session), '_NS_', num2str(cue), ' inPortNS '));

            else
                currentSubj(session).inPortNS(1,cue)= NaN;
            end
            
       end %end NS loop
       
       
       subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS= currentSubj(session).inPortDS;
       subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS= currentSubj(session).inPortNS;
       
   end %end session loop
end %end subject loop

%% Calculate DS PE latency
%relies on previous behavioral analyses sections
%here, we will calculate latency to enter port on every DS trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       %First, let's exclude trials where there was 1) no PE in the cue
       %epoch or 2) animal was already in the port at cue onset
        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
       
       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
                DSonset= DSselected(cue);
                firstPox = min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS{cue}); %min of poxDS= first PE after DS onset
                
                currentSubj(session).DSpeLatency(1,cue)= firstPox-DSonset;
%                  if currentSubj(session).DSpeLatency(1,cue)== 0 || currentSubj(session).DSpeLatency(1,cue)<0
%                     disp(currentSubj(session).DSpeLatency(1,cue) ) %Flag abnomal latency values
%                  end
           else %else if we want to skip over this cue, make latency nan
               currentSubj(session).DSpeLatency(1,cue) = nan;
           end               
       end %end DSselected loop
          
       subjDataAnalyzed.(subjects{subj})(session).behavior.DSpeLatency= currentSubj(session).DSpeLatency;
       
   end %end session loop
     
end %end subject loop


%% Calculate NS PE latency
%relies on previous behavioral analyses sections
%here, we will calculate latency to enter port on every NS trial

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
       %First, let's exclude trials where there was 1) no PE in the cue
       %epoch or 2) animal was already in the port at cue onset
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that NS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
       
       
       for cue = 1:numel(NSselected)
            
           if ~isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
                NSonset= NSselected(cue);
                firstPox = min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS{cue}); %min of poxNS= first PE after NS onset
                
                currentSubj(session).NSpeLatency(1,cue)= firstPox-NSonset;
                
           else %else if we want to skip over this cue, make latency nan
               currentSubj(session).NSpeLatency(1,cue) = nan;
           end               
       end %end NSselected loop
          
       subjDataAnalyzed.(subjects{subj})(session).behavior.NSpeLatency= currentSubj(session).NSpeLatency;

   end %end session loop
     
end %end subject loop

%% Calculate DS PE ratio
%relies on previous behavioral analyses sections
%here, we will calculate DS pe ratio

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
        DSselected= currentSubj(session).DS;  

       
        %We could exclude trials where animal was already in port, but
        %won't due this because they still receive a reward and MEDPC still
        %counts it toward the ratio
%         DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        currentSubj(session).DSpeRatio= numel(DSselected(~isnan(DSselected)))/numel(currentSubj(session).DS);
        
        
       subjDataAnalyzed.(subjects{subj})(session).behavior.DSpeRatio= currentSubj(session).DSpeRatio;

   end %end session loop
      
end %end subj loop

%% Calculate NS PE ratio
%relies on previous behavioral analyses sections
%here, we will calculate NS pe ratio

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed
       
        NSselected= currentSubj(session).NS;  
       
        %We could exclude trials where animal was already in port, but
        %won't due this because they still receive a reward and MEDPC still
        %counts it toward the ratio
%         NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that NS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
        
   if ~isnan(currentSubj(session).NS) %if there's NS data present, calculate ratio
            currentSubj(session).NSpeRatio= numel(NSselected(~isnan(NSselected)))/numel(currentSubj(session).NS);
        else % if no NS data present, make ratio nan
            currentSubj(session).NSpeRatio= nan;
        end %end ns conditional
        
       subjDataAnalyzed.(subjects{subj})(session).behavior.NSpeRatio= currentSubj(session).NSpeRatio;
       disp(currentSubj(session).NSpeRatio);
        
   end %end session loop
      
end %end subj loop


%% ~~~Event-Triggered Analyses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%In these sections, we will do an event-triggered analyses by extracting data 
%from the photometry traces immediately surrounding relevant behavioral events (e.g. cue onset, port entry, lick)
%To do so, we'll find the onset timestamp for each event (eventTime) and use this
%timestamp to extract photometry data surrounding it
%(preEventTime:postEventTime). This will be saved to the subjDataAnalyzed
%struct. 


%here we are establishing some variables for our event triggered-analysis
%TODO: putting this in the pox/lox id earlier also, be sure to
%remove/change that too
% periCueTime = 20;% t in seconds to examine before/after cue (e.g. 20 will get data 20s both before and after the cue) %TODO: use cue length to taper window cueLength/fs+10; %20;        
% periCueFrames = periCueTime*fs; %translate this time in seconds to a number of 'frames' or datapoints  

% % % preCueTime= 5; %t in seconds to examine before cue
% % % postCueTime=10; %t in seconds to examine after cue
% % % 
% % % preCueFrames= preCueTime*fs;
% % % postCueFrames= postCueTime*fs;
% % % 
% % % periCueFrames= preCueFrames+postCueFrames;
% % % 
% % % slideTime = 400; %define time window before cue onset to get baseline mean/stdDev for calculating sliding z scores- 400 for 10s (remember 400/40hz ~10s)


%% TIMELOCK TO DS
for subj= 1:numel(subjects) %for each subject

    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the curret subject within the struct

    %In this section, go cue-by-cue examining how fluorescence intensity changes in response to cue onset (either DS or NS)
    %Use an event-triggered sort of approach viewing data before and after cue onset where time 0 = cue onset time
    %Also, a sliding z-score will be calculated for each timepoint like in (Richard et al., 2018)- using data comprising 10s prior to that timepoint as a baseline  
    
    disp(strcat('running DS-triggered analysis subject_',  subjects{subj}));

        
    for session = 1:numel(currentSubj) %for each training session this subject completed              
        clear cutTime  %this is cleared between sessions to prevent spillover

        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

        for cue=1:length(currentSubj(session).DS) %DS CUES %For each DS cue, conduct event-triggered analysis of data surrounding that cue's onset

            %each entry in DS is a timestamp of the DS onset 
            DSonset = find(cutTime==currentSubj(session).DSshifted(cue,1));

            %define the frames (datapoints) around each cue to analyze
            preEventTimeDS = DSonset-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTimeDS = DSonset+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTimeDS< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to beginning, continuing'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTimeDS> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****DS cue ', num2str(cue), ' too close to end, continuing'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %blueA
            baselineMeanblue=mean(currentSubj(session).reblue((DSonset-slideTime):DSonset)); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue=std(currentSubj(session).reblue((DSonset-slideTime):DSonset)); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple=mean(currentSubj(session).repurple((DSonset-slideTime):DSonset)); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple=std(currentSubj(session).repurple((DSonset-slideTime):DSonset)); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDS.DS(cue) = currentSubj(session).DS(cue); %this way only included cues are saved

            subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeDS:postEventTimeDS);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeDS:postEventTimeDS))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeDS:postEventTimeDS))- baselineMeanpurple))/(baselineStdpurple);

            
            %dff - *******Relies upon previous photobleaching/baseline section
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSbluedff(:,:,cue)= subjDataAnalyzed.(subjects{subj})(session).photometry.bluedff(preEventTimeDS:postEventTimeDS);
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurpledff(:,:,cue)= subjDataAnalyzed.(subjects{subj})(session).photometry.purpledff(preEventTimeDS:postEventTimeDS);

% %%~~~~~~~~~~~~~~~~exclude VP-VTA-FP08 session 21 DS cue 17 (came unplugged, big outlier)~~~~~!!!
%     
%             if subj == 1 && session==21 && cue == 17
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue(:,:,cue) = nan;
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple(:,:,cue) = nan;
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue(:,:,cue) = nan;
%                subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple(:,:,cue) = nan;
%             end
            
                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDS.DSblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periDS.DSzpurple, 3);
                        
            %lets save the baseline mean and std used for z score calc- so
            %that we can use this same baseline for other analyses
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue)= baselineMeanblue;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue)= baselineStdblue;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue)= baselineMeanpurple;
            subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue)= baselineStdpurple;

        end %end DS cue loop
   end %end session loop
end %end subject loop
        
%% TIMELOCK TO NS
    %Same approach as above, but for NS; done a bit differently because not every session will have the NS
        disp(strcat('running NS-triggered analysis subject_',  subjects{subj}));

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct

       clear cutTime  %this is cleared between sessions to prevent spillover
       
       cutTime= currentSubj(session).cutTime; %save this as an array, immensely speeds things up because we have to go through each timestamp to find the closest one to the cues

  
      NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

%       disp(strcat('running NS-triggered analysis subject ', num2str(subj), '/', num2str(numel(subjects)), ' session ', num2str(session), '/', num2str(numel(currentSubj))));

      if isnan(currentSubj(session).NS)  %If there's no NS present, save data as empty arrays
          
        subjDataAnalyzed.(subjects{subj})(session).periNS.NS = [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple=[]; 

        %get the mean response to the DS for this session
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean=[]; 
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean=[]; 

        subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean= [];
        
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSbluedff= [];
        subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpledff= [];


      else %if the NS is present on this session, do the analysis and save results

            for cue=1:length(currentSubj(session).NS) %NS CUES %For each NS cue, conduct event-triggered analysis of data surrounding that cue's onset
                
                NSonset = find(cutTime==currentSubj(session).NSshifted(cue,1)); %get the corresponding cutTime index of the NS timestamp


                %define the frames (datapoints) around each cue to analyze
                preEventTimeNS = NSonset-preCueFrames; %earliest timepoint to examine is the shifted NS onset time - the # of frames we defined as periCueFrames (now this is equivalent to 20s before the shifted cue onset)
                postEventTimeNS = NSonset+postCueFrames; %latest timepoint to examine is the shifted NS onset time + the # of frames we defined as periCueFrames (now this is equivalent to 20s after the shifted cue onset)

               if NSonset-slideTime< 1 %If cue is too close to beginning, skip over it
                  disp(strcat('****NS cue ', num2str(cue), ' too close to beginning, continuing'));
                  NSskipped= NSskipped+1;%iterate the counter for skipped NS cues
                  continue%continue out of the loop and move onto the next NS cue
                end

               if postEventTimeNS> length(currentSubj(session).cutTime)-slideTime %if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                  disp(strcat('****NS cue ', num2str(cue), ' too close to end, continuing'));
                  NSskipped= NSskipped+1;  %iterate the counter for skipped NS cues
                  continue %continue out of the loop and move onto the next NS cue
               end

                % Calculate average baseline mean&stdDev 10s prior to DS for z-score
                %blueA
                baselineMeanblue=mean(currentSubj(session).reblue((NSonset-slideTime):NSonset)); %baseline mean blue 10s prior to DS onset for boxA
                baselineStdblue=std(currentSubj(session).reblue((NSonset-slideTime):NSonset)); %baseline stdDev blue 10s prior to DS onset for boxA
                %purpleA
                baselineMeanpurple=mean(currentSubj(session).repurple((NSonset-slideTime):NSonset)); %baseline mean purple 10s prior to DS onset for boxA
                baselineStdpurple=std(currentSubj(session).repurple((NSonset-slideTime):NSonset)); %baseline stdDev purple 10s prior to DS onset for boxA

                %save the data in the subjDataAnalyzed struct under the periNS field
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NS(cue)= currentSubj(session).NS(cue); %this way only analyzed cues are included
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.periNSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeNS:postEventTimeNS);
                
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue(:,:,cue)= currentSubj(session).reblue(preEventTimeNS:postEventTimeNS);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple(:,:,cue)= currentSubj(session).repurple(preEventTimeNS:postEventTimeNS);
                    %z score calculation
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue(:,:,cue)= (((currentSubj(session).reblue(preEventTimeNS:postEventTimeNS))-baselineMeanblue))/(baselineStdblue);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTimeNS:postEventTimeNS))- baselineMeanpurple))/(baselineStdpurple);

                     %dff - *******Relies upon previous photobleaching/baseline section
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSbluedff(:,:,cue)= (subjDataAnalyzed.(subjects{subj})(session).photometry.bluedff(preEventTimeNS:postEventTimeNS));
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpledff(:,:,cue)= (subjDataAnalyzed.(subjects{subj})(session).photometry.purpledff(preEventTimeNS:postEventTimeNS));

                
                    %get the mean response to the DS for this session
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSpurple, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to all cues 
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzblue, 3);
                subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periNS.NSzpurple, 3);
                

                %lets save the baseline mean and std used for z score calc- so
                %that we can use this same baseline for other analyses
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue)= baselineMeanblue;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue)= baselineStdblue;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue)= baselineMeanpurple;
                subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue)= baselineStdpurple;

             
            end % end NS cue loop
      end %end if NS ~nan conditional 
   end %end session loop
end %end subject loop

%% TIMELOCK TO FIRST PE AFTER DS (when sucrose should be dispensed)
%DS trials where animal was in port at cue onset are excluded

disp('conducting peri-DSpox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

        %get the DS cues
        DSselected= currentSubj(session).DS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
                
        DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        DSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(DSselected)
            
           if ~isnan(DSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch
               
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstPox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstPox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstPox = interp1(cutTime,cutTime, firstPox, 'nearest');

                %get the index of this timestamp in cutTime
                firstPoxind= find(cutTime==firstPox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstPoxind-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstPoxind+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstPoxdS ', num2str(cue), ' too close to beginning, continueing out'));
                DSskipped= DSskipped+1;
                continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
                disp(strcat('****firstPoxDS cue ', num2str(cue), ' too close to end, continueing out'));
                DSskipped= DSskipped+1;  %iterate the counter for skipped DS cues
                continue %continue out of the loop and move onto the next DS cue
            end

            % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periDS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periDS field

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSselected= DSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);

                %get the mean response to the DS for this session
            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSpoxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblueMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurpleMean = mean(subjDataAnalyzed.(subjects{subj})(session).periDSpox.DSzpoxpurple, 3);
           end
       
       end %end DSselected loop
       
   end %end session loop
end %end subject loop


%% TIMELOCK TO FIRST PE AFTER NS (no sucrose)


disp('conducting peri-NSpox analysis');

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   for session = 1:numel(currentSubj) %for each training session this subject completed

       if ~isempty(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS) %can only run for sessions that have NS data
        %get the NS cues
        NSselected= currentSubj(session).NS;  

       
        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
        %have a non-nan value and use these to exclude NS trials from this
        %analysis (we'll make them nan)
                
        NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;
        
        clear cutTime %clear between sessions to prevent spillover
        
        cutTime= currentSubj(session).cutTime; %save this as an array, greatly speeds things up because we have to go through each timestamp to find the closest one to the cues

        NSskipped= 0;  %counter to know how many cues were cut off/not analyzed (since those too close to the end will be chopped off- this shouldn't happen often though)

       
       for cue = 1:numel(NSselected)
            
           if isnan(NSselected(cue)) %skip over trials where animal was in port at cue onset or did not make a PE during cue epoch, but save empty arrays
               
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue(1:periCueFrames+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple(1:periCueFrames+1,1,cue)= nan;

                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue(1:periCueFrames+1,1,cue)= nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple(1:periCueFrames+1,1,cue)= nan;
% 
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSselected= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue= [];
%                 subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple= [];
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblueMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurpleMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblueMean(1:periCueFrames+1,1,cue) = nan;
                subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurpleMean(1:periCueFrames+1,1,cue) = nan;
                
           else %if this is a selected NS
               
                 %find the minimum PE timestamp during the cue epoch (this is the 1st pe)
                firstPox= min(subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS{cue});
             
                %use interp to find closest timestamp in cutTime to this firstPox ( TODO: or we could add a timestamp and interp the photometry values?)
                firstPox = interp1(cutTime,cutTime, firstPox, 'nearest');

                %get the index of this timestamp in cutTime
                firstPoxind= find(cutTime==firstPox);
                
            %define the frames (datapoints) around each cue to analyze
            preEventTime = firstPoxind-preCueFrames; %earliest timepoint to examine is the shifted DS onset time - the # of frames we defined as periDSFrames (now this is equivalent to 20s before the shifted cue onset)
            postEventTime = firstPoxind+postCueFrames; %latest timepoint to examine is the shifted DS onset time + the # of frames we defined as periDSFrames (now this is equivalent to 20s after the shifted cue onset)

            if preEventTime< 1 %if cue onset is too close to the beginning to extract preceding frames, skip this cue
                disp(strcat('****firstPoxNS ', num2str(cue), ' too close to beginning, continueing out'));
                NSskipped= NSskipped+1;
            continue
            end

            if postEventTime> length(currentSubj(session).cutTime)-slideTime %%if cue onset is too close to the end to extract following frames, skip this cue; if the latest timepoint to examine is greater than the length of our time axis minus slideTime (10s), then we won't be able to collect sufficient basline data within the 'slideTime' to calculate our sliding z score- so we will just exclude this cue
            disp(strcat('****firstPoxDS cue ', num2str(cue), ' too close to end, continueing out'));
            NSskipped= NSskipped+1;  %iterate the counter for skipped DS cues
            continue %continue out of the loop and move onto the next DS cue
            end

              % Calculate average baseline mean&stdDev 10s prior to DS for z-score
            %we'll retrieve the baselines calculated when we timelocked to
            %DS, so our z score is relative to a baseline prior to any
            %cue-related activity
            %blueA
            baselineMeanblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanblue(1,cue); %baseline mean blue 10s prior to DS onset for boxA
            baselineStdblue= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdblue(1,cue); %baseline stdDev blue 10s prior to DS onset for boxA
            %purpleA
            baselineMeanpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineMeanpurple(1,cue); %baseline mean purple 10s prior to DS onset for boxA
            baselineStdpurple= subjDataAnalyzed.(subjects{subj})(session).periNS.baselineStdpurple(1,cue); %baseline stdDev purple 10s prior to DS onset for boxA

            %save all of the following data in the subjDataAnalyzed struct under the periNS field

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSselected= NSselected;

%             subjDataAnalyzed.(subjects{subj})(session).periDS.periDSwindow(:,:,cue)= currentSubj(session).cutTime(preEventTimeDS:postEventTimeDS);

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue(:,:,cue)= currentSubj(session).reblue(preEventTime:postEventTime);
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple(:,:,cue)= currentSubj(session).repurple(preEventTime:postEventTime);
                
                %z score calculation: for each timestamp, subtract baselineMean from current photometry value and divide by baselineStd
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue(:,:,cue)= (((currentSubj(session).reblue(preEventTime:postEventTime))-baselineMeanblue))/(baselineStdblue); 
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple(:,:,cue)= (((currentSubj(session).repurple(preEventTime:postEventTime))- baselineMeanpurple))/(baselineStdpurple);
 
           end
       
       end %end DSselected loop
       end %end NS conditional
       
                 %get the mean response to the NS for this session
            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxblue, 3); %avg across 3rd dimension (across each page) %this just gives us an average response to 1st PE 

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSpoxpurple, 3); 

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblueMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxblue, 3);

            subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurpleMean = nanmean(subjDataAnalyzed.(subjects{subj})(session).periNSpox.NSzpoxpurple, 3);
       
   end %end session loop
end %end subject loop





subjectsAnalyzed = fieldnames(subjDataAnalyzed); %now, let's save an array containing all of the analyzed subject IDs (may be useful later if we decide to exclude subjects from analysis)
%% ~~~Individual subjects peri-event plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Establish common date axis across subjects
%since training day may vary between subjects, we want to eventually arrange
%all these data by the actual recording date. If a subject did not run a
%session on a date we should be able to make values on this date nan later 

%this section will simply collect all of the unique recording dates from
%all subjects into an array (allDates)

for subj= 1:numel(subjectsAnalyzed) %for each subject analyzed
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

    for session = 1:numel(currentSubj) %for each training session this subject completed
       
%       So save the dates in a cell array
        allDates(session,subj) = currentSubj(session).date;
%         allDates(session)= currentSubj(session).date;
%                 
    end %end session loop
   
end

    %remove invalid dates (empty sessions were filled with zero, let's make
    %these empty)
    allDates(allDates==0) = [];
    
    %retain only unique dates 
%     allDates= unique(allDates); 

%% HEAT PLOT OF AVG RESPONSE TO CUE (by session)

%Here, we'll make a figure for each subject with 4 subplots based on avg daily 
%response to cue- Avg blue z score response to DS, Avg blue z score response 
%to NS, Avg purple z score response to DS, Avg purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots
%first, we need to collect the avg cue response from all sessions and reshape for plotting

for subj= 1:numel(subjectsAnalyzed) %for each subject analyzed
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    %DS - extract data for plots
    %avg cue response sorted by trial, timelocked to DS
    
    subjDates= zeros(1,numel(allDates));
    emptyDates= [];
    
    timeLock= [-preCueFrames:postCueFrames]/fs;
    
    %First find out which dates this subj has data for
    %get all dates for this subj
    for session= 1:numel(currentSubj)
        subjDates(session)= currentSubj(session).date;
    end %end session loop
    
    %now find out which dates from allDates this subj has data for 
    for thisDate = allDates %loop through all dates
        if isempty(subjDates(subjDates==thisDate)) %if this subj doesn't have valid data on this date
%                 emptyDates= cat(1, emptyDates,thisDate); %save this empty date to an array (add onto array by using cat())
                currentSubj(end+1).date= thisDate; %use end+1 to add a new empty session
                
                %fill relevant fields with NaN for later 
                currentSubj(end).periDS.DSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periDS.DSzpurpleMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzpurpleMean= NaN(size(timeLock'));

        end
    end
    
    %now let's resort the struct with empty sessions by date
     subjTable = struct2table(currentSubj); % convert the struct array to a table
     subjTableSorted = sortrows(subjTable, 'date'); % sort the table by 'date'
     currentSubj = table2struct(subjTableSorted); %convert back to struct

    
    %now get the actual photometry data
    for session = 1:numel(currentSubj) %for each training session this subject completed       
            if session ==1 %for the first session, get this sessions periDS blue z score response
                        currentSubj(1).DSzblueSessionMean= currentSubj(session).periDS.DSzblueMean; 
                        currentSubj(1).DSzpurpleSessionMean= currentSubj(session).periDS.DSzpurpleMean;
                else % add on periDS response for subsequent sessions
                        currentSubj(1).DSzblueSessionMean= cat(2, currentSubj(1).DSzblueSessionMean, currentSubj(session).periDS.DSzblueMean);
                        currentSubj(1).DSzpurpleSessionMean= cat(2, currentSubj(1).DSzpurpleSessionMean, currentSubj(session).periDS.DSzpurpleMean);
            end
    end %end session loop
 
    
    %Transpose for readability
    currentSubj(1).DSzblueSessionMean= currentSubj(1).DSzblueSessionMean';
    currentSubj(1).DSzpurpleSessionMean= currentSubj(1).DSzpurpleSessionMean';

    %get list of session days for heatplot y axis (transposed for readability)
%     subjTrial= cat(2, currentSubj.trainDay).'; %this is only training days for this subj
    subjTrial= 1:numel(allDates); %let's just number each training day starting at 1

    %NS- extract data for plots
    %session axis (Y) is handled a bit differently because we only want to show sessions that have NS cues
    
    %photometry signals sorted by trial, timelocked to NS
    
    for session = 1:numel(currentSubj) %for each training session this subject completed
        %if there's no NS data, fill with NaNs first
        if isempty(currentSubj(session).periNS.NSzblueMean)
            currentSubj(session).periNS.NSzblueMean= NaN(size(timeLock'));
            currentSubj(session).periNS.NSzpurpleMean= NaN(size(timeLock'));
        end
        
        if session ==1 %for the first session, get this sessions periDS blue z score response
                currentSubj(1).NSzblueSessionMean= currentSubj(session).periNS.NSzblueMean; 
                currentSubj(1).NSzpurpleSessionMean= currentSubj(session).periNS.NSzpurpleMean;
        else % add on periDS response for subsequent sessions
                currentSubj(1).NSzblueSessionMean= cat(2, currentSubj(1).NSzblueSessionMean, currentSubj(session).periNS.NSzblueMean);
                currentSubj(1).NSzpurpleSessionMean= cat(2, currentSubj(1).NSzpurpleSessionMean, currentSubj(session).periNS.NSzpurpleMean);
        end

    end %end session loop
    
    
    %Transpose for readability
    currentSubj(1).NSzblueSessionMean= currentSubj(1).NSzblueSessionMean';
    currentSubj(1).NSzpurpleSessionMean= currentSubj(1).NSzpurpleSessionMean';
   
    %get list of session days for heatplot y axis
%     subjTrialNS=[]; %keep track of sessions that have valid NS trials
%     dateNS= [];
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%         if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
% %              subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay); %old method based on trainDay
%                 dateNS= cat(2, dateNS, currentSubj(session).date);
%         end
%     end %end session loop
%     
%     %search NS dates for the appropriate index in allDates, then label it
%     %similar to subjTrial
%     for thisDate = 1:numel(dateNS) 
%         subjTrialNS(thisDate)= find(allDates==dateNS(thisDate)); %returns the index in allDates that matches the date of this NS session
%     end
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
    
     %define DS color axes
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
     topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMean, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
        topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
        bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomMeanShared= bottomAllDS;
        topMeanShared= topAllDS;
    end
    
    
    %Heatplots!       
    %DS z plot
    figure(figureCount);
    hold on;
    subplot(2,2,1); %subplot for shared colorbar

    %plot blue DS

    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatDSzblueMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzblueSessionMean, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg blue z score response surrounding DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleMean= imagesc(timeLock,subjTrial,currentSubj(1).DSzpurpleSessionMean,  'AlphaData', ~isnan(currentSubj(1).DSzpurpleSessionMean)); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' daily avg purple z score response surrounding DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
    

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving




    %     %NS z plot
    hold on;
    subplot(2,2,2); %subplot for shared colorbar

    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatNSzblueMean= imagesc(timeLock,subjTrial,currentSubj(1).NSzblueSessionMean, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), 'avg blue z score response to NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple NS (subplotted for shared colorbar)
    subplot(2,2,4);
    heatNSzpurpleMean= imagesc(timeLock,subjTrial,currentSubj(1).NSzpurpleSessionMean, 'AlphaData', ~isnan(currentSubj(1).NSzpurpleSessionMean)); 

    title(strcat('rat ', num2str(subjectsAnalyzed{subj}), ' avg purple z score response to NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); %TODO: NS trial labels must be different, only stage 5 trials

    caxis manual;
    caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
    saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZSessionAvg','.fig')); %save the current figure in fig format
    figureCount=figureCount+1; %iterate the figure count

    
%     % 2D plot of cue response from all sessions
%          figure(figureCount);
%          figureCount=figureCount+1;
%        
%          subplot(1,2,1) %DS
%          title('DS session avgs');
%           hold on;
%           plot(timeLock,currentSubj(1).DSzblueSessionMean, 'b');
%           plot(timeLock,currentSubj(1).DSzpurpleSessionMean, 'm');
%           
%           subplot(1,2,2) %NS
%           hold on;
%           title('NS session avgs');
%           plot(timeLock,currentSubj(1).NSzblueSessionMean, 'b');
%           plot(timeLock,currentSubj(1).NSzpurpleSessionMean, 'm');
%           set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
    
     %plot of mean response during each session; keypress advances thru sessions
              
          figure(figureCount);
     
         for session= 1:numel(currentSubj)
             subplot(1,2,1) %DS
             title('DS session avgs');
              hold on;
              plot(timeLock,currentSubj(1).DSzblueSessionMean(session,:), 'b');
              plot(timeLock,currentSubj(1).DSzpurpleSessionMean(session,:), 'm');

              subplot(1,2,2) %NS
              hold on;
              title('NS session avgs');
              plot(timeLock,currentSubj(1).NSzblueSessionMean(session,:), 'b');
              plot(timeLock,currentSubj(1).NSzpurpleSessionMean(session,:), 'm');
              set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
              
%               waitforbuttonpress;
%               cla;
         end %end session loop
     
           figureCount=figureCount+1;


end %end subject loop
    
%% HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION- sorted by trial 

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS, blue z score response to NS, purple z score response to
%DS, purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    sesCount= 1; %counter to keep track of sessions that meet a condition (e.g. if you only want to look at stage 5 sessions
    for session = 1:numel(currentSubj) %for each training session this subject completed
%         if currentSubj(session).trainStage == 5
%         if currentSubj(session).trainStage== 1 || currentSubj(session).trainStage ==2 || currentSubj(session).trainStage==3
        %collect all z score responses to every single DS across all sessions
            if sesCount==1 %for first session, initialize 
                currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

                currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
                currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

                currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
                currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 
            end
        sesCount=sesCount+1;   

    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
%      %overlay plot of transitions between training stages - TODO: this
%      %stopped working after stage 6 I think
%     transitionCue= [];
%     transitionDay=[];
%     
%     cueCount = 1;
%     
%     stageCount= 1;
%     
%     for session= 1:numel(currentSubj)
%        
%        if session ==1 
%            trainStage = currentSubj(session).trainStage;
%        end
%         
%        if currentSubj(session).trainStage ~= trainStage
%            %if the trainStage changes, save this day as a transision
%            trainStage = currentSubj(session).trainStage;
%            
%            %iterate stageCount
%            stageCount=stageCount+1
%            transitionDay(stageCount) = currentSubj(session).trainDay;
%            
% %            disp(strcat('transition day ', num2str(transitionDay(session))));
%            
%            %since we are plotting individual trials and not days, 
%            %find the cue corresponding to the transition
%            %to do so,loop over all cues in the session, finding the
%            %matching saved to DSzblueAllTrials
%            for cue = 1:numel(currentSubj(session).periDS.DS) %for each cue in this session
%                 cueCount=cueCount+1;                                
%                 if find(currentSubj(1).DSzblueAllTrials'==currentSubj(session).periDS.DSzblue(:,:,cue),1)% currentSubj(1).DSzblueAllTrials(cue,:)' == currentSubj(session).periDS.DSzblue(:,:,cue)
%                     
% %                     [~, cueInd] =  find(currentSubj(1).DSzblueAllTrials'==currentSubj(session).periDS.DSzblue(:,:,cue),1);
%                     transitionCue(stageCount)= cueCount;
%                 end
%            end
% %            disp(strcat('transition Cue', num2str(transitionCue(session))))
%        end %end stage transition conditional
%     end %end session loop
%  
%     
%     for i= 1:numel(transitionCue)
%         if transitionCue(i) ~= 0
%             subplot(2,2,1) %DS blue
%             hold on;
%             plot([timeLock(1), timeLock(end)], [transitionCue(i), transitionCue(i)], 'k--')  
%             
%             subplot(2,2,3) %DS puprle
%             hold on;
%             plot([timeLock(1), timeLock(end)], [transitionCue(i), transitionCue(i)], 'k--')
%             
%         end
%     end
%        
    figureCount= figureCount+1;
end %end subject loop


%% LATENCY SORTED HEAT PLOT OF RESPONSE TO EVERY INDIVIDUAL CUE PRESENTATION

%Same as before, but now sorted by PE latency

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

        %initialize arrays for convenience
        currentSubj(1).NSzblueAllTrials= [];
        currentSubj(1).NSzpurpleAllTrials= [];
        currentSubj(1).NSpeLatencyAllTrials= [];

    for session = 1:numel(currentSubj) %for each training session this subject completed
       
        clear NSselected
        
        %We can only include trials that have a PE latency, so we need to
        %selectively extract these data first
        
            %get the DS cues
        DSselected= currentSubj(session).periDS.DS;  % all the DS cues

        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
            
        %We have to throw in an extra conditional in case we've excluded
        %cues in our peri cue analysis due to being too close to the
        %beginning or end. Otherwise, we can get an out of range error
        %because the inPortDS array doesn't exclude these cues.
        for inPortTrial = find(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS))
            if inPortTrial < numel(DSselected) 
                DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;
            end
        end
        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        
        %same here, we need an extra conditional in case cues were excluded
        for noPEtrial = find(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS))
            if noPEtrial < numel(DSselected)
                DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
            end
        end
        
        %this may create some zeros, so let's make those nan as well
        DSselected(DSselected==0) = nan;
        
        %lets convert this to an index of trials with a valid value 
        DSselected= find(~isnan(DSselected));
        
            %Repeat above for NS 
        if ~isempty(currentSubj(session).periNS.NS)
             NSselected= currentSubj(session).periNS.NS;  

            %First, let's exclude trials where animal was already in port
            %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
            %have a non-nan value and use these to exclude NS trials from this
            %analysis (we'll make them nan)

            NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

            %Then, let's exclude trials where animal didn't make a PE during
            %the cue epoch. To do so, get indices of empty cells in
            %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
            %happened during the cue epoch) and then use these to set that NS =
            %nan
            NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;

       
            %lets convert this to an index of trials with a valid value 
            NSselected= find(~isnan(NSselected));
        end %end NS conditional       
        
        %collect all z score responses to every single DS across all sessions
        %we'll use DSselected and NSselected as indices to pull only data
        %from trials with port entries
        if session==1 %for first session, initialize 
           currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
           currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
           currentSubj(1).DSpeLatencyAllTrials= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
         
           if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                currentSubj(1).NSpeLatencyAllTrials= currentSubj(session).behavior.NSpeLatency(NSselected); 
           else
               continue %continue if no NS data
           end
        else %add subsequent sessions using cat()
            currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSpeLatencyAllTrials = cat(2,currentSubj(1).DSpeLatencyAllTrials,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions
        
            if ~isempty(currentSubj(session).periNS.NS)
                currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                currentSubj(1).NSpeLatencyAllTrials = cat(2,currentSubj(1).NSpeLatencyAllTrials,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
            else
                continue %continue if nos NS data
            end
        end        
    end %end session loop
    
    
    %Sort PE latencies and retrieve an index of the sorted order that
    %we'll use to sort the photometry data
    [DSpeLatencySorted,DSsortInd] = sort(currentSubj(1).DSpeLatencyAllTrials);       

    [NSpeLatencySorted,NSsortInd] = sort(currentSubj(1).NSpeLatencyAllTrials);
    
    %Sort all trials by PE latency
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials(:,DSsortInd);
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials(:,DSsortInd);
    currentSubj(1).NSzblueAllTrials = currentSubj(1).NSzblueAllTrials(:,NSsortInd);
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials(:,NSsortInd);

    %Transpose these data for readability
    currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
    currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding DS trials with valid PE - sorted  by PE latency (Lo-Hi)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding DS trials with valid PE - sorted by PE latency (Lo-Hi) ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding NS trials with valid PE - sorted by PE latency (Lo-Hi) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding NS trials with valid PE - sorted by PE latency (Lo-Hi) ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
    end   
    
   
    %Overlay scatter of PE latency
   subplot(2,2,1) %DS blue
   hold on
   scatter(DSpeLatencySorted,currentSubj(1).totalDScount', 'm.');
   subplot(2,2,3) %DS purple
   hold on
   scatter(DSpeLatencySorted,currentSubj(1).totalDScount', 'm.');
   
   if ~isempty(currentSubj(1).NSzblueAllTrials)
      subplot(2,2,2) %NS blue
      hold on
      scatter(NSpeLatencySorted,currentSubj(1).totalNScount', 'm.');
     
      subplot(2,2,4) %NS purple
      hold on
      scatter(NSpeLatencySorted,currentSubj(1).totalNScount', 'm.');
   end
    
    figureCount= figureCount+1;
   
end %end subject loop

%% HEAT PLOT OF RESPONSE TO FIRST PE IN CUE EPOCH

%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS firstPox, blue z score response to NS firstPox, purple z score response to
%DS firstPox, purple z score response to NS firstPox.

%we'll pull from the subjDataAnalyzed struct to make our heatplots 

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
        
        %collect all z score responses to every single DSfirstPox across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSzpoxblueAllTrials= squeeze(currentSubj(session).periDSpox.DSzpoxblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSzpoxpurpleAllTrials= squeeze(currentSubj(session).periDSpox.DSzpoxpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSzpoxblueAllTrials= squeeze(currentSubj(session).periNSpox.NSzpoxblue); 
            currentSubj(1).NSzpoxpurpleAllTrials= squeeze(currentSubj(session).periNSpox.NSzpoxpurple);
        else %add subsequent sessions using cat()
            currentSubj(1).DSzpoxblueAllTrials = cat(2, currentSubj.DSzpoxblueAllTrials, (squeeze(currentSubj(session).periDSpox.DSzpoxblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSzpoxpurpleAllTrials = cat(2, currentSubj.DSzpoxpurpleAllTrials, (squeeze(currentSubj(session).periDSpox.DSzpoxpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSzpoxblueAllTrials = cat(2, currentSubj.NSzpoxblueAllTrials, (squeeze(currentSubj(session).periNSpox.NSzpoxblue))); 
            currentSubj(1).NSzpoxpurpleAllTrials = cat(2, currentSubj.NSzpoxpurpleAllTrials, (squeeze(currentSubj(session).periNSpox.NSzpoxpurple))); 
        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSzpoxblueAllTrials= currentSubj(1).DSzpoxblueAllTrials';
    currentSubj(1).DSzpoxpurpleAllTrials= currentSubj(1).DSzpoxpurpleAllTrials';    
    currentSubj(1).NSzpoxblueAllTrials= currentSubj(1).NSzpoxblueAllTrials';
    currentSubj(1).NSzpoxpurpleAllTrials= currentSubj(1).NSzpoxpurpleAllTrials';
      
    
    %remove nan trials (NSzpox arrays retain nan values bc of the 3d structure)
    currentSubj(1).NSzpoxblueAllTrials= currentSubj(1).NSzpoxblueAllTrials(all(~isnan(currentSubj(1).NSzpoxblueAllTrials),2),:); 
    currentSubj(1).NSzpoxpurpleAllTrials= currentSubj(1).NSzpoxblueAllTrials(all(~isnan(currentSubj(1).NSzpoxblueAllTrials),2),:); 

    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzpoxblueAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzpoxblueAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSzblue= stdFactor*abs(mean((std(currentSubj(1).DSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpoxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblue = -stdFactor*abs(mean((std(currentSubj(1).DSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpoxpurpleAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
     topAllDS= max(topDSzblue, topDSzpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %only run this if there's NS data
        topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzpoxblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpoxpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzpoxblueAllTrials, 0, 2))));
        bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpoxpurpleAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
        topAllNS= max(topNSzblue, topNSzpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDSpox.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSzpoxblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpoxblueAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE in DS epoch')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from PE');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding DS');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpoxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpoxpurpleAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first PE in DS epoch')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from PE');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding DS');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSzpoxblueAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSzpoxblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpoxblueAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE in NS epoch ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding NS');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSzpoxpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpoxpurpleAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding first PE in NS epoch ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from PE ');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding NS');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_perifirstPoxZ_AllTrials','.fig')); %save the current figure in fig format
    end
    
    
    figureCount= figureCount+1;
end %end subject loop

%% DFF heat plot of response to every individual cue


%Here, we'll make a figure for each subject with 4 subplots- blue z score
%response to DS, blue z score response to NS, purple z score response to
%DS, purple z score response to NS.

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
    for session = 1:numel(currentSubj) %for each training session this subject completed
                
        %collect all z score responses to every single DS across all sessions
        if session==1 %for first session, initialize 
            currentSubj(1).DSbluedffAllTrials= squeeze(currentSubj(session).periDS.DSbluedff); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            currentSubj(1).DSpurpledffAllTrials= squeeze(currentSubj(session).periDS.DSpurpledff); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
            
            currentSubj(1).NSbluedffAllTrials= squeeze(currentSubj(session).periNS.NSbluedff); 
            currentSubj(1).NSpurpledffAllTrials= squeeze(currentSubj(session).periNS.NSpurpledff);
        else %add subsequent sessions using cat()
            currentSubj(1).DSbluedffAllTrials = cat(2, currentSubj.DSbluedffAllTrials, (squeeze(currentSubj(session).periDS.DSbluedff))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
            currentSubj(1).DSpurpledffAllTrials = cat(2, currentSubj.DSpurpledffAllTrials, (squeeze(currentSubj(session).periDS.DSpurpledff))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
        
            currentSubj(1).NSbluedffAllTrials = cat(2, currentSubj.NSbluedffAllTrials, (squeeze(currentSubj(session).periNS.NSbluedff))); 
            currentSubj(1).NSpurpledffAllTrials = cat(2, currentSubj.NSpurpledffAllTrials, (squeeze(currentSubj(session).periNS.NSpurpledff))); 

        end
        
    end %end session loop
    
    %Transpose these data for readability
    currentSubj(1).DSbluedffAllTrials= currentSubj(1).DSbluedffAllTrials';
    currentSubj(1).DSpurpledffAllTrials= currentSubj(1).DSpurpledffAllTrials';    
    currentSubj(1).NSbluedffAllTrials= currentSubj(1).NSbluedffAllTrials';
    currentSubj(1).NSpurpledffAllTrials= currentSubj(1).NSpurpledffAllTrials';
      
    
    %get a trial count to use for the heatplot ytick
    currentSubj(1).totalDScount= 1:size(currentSubj(1).DSbluedffAllTrials,1); 
    currentSubj(1).totalNScount= 1:size(currentSubj(1).NSbluedffAllTrials,1);
    
    
    %TODO: split up yticks by session (this would show any clear differences between days)
    
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
     
     %define DS color axes
     
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 8; %multiplicative factor- how many stds away do we want our color max & min?
     
     topDSdffblue= stdFactor*abs(mean((std(currentSubj(1).DSbluedffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSdffpurple= stdFactor*abs(mean((std(currentSubj(1).DSpurpledffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSdffblue = -stdFactor*abs(mean((std(currentSubj(1).DSbluedffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSdffpurple= -stdFactor*abs(mean((std(currentSubj(1).DSpurpledffAllTrials, 0, 2))));
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottomDSdffblue, bottomDSdffpurple);
     topAllDS= max(topDSdffblue, topDSdffpurple);
     
    %same, but defining color axes for NS
    if ~isempty(currentSubj(1).NSbluedffAllTrials) %only run this if there's NS data
        topNSdffblue= stdFactor*abs(mean((std(currentSubj(1).NSbluedffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
        topNSdffpurple= stdFactor*abs(mean((std(currentSubj(1).NSpurpledffAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

        bottomNSdffblue= -stdFactor*abs(mean((std(currentSubj(1).NSbluedffAllTrials, 0, 2))));
        bottomNSdffpurple= -stdFactor*abs(mean((std(currentSubj(1).NSpurpledffAllTrials, 0, 2))));

        bottomAllNS= min(bottomNSdffblue, bottomNSdffpurple);
        topAllNS= max(topNSdffblue, topNSdffpurple);
    end
    
    %Establish a shared bottom and top for shared color axis of DS & NS
    if ~isempty(currentSubj(1).NSbluedffAllTrials) %if there is an NS
        bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
        topAllShared= max(topAllDS, topAllNS); %find the absolute min value
    else
        bottomAllShared= bottomAllDS;
        topAllShared= topAllDS;
    end
    
    %save for later 
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
    subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
    
    %Heatplots!  
    
    %DS z plot
    figure(figureCount);
    hold on;
    
    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    
    %plot blue DS

    subplot(2,2,1); %subplot for shared colorbar
    
    heatDSdffblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSbluedffAllTrials);
    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue dff response surrounding every DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue dff ');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSdffpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSpurpledffAllTrials); 

    title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple dff response surrounding every DS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));

%     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately

    caxis manual;
    caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
    
    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple dff');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format

    if ~isempty(currentSubj(1).NSbluedffAllTrials) %if there is NS data
        
        %plot blue NS
        subplot(2,2,2); %subplot for shared colorbar

        heatNSdffblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSbluedffAllTrials);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue dff response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS dff');
        
        
           %   plot purple NS (subplotted for shared colorbar)
        subplot(2,2,4);
        heatNSdffpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSpurpledffAllTrials); 

        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purpledff response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
        xlabel('seconds from cue onset');
        ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));

    %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately

        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('NS purple dff');

        set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

        saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueDffs_AllTrials','.fig')); %save the current figure in fig format
    end
    figureCount= figureCount+1;
end %end subj loop

%% Variable reward z score heatplot- timlocked to CUE
%here we will make a figure with subplotted heatplots of the z score
%response to all Pump1, Pump2, and Pump3 DS trials

%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct


rewardSessionCount= 0; %counter for sessions with valid variable reward data 


    for session = 1:numel(currentSubj) %for each training session this subject completed
                
        if ~isempty(currentSubj(session).reward) %make sure this is a valid stage with multiple rewards
            
            rewardSessionCount= rewardSessionCount+1; %counter for sessions with valid variable reward data 

            
            %first we need to get the z score data surrounding either pump1,
            %pump2, or pump3 DS trials. To do this, we'll use the reward
            %identities (reward.DSreward) as an indidices to get the right DS trials

            indPump1= find(currentSubj(session).reward.DSreward==1);
            indPump2= find(currentSubj(session).reward.DSreward==2);
            indPump3= find(currentSubj(session).reward.DSreward==3);

            %collect all z score responses to every single DS across all sessions
            if rewardSessionCount==1 %for first session, initialize 
                
                %now we'll use the reward identity (pump) indices to get only responses to those specific trials 
                currentSubj(1).DSzbluePump1= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump2= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump3= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

                rewardSessionCount= rewardSessionCount+1;
                
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
%                 currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzbluePump1 = cat(2, currentSubj(1).DSzbluePump1, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump2 = cat(2, currentSubj(1).DSzbluePump2, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump3 = cat(2, currentSubj(1).DSzbluePump3, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

                rewardSessionCount= rewardSessionCount+1;

% currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
% 
%                 currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
%                 currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 

            end
        end %end session loop
    end %end ~isempty reward conditional (alternative to stage conditional)
    
       
    if rewardSessionCount ~=0 %if this subject had a session with valid variable reward data

        %Transpose these data for readability
        currentSubj(1).DSzbluePump1= currentSubj(1).DSzbluePump1';
        currentSubj(1).DSzbluePump2= currentSubj(1).DSzbluePump2';
        currentSubj(1).DSzbluePump3= currentSubj(1).DSzbluePump3';


    %     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    %     currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    %     currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
    %       

        %get a trial count to use for the heatplot ytick
        currentSubj(1).DScountPump1= 1:size(currentSubj(1).DSzbluePump1,1); 
        currentSubj(1).DScountPump2= 1:size(currentSubj(1).DSzbluePump2,1); 
        currentSubj(1).DScountPump3= 1:size(currentSubj(1).DSzbluePump3,1); 


    %     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1);


        %TODO: split up yticks by session (this would show any clear differences between days)

%          Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes

         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?

         topDSzbluePump1= stdFactor*abs(mean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump2= stdFactor*abs(mean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump3= stdFactor*abs(mean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         
%          topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzbluePump1 = -stdFactor*abs(mean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump2 = -stdFactor*abs(mean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump3 = -stdFactor*abs(mean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
%          bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));

         %now choose the most extreme of these two (between blue and
         %purple)to represent the color axis 
         bottomAllDS= min([bottomDSzbluePump1, bottomDSzbluePump2, bottomDSzbluePump3]);
         topAllDS= max([topDSzbluePump1, topDSzbluePump2, topDSzbluePump3]);

%         %same, but defining color axes for NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%             topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%             topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%             bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%             bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%             topAllNS= max(topNSzblue, topNSzpurple);
%         end

%         %Establish a shared bottom and top for shared color axis of DS & NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%             bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%             topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%         else
            bottomAllShared= bottomAllDS;
            topAllShared= topAllDS;
%         end
% 
%         %save for later 
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;

        %Heatplots!  

        %DS z plot
        figure(figureCount);
        figureCount=figureCount+1;
        hold on;

        timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

        %plot pump1 blue DSz

        subplot(3,1,1); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump1,currentSubj(1).DSzbluePump1);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding Pump1 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        
                %plot pump2 blue DSz

        subplot(3,1,2); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump2,currentSubj(1).DSzbluePump2);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding Pump2 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

                %plot pump3 blue DSz

        subplot(3,1,3); %subplot for shared colorbar

        heatDSzbluePump3= imagesc(timeLock,currentSubj(1).DScountPump3,currentSubj(1).DSzbluePump3);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding Pump3 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from cue onset');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        %TODO: add purple plot
        
               set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    end %end variable reward conditional
end %end subject loop


%% Variable reward z-score heatplot- timelocked to FIRST PE after cue

for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct


rewardSessionCount= 0; %counter for sessions with valid variable reward data 


    for session = 1:numel(currentSubj) %for each training session this subject completed
                
        %clear between sessions
        indPump1= [];
        indPump2= [];
        indPump3= [];
        
                
        if ~isempty(currentSubj(session).reward) %make sure this is a valid stage with multiple rewards
            
            rewardSessionCount= rewardSessionCount+1; %counter for sessions with valid variable reward data 

            
            %first we need to get the z score data surrounding either pump1,
            %pump2, or pump3 DS trials. To do this, we'll use the reward
            %identities (reward.DSreward) as an indidices to get the right DS trials
           

            indPump1= find(currentSubj(session).reward.DSreward==1);
            indPump2= find(currentSubj(session).reward.DSreward==2);
            indPump3= find(currentSubj(session).reward.DSreward==3);
            
            %it's possible that indPump1,2, or 3 will result in an invalid
            %index (for a cue that was excluded in the peri cue analyses)
            %so let's check for that and exclude these (this may not be the
            %best method)
           
            for i= 1:numel(indPump1)
                if indPump1(i) > size(currentSubj(session).periDSpox.DSzpoxblue,3)
                   indPump1(i:end) = [];
                   break;
                end
            end
            
            for i= 1:numel(indPump2)
                if indPump2(i) > size(currentSubj(session).periDSpox.DSzpoxblue,3)
                   indPump2(i:end) = []; 
                  break;
                end
            end

            for i= 1:numel(indPump3)
                if indPump3(i) > size(currentSubj(session).periDSpox.DSzpoxblue,3)
                   indPump3(i:end) = []; 
                   break;
                end
            end

            %collect all z score responses to every single DS across all sessions
            if rewardSessionCount==1 %for first session, initialize 
                
                %now we'll use the reward identity (pump) indices to get only responses to those specific trials 
                currentSubj(1).DSzbluePump1= squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump1)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump2= squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump2)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump3= squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump3)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue

                rewardSessionCount= rewardSessionCount+1;
                
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
%                 currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzbluePump1 = cat(2, currentSubj(1).DSzbluePump1, squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump1))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump2 = cat(2, currentSubj(1).DSzbluePump2, squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump2))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump3 = cat(2, currentSubj(1).DSzbluePump3, squeeze(currentSubj(session).periDSpox.DSzpoxblue(:,:,indPump3))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

                rewardSessionCount= rewardSessionCount+1;

% currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
% 
%                 currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
%                 currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 

            end
        end %end ~isempty reward conditional (alternative to stage conditional)
    end %end session loop
    
       
    if rewardSessionCount ~=0 %if this subject had a session with valid variable reward data
        
        %some values were filled
        

        %Transpose these data for readability
        currentSubj(1).DSzbluePump1= currentSubj(1).DSzbluePump1';
        currentSubj(1).DSzbluePump2= currentSubj(1).DSzbluePump2';
        currentSubj(1).DSzbluePump3= currentSubj(1).DSzbluePump3';


    %     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    %     currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    %     currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
    %       

        %get a trial count to use for the heatplot ytick
        currentSubj(1).DScountPump1= 1:size(currentSubj(1).DSzbluePump1,1); 
        currentSubj(1).DScountPump2= 1:size(currentSubj(1).DSzbluePump2,1); 
        currentSubj(1).DScountPump3= 1:size(currentSubj(1).DSzbluePump3,1); 


 
        %TODO: split up yticks by session (this would show any clear differences between days)

%          Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes

         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?

         topDSzbluePump1= stdFactor*abs(mean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump2= stdFactor*abs(mean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump3= stdFactor*abs(mean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         
%          topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzbluePump1 = -stdFactor*abs(mean((std(currentSubj(1).DSzbluePump1, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump2 = -stdFactor*abs(mean((std(currentSubj(1).DSzbluePump2, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump3 = -stdFactor*abs(mean((std(currentSubj(1).DSzbluePump3, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
%          bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));

         %now choose the most extreme of these two (between blue and
         %purple)to represent the color axis 
         bottomAllDS= min([bottomDSzbluePump1, bottomDSzbluePump2, bottomDSzbluePump3]);
         topAllDS= max([topDSzbluePump1, topDSzbluePump2, topDSzbluePump3]);

%         %same, but defining color axes for NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%             topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%             topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%             bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%             bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%             topAllNS= max(topNSzblue, topNSzpurple);
%         end

%         %Establish a shared bottom and top for shared color axis of DS & NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%             bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%             topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%         else
            bottomAllShared= bottomAllDS;
            topAllShared= topAllDS;
%         end
% 
%         %save for later 
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;

        %Heatplots!  

        %DS z plot
        figure(figureCount);
        figureCount=figureCount+1;
        hold on;

        timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

        %plot pump1 blue DSz

        subplot(3,1,1); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump1,currentSubj(1).DSzbluePump1);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE- Pump1 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        
                %plot pump2 blue DSz

        subplot(3,1,2); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,currentSubj(1).DScountPump2,currentSubj(1).DSzbluePump2);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE- Pump2 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

                %plot pump3 blue DSz

        subplot(3,1,3); %subplot for shared colorbar

        heatDSzbluePump3= imagesc(timeLock,currentSubj(1).DScountPump3,currentSubj(1).DSzbluePump3);
        title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding first PE- Pump3 DS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
        xlabel('seconds from PE');
%         ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legend
        c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        %TODO: add purple plot
        
               set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

               
                   % ~~~~ 2d plot of all session means ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        %plot of response on Pump1, Pump2, and Pump3 DS trials
%        figure(figureCount);
%        figureCount=figureCount+1;
%        
%           hold on;
%           plot(timeLock,currentSubj(1).DSzbluePump1, 'k');
%           plot(timeLock,currentSubj(1).DSzbluePump2, 'r');
%           plot(timeLock,currentSubj(1).DSzbluePump3, 'g');
%           set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%           
          
      %~~~ 2d plot of grand mean of trials with valid PE
      
      figure(figureCount);
      figureCount= figureCount+1;
      hold on;
      plot(timeLock,mean(currentSubj(1).DSzbluePump1, 1), 'k');
      plot(timeLock,mean(currentSubj(1).DSzbluePump2, 1), 'r');
      plot(timeLock,mean(currentSubj(1).DSzbluePump3, 1), 'g');
      set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving               
               
    end %end variable reward conditional
end %end subject loop


%% Variable reward Session AVG z response heatplot


for subj= 1:numel(subjectsAnalyzed) %for each subject
currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct


rewardSessionCount= 0; %counter for sessions with valid variable reward data 


    for session = 1:numel(currentSubj) %for each training session this subject completed
                
        %clear between sessions
        indPump1= [];
        indPump2= [];
        indPump3= [];
        
        
        if ~isempty(currentSubj(session).reward) %make sure this is a valid stage with multiple rewards
            
            rewardSessionCount= rewardSessionCount+1; %counter for sessions with valid variable reward data 

            
            %first we need to get the z score data surrounding either pump1,
            %pump2, or pump3 DS trials. To do this, we'll use the reward
            %identities (reward.DSreward) as an indidices to get the right DS trials
           

            indPump1= find(currentSubj(session).reward.DSreward==1);
            indPump2= find(currentSubj(session).reward.DSreward==2);
            indPump3= find(currentSubj(session).reward.DSreward==3);
            
            %it's possible that indPump1,2, or 3 will result in an invalid
            %index (for a cue that was excluded in the peri cue analyses)
            %so let's check for that and exclude these (this may not be the
            %best method)
           
            for i= 1:numel(indPump1)
                if indPump1(i) > size(currentSubj(session).periDS.DSzblue,3)
                   indPump1(i:end) = [];
                   break;
                end
            end
            
            for i= 1:numel(indPump2)
                if indPump2(i) > size(currentSubj(session).periDS.DSzblue,3)
                   indPump2(i:end) = []; 
                  break;
                end
            end

            for i= 1:numel(indPump3)
                if indPump3(i) > size(currentSubj(session).periDS.DSzblue,3)
                   indPump3(i:end) = []; 
                   break;
                end
            end

            %collect all z score responses to every single DS across all sessions
            if rewardSessionCount==1 %for first session, initialize 
                
                %now we'll use the reward identity (pump) indices to get only responses to those specific trials 
                currentSubj(1).DSzbluePump1= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump2= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                currentSubj(1).DSzbluePump3= squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3)); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
                
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); 
%                 currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple);
            else %add subsequent sessions using cat()
                currentSubj(1).DSzbluePump1 = cat(2, currentSubj(1).DSzbluePump1, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump2 = cat(2, currentSubj(1).DSzbluePump2, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                currentSubj(1).DSzbluePump3 = cat(2, currentSubj(1).DSzbluePump3, squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)

% currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
% 
%                 currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); 
%                 currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); 
            end
            
            %get the Mean z value for each timepoint by taking mean z score for each timestamp across all
            %cues in this session
            currentSubj(1).DSzbluePump1mean(rewardSessionCount,:)= mean(squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump1)),2)';
            currentSubj(1).DSzbluePump2mean(rewardSessionCount,:)= mean(squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump2)),2)';
            currentSubj(1).DSzbluePump3mean(rewardSessionCount,:)= mean(squeeze(currentSubj(session).periDS.DSzblue(:,:,indPump3)),2)';

    %         currentSubj(session).DSzbluePump2mean= mean(currentSubj(1).DSzbluePump2,2);
    %         currentSubj(session).DSzbluePump3mean= mean(currentSubj(1).DSzbluePump3,2);

        end %end session loop
    end %end ~isempty reward conditional (alternative to stage conditional)
    
       
    if rewardSessionCount ~=0 %if this subject had a session with valid variable reward data




    %     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';    
    %     currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
    %     currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
    %       

        %get a trial count to use for the heatplot ytick
%         currentSubj(1).DScountPump1= 1:size(currentSubj(1).DSzbluePump1mean,1); 
%         currentSubj(1).DScountPump2= 1:size(currentSubj(1).DSzbluePump2mean,1); 
%         currentSubj(1).DScountPump3= 1:size(currentSubj(1).DSzbluePump3mean,1); 

 
        %TODO: split up yticks by session (this would show any clear differences between days)

%          Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes

         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 4; %multiplicative factor- how many stds away do we want our color max & min?

         topDSzbluePump1= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump2= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         topDSzbluePump3= stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         
%          topDSzpurple= stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzbluePump1 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump1mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump2 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump2mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
         bottomDSzbluePump3 = -stdFactor*abs(nanmean((std(currentSubj(1).DSzbluePump3mean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
%          bottomDSzpurple= -stdFactor*abs(mean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));

         %now choose the most extreme of these two (between blue and
         %purple)to represent the color axis 
         bottomAllDS= min([bottomDSzbluePump1, bottomDSzbluePump2, bottomDSzbluePump3]);
         topAllDS= max([topDSzbluePump1, topDSzbluePump2, topDSzbluePump3]);

%         %same, but defining color axes for NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%             topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%             topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%             bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%             bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%             bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%             topAllNS= max(topNSzblue, topNSzpurple);
%         end

%         %Establish a shared bottom and top for shared color axis of DS & NS
%         if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%             bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%             topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%         else
            bottomAllShared= bottomAllDS;
            topAllShared= topAllDS;
%         end
% 
%         %save for later 
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%         subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;

        %Heatplots!  

        %DS z plot
        figure(figureCount);
        figureCount=figureCount+1;
        hold on;

        sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), 'avg response to DS resulting in different reward'));
        
        timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

        %plot pump1 blue DSz

        subplot(3,1,1); %subplot for shared colorbar

        heatDSzbluePump1= imagesc(timeLock,rewardSessionCount,currentSubj(1).DSzbluePump1mean);
        title(strcat('Avg 465nm z score response to Pump1 DS'));
        xlabel('seconds from PE');
        ylabel(strcat('training day'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        
                %plot pump2 blue DSz

        subplot(3,1,2); %subplot for shared colorbar

        heatDSzbluePump2= imagesc(timeLock,rewardSessionCount,currentSubj(1).DSzbluePump2mean);
        title(strcat('Avg 465nm z score response to Pump2 DS'));
        xlabel('seconds from PE');
        ylabel(strcat('training day'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

                %plot pump3 blue DSz

        subplot(3,1,3); %subplot for shared colorbar

        heatDSzbluePump3= imagesc(timeLock,rewardSessionCount,currentSubj(1).DSzbluePump3mean);
        title(strcat('Avg 465nm z score response to Pump3 DS'));
        xlabel('seconds from PE');
        ylabel(strcat('training day'));
    %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
        caxis manual;
        caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values

        c= colorbar; %colorbar legendsd
        c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

        %TODO: add purple plot
        
               set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

               
               
       % ~~~~ 2d plot of all session means ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        %plot of response on Pump1, Pump2, and Pump3 DS trials
       figure(figureCount);
       figureCount=figureCount+1;
       
          hold on;
          plot(timeLock,currentSubj(1).DSzbluePump1mean, 'k');
          plot(timeLock,currentSubj(1).DSzbluePump2mean, 'r');
          plot(timeLock,currentSubj(1).DSzbluePump3mean, 'g');
          set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
          
          
      %~~~ 2d plot of grand mean of session mean
      
      figure(figureCount);
      figureCount= figureCount+1;
      hold on;
      plot(timeLock,mean(currentSubj(1).DSzbluePump1mean, 1), 'k');
      plot(timeLock,mean(currentSubj(1).DSzbluePump2mean, 1), 'r');
      plot(timeLock,mean(currentSubj(1).DSzbluePump3mean, 1), 'g');
      set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving               
               
    end %end variable reward conditional
end %end subject loop

%% ~~ Between subjects peri-event plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% BETWEEN SUBJECTS HEATPLOTS- Avg response to cue (by date)
 
 %gathering all mean data from time window around cue 
 
 
 for subj= 1:numel(subjectsAnalyzed) %for each subject
     
     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
 
     %we'll want to organize these by common date instead of relative
     %training day as well
     
     %First find out which dates this subj has data for
    %get all dates for this subj
    for session= 1:numel(currentSubj)
        subjDates(session)= currentSubj(session).date;
    end %end session loop
    
    %now find out which dates from allDates this subj has data for 
    for thisDate = allDates %loop through all dates
        if isempty(subjDates(subjDates==thisDate)) %if this subj doesn't have valid data on this date
%                 emptyDates= cat(1, emptyDates,thisDate); %save this empty date to an array (add onto array by using cat())
                currentSubj(end+1).date= thisDate; %use end+1 to add a new empty session
                
                %fill relevant fields with NaN for later 
                currentSubj(end).periDS.DSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periDS.DSzpurpleMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzblueMean= NaN(size(timeLock'));
                currentSubj(end).periNS.NSzpurpleMean= NaN(size(timeLock'));
                
                currentSubj(end).periNS.NS= nan;

        end
    end
    
    %now let's resort the struct with empty sessions by date
     subjTable = struct2table(currentSubj); % convert the struct array to a table
     subjTableSorted = sortrows(subjTable, 'date'); % sort the table by 'date'
     currentSubj = table2struct(subjTableSorted); %convert back to struct

     
     
     NStrialCount= 1; %counter for ns sessions
     
     %now get the actual photometry data
     
     for session = 1:numel(currentSubj) %for each session this subject completed

         allRats.meanDSzblue(:,session,subj)= currentSubj(session).periDS.DSzblueMean;
         allRats.meanDSzpurple(:,session,subj)= currentSubj(session).periDS.DSzpurpleMean;

         if isempty(currentSubj(session).periNS.NS) %if there's no NS data, fill with NaNs
            currentSubj(session).periNS.NSzblueMean= NaN(size(timeLock'));
            currentSubj(session).periNS.NSzpurpleMean=  NaN(size(timeLock'));
         end
         
         allRats.meanNSzblue(:,session,subj)= currentSubj(session).periNS.NSzblueMean;
         allRats.meanNSzpurple(:,session,subj)= currentSubj(session).periNS.NSzpurpleMean;
         
%          if ~isempty(currentSubj(session).periNS.NS) %only run if NS data present
%             allRats.meanNSzblue(:,NStrialCount,subj)= currentSubj(session).periNS.NSzblueMean;
%             allRats.meanNSzpurple(:,NStrialCount,subj)= currentSubj(session).periNS.NSzpurpleMean;
%              
% %             allRats.subjTrialNS(NStrialCount,subj)= currentSubj(session).trainDay;
%             
%             NStrialCount= NStrialCount+1;
%             % zeros are appearing in sessions where there's no data! (e.g.
%             % rats are on different training days, so one can be on day 14
%             % ahead of others that are on day 13)
%                        %skipping from 6->10
%          else %if there's no NS data present, fill with nan (otherwise will fill with zeros)
%             allRats.meanNSzblue(:,session, subj)= nan(size(currentSubj(session).periDS.DSzblueMean));
%             allRats.meanNSzpurple(:,session,subj)= nan(size(currentSubj(session).periDS.DSzblueMean));        
%          end %end NS conditional
     end %end session loop
          
 end %end subj loop

 % mean of all rats per training day ( each column is a training day , each 3d page is a subject)
allRats.grandDSzblue=nanmean(allRats.meanDSzblue(:,:,:),3)'; %(:,:,1:4),3)' % doing 1:4 in 3rd dmension because rat8 is a GFP animal but need to find more robust way to do this
allRats.grandDSzpurple=nanmean(allRats.meanDSzpurple(:,:, :),3)'; %1:4),3)'
allRats.grandNSzblue=nanmean(allRats.meanNSzblue(:,:,:),3)';%'; %1:4),3)'
allRats.grandNSzpurple=nanmean(allRats.meanNSzpurple(:,:,:),3)'; %,1:4),3)'

 %get bottom and top for color axis of DS heatplot
 allRats.bottomMeanallDS = min(min(min(allRats.grandDSzblue)), min(min(allRats.grandDSzpurple))); %find the lowest value 
 allRats.topMeanallDS = max(max(max(allRats.grandDSzblue)), max(max(allRats.grandDSzpurple))); %find the highest value

 %get bottom and top for color axis of NS heatplot
 allRats.bottomMeanallNS = min(min(min(allRats.grandNSzblue)), min(min(allRats.grandNSzpurple)));
 allRats.topMeanallNS = max(max(max(allRats.grandNSzblue)), max(max(allRats.grandNSzpurple)));


%Establish a shared bottom and top for shared color axis of DS & NS means
    if ~isnan(allRats.bottomMeanallNS) %if there is an NS
        allRats.bottomMeanallShared= min(allRats.bottomMeanallDS, allRats.bottomMeanallNS); %find the absolute min value
        allRats.topMeanallShared= max(allRats.topMeanallDS, allRats.topMeanallNS); %find the absolute min value
    else
        allRats.bottomMeanallShared= allRats.bottomMeanallDS;
        allRats.topMeanallShared= allRats.topMeanallDS;
    end
    
 %get list of session days for heatplot y axis
%  for day= 1:size(allRats.grandDSzblue,1)   
%     allRats.subjTrialDS(day,1)= day;
%  end

    subjTrial= 1:numel(allDates); %let's just number each training day starting at 1

 
%get list of NS session days for heatplot y axis
% need to loop through all subjects and sessions, find unique trials with NS data
allRats.subjTrialNS=[];
 for subj = 1:numel(subjectsAnalyzed)

    currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing
    for session = 1:numel(currentSubj) %for each training session this subject completed
        if ~isempty(currentSubj(session).periNS.NS) %if there's an NS trial in this session, add it to the array that will mark the y axis
%              allRats.subjTrialNS= cat(2, allRats.subjTrialNS, currentSubj(session).trainDay);
%              disp(currentSubj(session).trainDay);
        end
    end %end session loop
     
     
 end %end subj loop
   
%get only unique elements of subjTrialNS
% allRats.subjTrialNS= unique(allRats.subjTrialNS);

% HEATPLOT

 %DS z plot
    figure(figureCount);
    figureCount=figureCount+1;
    hold on;
    subplot(2,2,1); %subplot for shared colorbar

    %plot blue DS

    timeLock = [-preCueFrames:postCueFrames]/fs;% [-periDSFrames:periDSFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatDSzblueMeanall= imagesc(timeLock,subjTrial,allRats.grandDSzblue);
    title(' All rats avg blue z score response to DS '); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple DS (subplotted for shared colorbar)
    subplot(2,2,3);
    heatDSzpurpleMeanall= imagesc(timeLock,subjTrial,allRats.grandDSzpurple); 

    title(' All rats avg purple z score response to DS ') %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); 

    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values
    
%     %% TODO: try linspace with caxis

    c= colorbar; %colorbar legend
    c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving




    %     %NS z plot
    %         figure(figureCount-1); %subplotting on the same figure as the DS heatplots
    hold on;
    subplot(2,2,2); %subplot for shared colorbar

    timeLock = [-preCueFrames:postCueFrames]/fs;%[-periDSFrames:periDSFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

    heatNSzblueMeanall= imagesc(timeLock,subjTrial,allRats.grandNSzblue, 'AlphaData', ~isnan(allRats.grandNSzpurple));
    title(' All rats avg blue z score response to NS '); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
    xlabel('seconds from cue onset');
    ylabel('training day');
    set(gca, 'ytick', subjTrial); %label trials appropriately
    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');


    %   plot purple NS (subplotted for shared colorbar)
    subplot(2,2,4);
    heatNSzpurpleMean= imagesc(timeLock,subjTrial,allRats.grandNSzpurple, 'AlphaData', ~isnan(allRats.grandNSzpurple)); 

    title(' All rats avg purple z score response to NS ') %'(n= ', num2str(unique(trialDSnum)),')')); 
    xlabel('seconds from cue onset');
    ylabel('training day');

    set(gca, 'ytick', subjTrial); 
    caxis manual;
    caxis([allRats.bottomMeanallShared allRats.topMeanallShared]); %use a shared color axis to encompass all values

    c= colorbar; %colorbar legend
    c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');

    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

%% Between subjects response to cue on key transition sessions
%avg response timelocked to CUE on key transition sessions
%(e.g. first day of training, first day with NS, last day of stage 5

for subj= 1:numel(subjIncluded) %for each subject
       currentSubj= subjDataAnalyzed.(subjIncluded{subj}); %use this for easy indexing into the current subject within the struct

      %First, need to identify sessions that meet these conditions
       
%       %counter for sessions that meet each condition, reset between subjs
      sesCountA= 1;
      sesCountB= 1;
      sesCountC= 1;
      sesCountD= 1;
      
       for session = 1:numel(currentSubj) %for each training session this subject completed
            
           %cond A
           if currentSubj(session).trainStage==2 %condA= stage 2 sessions (rat13 missing stage1 data)
               %save training day label for this data 
                allRats(1).subjSessA(sesCountA,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountA= sesCountA+1;
           end %end conditional A

             %cond B
           if currentSubj(session).trainStage ==5 %condB= stage 5 sessions
               %save training day label for this data 
                allRats(1).subjSessB(sesCountB,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountB= sesCountB+1;
           end %end conditional B
           
               %cond C
           if currentSubj(session).trainStage==7 %condC = stage 7 sessions (full 1s delay between PE and pump on)
               %save training day label for this data 
                allRats(1).subjSessC(sesCountC,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountC= sesCountC+1;
           end %end conditional C
           
                %cond D
           if currentSubj(session).trainStage ==8 %condD = stage 8 sessions (any variable reward, should be refined by changing stage to reflect reward ID)
               %save training day label for this data 
                allRats(1).subjSessD(sesCountD,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountD= sesCountD+1;
           end %end conditional D
        end %end session loop

     %replace empty 0s with nans AND identify individual sessions for
     %plotting (instead of plotting them all)
        %the above code filled in blank training dates with 0 for photometry data (e.g. if 1 rat 
        %ran 12 days but others ran 9 days, the 3 days in between were 
        %filled with 0), let's make these = nan instead 
        
            %condA
        for ses = 1:size(allRats(1).subjSessA,1) %each row is a session
           if allRats(1).subjSessA(ses,subj)==0 %if there's no data for this date
              %make train day nan
              allRats(1).subjSessA(ses,subj)=nan;
           end
           
           if ses==1 %retain only the first stage 2 day
               allRats(1).stage2FirstSes(1,subj)= allRats(1).subjSessA(ses,subj); %get corresponding session, will be used to extract photometry data
               
               allRats(1).DSzblueMeanStage2FirstSes(1,:,subj)= currentSubj(allRats(1).stage2FirstSes(1,subj)).periDS.DSzblueMean'; %transposing for readability
               allRats(1).DSzpurpleMeanStage2FirstSes(1,:,subj)= currentSubj(allRats(1).stage2FirstSes(1,subj)).periDS.DSzpurpleMean';
           end 
        end
        
            %condB
         for ses = 1:size(allRats(1).subjSessB,1) %each row is a session
           if allRats(1).subjSessB(ses,subj)==0 %if there's no data for this date
              %make train day nan
              allRats(1).subjSessB(ses,subj)=nan;
           end
           
           if ses==1 %retain the first and last stage 5 day
               allRats(1).stage5FirstSes(1,subj)= allRats(1).subjSessB(ses,subj);
               allRats(1).stage5LastSes(1,subj)= max(allRats(1).subjSessB(:,subj));
               
               allRats(1).DSzblueMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periDS.DSzblueMean';
               allRats(1).NSzblueMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periNS.NSzblueMean';
               allRats(1).DSzpurpleMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periDS.DSzpurpleMean';
               allRats(1).NSzpurpleMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periNS.NSzpurpleMean';
               
               allRats(1).DSzblueMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periDS.DSzblueMean';
               allRats(1).NSzblueMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periNS.NSzblueMean';
               allRats(1).DSzpurpleMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periDS.DSzpurpleMean';
               allRats(1).NSzpurpleMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periNS.NSzpurpleMean';
               
           end
           
         end
         
           %condC
         for ses = 1:size(allRats(1).subjSessC,1) %each row is a session
           if allRats(1).subjSessC(ses,subj)==0 %if there's no data for this date
              %make train day nan
              allRats(1).subjSessC(ses,subj)=nan;
           end
           
           if ses==1 %retain the first and last stage 7 day
              allRats(1).stage7FirstSes(1,subj)= allRats(1).subjSessC(ses,subj);
              allRats(1).stage7LastSes(1,subj)=max(allRats(1).subjSessC(:,subj));
              
              allRats(1).DSzblueMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periDS.DSzblueMean';
              allRats(1).NSzblueMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periNS.NSzblueMean';
              allRats(1).DSzpurpleMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periDS.DSzpurpleMean';
              allRats(1).NSzpurpleMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periNS.NSzpurpleMean';
              
              allRats(1).DSzblueMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periDS.DSzblueMean';
              allRats(1).NSzblueMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periNS.NSzblueMean';
              allRats(1).DSzpurpleMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periDS.DSzpurpleMean';
              allRats(1).NSzpurpleMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periNS.NSzpurpleMean';
           end
           
         end
           %condD 
         for ses = 1:size(allRats(1).subjSessD,1) %each row is a session
           if allRats(1).subjSessD(ses,subj)==0 %if there's no data for this date
              %make train day nan`
              allRats(1).subjSessD(ses,subj)=nan;
           end
           
           if ses==1 %retain the first and last stage 8 days (last is extinction for vp-vta-fpround2)
               allRats(1).stage8FirstSes(1,subj)= allRats(1).subjSessD(ses,subj);
               allRats(1).extinctionLastSes(1,subj)= max(allRats(1).subjSessD(:,subj));
               
              allRats(1).DSzblueMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periDS.DSzblueMean';
              allRats(1).NSzblueMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periNS.NSzblueMean';
              allRats(1).DSzpurpleMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periDS.DSzpurpleMean';
              allRats(1).NSzpurpleMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periNS.NSzpurpleMean';
              
              allRats(1).DSzblueMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periDS.DSzblueMean';
              allRats(1).NSzblueMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periNS.NSzblueMean';
              allRats(1).DSzpurpleMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periDS.DSzpurpleMean';
              allRats(1).NSzpurpleMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periNS.NSzpurpleMean';
               
           end
         end
end %end subj loop
         


 % now get mean of all rats for these transition sessions (each column is a training day , each 3d page is a subject)

    %stage 2
 allRats.grandMeanDSzblueStage2FirstSes=nanmean(allRats.DSzblueMeanStage2FirstSes,3);
 allRats.grandMeanDSzpurpleStage2FirstSes=nanmean(allRats.DSzpurpleMeanStage2FirstSes,3);

    %stage 5
allRats(1).grandMeanDSzblueStage5FirstSes= nanmean(allRats.DSzblueMeanStage5FirstSes,3);
allRats(1).grandMeanNSzblueStage5FirstSes= nanmean(allRats.NSzblueMeanStage5FirstSes,3);
allRats(1).grandMeanDSzpurpleStage5FirstSes= nanmean(allRats.DSzpurpleMeanStage5FirstSes,3);
allRats(1).grandMeanNSzpurpleStage5FirstSes= nanmean(allRats.NSzpurpleMeanStage5FirstSes,3);

allRats(1).grandMeanDSzblueStage5LastSes= nanmean(allRats.DSzblueMeanStage5LastSes,3);
allRats(1).grandMeanNSzblueStage5LastSes= nanmean(allRats.NSzblueMeanStage5LastSes,3);
allRats(1).grandMeanDSzpurpleStage5LastSes= nanmean(allRats.DSzpurpleMeanStage5LastSes,3);
allRats(1).grandMeanNSzpurpleStage5LastSes= nanmean(allRats.NSzpurpleMeanStage5LastSes,3);
    
    %stage 7
allRats(1).grandMeanDSzblueStage7FirstSes= nanmean(allRats.DSzblueMeanStage7FirstSes,3);
allRats(1).grandMeanNSzblueStage7FirstSes= nanmean(allRats.NSzblueMeanStage7FirstSes,3);
allRats(1).grandMeanDSzpurpleStage7FirstSes= nanmean(allRats.DSzpurpleMeanStage7FirstSes,3);
allRats(1).grandMeanNSzpurpleStage7FirstSes= nanmean(allRats.NSzpurpleMeanStage7FirstSes,3);

allRats(1).grandMeanDSzblueStage7LastSes= nanmean(allRats.DSzblueMeanStage7LastSes,3);
allRats(1).grandMeanNSzblueStage7LastSes= nanmean(allRats.NSzblueMeanStage7LastSes,3);
allRats(1).grandMeanDSzpurpleStage7LastSes= nanmean(allRats.DSzpurpleMeanStage7LastSes,3);
allRats(1).grandMeanNSzpurpleStage7LastSes= nanmean(allRats.NSzpurpleMeanStage7LastSes,3);    
 
    %stage 8
allRats(1).grandMeanDSzblueStage8FirstSes= nanmean(allRats.DSzblueMeanStage8FirstSes,3);
allRats(1).grandMeanNSzblueStage8FirstSes= nanmean(allRats.NSzblueMeanStage8FirstSes,3);
allRats(1).grandMeanDSzpurpleStage8FirstSes= nanmean(allRats.DSzpurpleMeanStage8FirstSes,3);
allRats(1).grandMeanNSzpurpleStage8FirstSes= nanmean(allRats.NSzpurpleMeanStage8FirstSes,3);

allRats(1).grandMeanDSzblueExtinctionLastSes= nanmean(allRats.DSzblueMeanExtinctionLastSes,3);
allRats(1).grandMeanNSzblueExtinctionLastSes= nanmean(allRats.NSzblueMeanExtinctionLastSes,3);
allRats(1).grandMeanDSzpurpleExtinctionLastSes= nanmean(allRats.DSzpurpleMeanExtinctionLastSes,3);
allRats(1).grandMeanNSzpurpleExtinctionLastSes= nanmean(allRats.NSzpurpleMeanExtinctionLastSes,3);  


% Now, 2d plots 
figure(figureCount);
figureCount= figureCount+1;

sgtitle('Between subjects (n=5) avg response to cue on transition days')

subplot(2,7,1);
title('DS stage 2 first day');
hold on;
plot(timeLock,allRats(1).grandMeanDSzblueStage2FirstSes, 'b');
plot(timeLock,allRats(1).grandMeanDSzpurpleStage2FirstSes, 'm');

subplot(2,7,2);
title('DS stage 5 first day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzblueStage5FirstSes,'b');
plot(timeLock, allRats(1).grandMeanDSzpurpleStage5FirstSes,'m');

subplot(2,7,3);
title('DS stage 5 last day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzblueStage5LastSes,'b');
plot(timeLock, allRats(1).grandMeanDSzpurpleStage5LastSes,'m');

subplot(2,7,4);
title('DS stage 7 first day (1s delay)');
hold on;
plot(timeLock, allRats(1).grandMeanDSzblueStage7FirstSes,'b');
plot(timeLock, allRats(1).grandMeanDSzpurpleStage7FirstSes,'m');

subplot(2,7,5);
title('DS stage 7 last day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzblueStage7LastSes, 'b');
plot(timeLock, allRats(1).grandMeanDSzpurpleStage7LastSes,'m');

subplot(2,7,6);
title('DS stage 8 first day (variable reward)');
hold on;
plot(timeLock, allRats(1).grandMeanDSzblueStage8FirstSes, 'b');
plot(timeLock, allRats(1).grandMeanDSzpurpleStage8FirstSes,'m');

subplot(2,7,7);
title('DS extinction last day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzblueExtinctionLastSes, 'b');
plot(timeLock, allRats(1).grandMeanDSzpurpleExtinctionLastSes,'m');



subplot(2,7,8);
title('no NS on stage 2');
hold on;

subplot(2,7,9);
title('NS stage 5 first day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzblueStage5FirstSes,'b');
plot(timeLock, allRats(1).grandMeanNSzpurpleStage5FirstSes,'m');

subplot(2,7,10);
title('NS stage 5 last day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzblueStage5LastSes,'b');
plot(timeLock, allRats(1).grandMeanNSzpurpleStage5LastSes,'m');

subplot(2,7,11);
title('NS stage 7 first day (1s delay)');
hold on;
plot(timeLock, allRats(1).grandMeanNSzblueStage7FirstSes,'b');
plot(timeLock, allRats(1).grandMeanNSzpurpleStage7FirstSes,'m');

subplot(2,7,12);
title('NS stage 7 last day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzblueStage7LastSes, 'b');
plot(timeLock, allRats(1).grandMeanNSzpurpleStage7LastSes,'m');

subplot(2,7,13);
title('NS stage 8 first day (variable reward)');
hold on;
plot(timeLock, allRats(1).grandMeanNSzblueStage8FirstSes, 'b');
plot(timeLock, allRats(1).grandMeanNSzpurpleStage8FirstSes,'m');

subplot(2,7,14);
title('NS extinction last day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzblueExtinctionLastSes, 'b');
plot(timeLock, allRats(1).grandMeanNSzpurpleExtinctionLastSes,'m');


%equalize the axes and link them together for examination
linkaxes;

set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen


%% Between subjects response to FIRST PE after cue on key transition sessions
%avg response timelocked to FIRST PE on key transition sessions
%(e.g. first day of training, first day with NS, last day of stage 5

for subj= 1:numel(subjIncluded) %for each subject
       currentSubj= subjDataAnalyzed.(subjIncluded{subj}); %use this for easy indexing into the current subject within the struct

      %First, need to identify sessions that meet these conditions
       
%       %counter for sessions that meet each condition, reset between subjs
      sesCountA= 1;
      sesCountB= 1;
      sesCountC= 1;
      sesCountD= 1;
      sesCountE= 1;
      
       for session = 1:numel(currentSubj) %for each training session this subject completed
            
           %cond A
           if currentSubj(session).trainStage==2 %condA= stage 2 sessions (rat13 missing stage1 data)
               %save training day label for this data 
                allRats(1).subjSessA(sesCountA,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountA= sesCountA+1;
           end %end conditional A

             %cond B
           if currentSubj(session).trainStage ==5 %condB= stage 5 sessions
               %save training day label for this data 
                allRats(1).subjSessB(sesCountB,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountB= sesCountB+1;
           end %end conditional B
           
               %cond C
           if currentSubj(session).trainStage==7 %condC = stage 7 sessions (full 1s delay between PE and pump on)
               %save training day label for this data 
                allRats(1).subjSessC(sesCountC,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountC= sesCountC+1;
           end %end conditional C
           
                %cond D
           if currentSubj(session).trainStage ==8 %condD = stage 8 sessions (any variable reward, should be refined by changing stage to reflect reward ID)
               %save training day label for this data 
                allRats(1).subjSessD(sesCountD,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountD= sesCountD+1;
           end %end conditional D        
        
                %cond E
           if currentSubj(session).trainStage ==9 %condE = Extinction (stage 9)
               %save training day label for this data 
                allRats(1).subjSessE(sesCountE,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountE= sesCountE+1;
           end %end conditional E
        end %end session loop
        

     %Translate the training days saved above into an index based on the
     %file order (critical step- if a subject is missing a file then the
     %training day can't be used as an index bc it will pull incorrect
     %data)
     
        for transitionSession= 1:size(allRats.subjSessA,1)
             if allRats(1).subjSessA(transitionSession,subj) ~= 0 && ~isnan(allRats(1).subjSessA(transitionSession,subj))
                 %search the trainDay field by vectorizing it [] and get its index using find() 
                 allRats(1).subjSessA(transitionSession,subj)= find([currentSubj.trainDay]==allRats(1).subjSessA(transitionSession,subj));
             end
         end
     
        for transitionSession= 1:size(allRats.subjSessB,1)
             if allRats(1).subjSessB(transitionSession,subj) ~= 0 && ~isnan(allRats(1).subjSessB(transitionSession,subj))
                 %search the trainDay field by vectorizing it [] and get its index using find() 
                 allRats(1).subjSessB(transitionSession,subj)= find([currentSubj.trainDay]==allRats(1).subjSessB(transitionSession,subj));
             end
         end
     
        for transitionSession= 1:size(allRats.subjSessC,1)
             if allRats(1).subjSessC(transitionSession,subj) ~= 0 && ~isnan(allRats(1).subjSessC(transitionSession,subj))
                 %search the trainDay field by vectorizing it [] and get its index using find() 
                 allRats(1).subjSessC(transitionSession,subj)= find([currentSubj.trainDay]==allRats(1).subjSessC(transitionSession,subj));
             end
         end
     
        for transitionSession= 1:size(allRats.subjSessD,1)
             if allRats(1).subjSessD(transitionSession,subj) ~= 0 && ~isnan(allRats(1).subjSessD(transitionSession,subj))
                 %search the trainDay field by vectorizing it [] and get its index using find() 
                 allRats(1).subjSessD(transitionSession,subj)= find([currentSubj.trainDay]==allRats(1).subjSessD(transitionSession,subj));
             end
         end
     
         for transitionSession= 1:size(allRats.subjSessE,1)
             if allRats(1).subjSessE(transitionSession,subj) ~= 0 && ~isnan(allRats(1).subjSessE(transitionSession,subj))
                 %search the trainDay field by vectorizing it [] and get its index using find() 
                 allRats(1).subjSessE(transitionSession,subj)= find([currentSubj.trainDay]==allRats(1).subjSessE(transitionSession,subj));
             end
         end

     %replace empty 0s with nans AND identify individual sessions for
     %plotting (instead of plotting them all)
        %the above code filled in blank training dates with 0 for photometry data (e.g. if 1 rat 
        %ran 12 days but others ran 9 days, the 3 days in between were 
        %filled with 0), let's make these = nan instead 
        
            %condA
        allRats(1).subjSessA(allRats(1).subjSessA==0)=nan; %if there's no data for this date just make it nan

        for ses = 1:size(allRats(1).subjSessA,1) %each row is a session
           if ses==1 %retain only the first stage 2 day
               allRats(1).stage2FirstSes(1,subj)= allRats(1).subjSessA(ses,subj); %get corresponding session, will be used to extract photometry data
               
               allRats(1).DSzpoxblueMeanStage2FirstSes(1,:,subj)= currentSubj(allRats(1).stage2FirstSes(1,subj)).periDSpox.DSzpoxblueMean'; %transposing for readability
               allRats(1).DSzpoxpurpleMeanStage2FirstSes(1,:,subj)= currentSubj(allRats(1).stage2FirstSes(1,subj)).periDSpox.DSzpoxpurpleMean';
           end 
        end
        
            %condB
         allRats(1).subjSessB(allRats(1).subjSessB==0)=nan; %if there's no data for this date just make it nan
         
         for ses = 1:size(allRats(1).subjSessB,1) %each row is a session           
           if ses==1 %retain the first and last stage 5 day
               allRats(1).stage5FirstSes(1,subj)= allRats(1).subjSessB(ses,subj);
               allRats(1).stage5LastSes(1,subj)= max(allRats(1).subjSessB(:,subj));
               
               allRats(1).DSzpoxblueMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periDSpox.DSzpoxblueMean';
               allRats(1).NSzpoxblueMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periNSpox.NSzpoxblueMean';
               allRats(1).DSzpoxpurpleMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periDSpox.DSzpoxpurpleMean';
               allRats(1).NSzpoxpurpleMeanStage5FirstSes(1,:,subj)= currentSubj(allRats(1).stage5FirstSes(1,subj)).periNSpox.NSzpoxpurpleMean';
               
               allRats(1).DSzpoxblueMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periDSpox.DSzpoxblueMean';
               allRats(1).NSzpoxblueMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periNSpox.NSzpoxblueMean';
               allRats(1).DSzpoxpurpleMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periDSpox.DSzpoxpurpleMean';
               allRats(1).NSzpoxpurpleMeanStage5LastSes(1,:,subj)= currentSubj(allRats(1).stage5LastSes(1,subj)).periNSpox.NSzpoxpurpleMean';
               
           end
           
         end
         
           %condC
         allRats(1).subjSessC(allRats(1).subjSessC==0)=nan; %if there's no data for this date just make it nan
         for ses = 1:size(allRats(1).subjSessC,1) %each row is a session\     
           if ses==1 %retain the first and last stage 7 day
              allRats(1).stage7FirstSes(1,subj)= allRats(1).subjSessC(ses,subj);
              allRats(1).stage7LastSes(1,subj)=max(allRats(1).subjSessC(:,subj));
              
              allRats(1).DSzpoxblueMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periDSpox.DSzpoxblueMean';
              allRats(1).NSzpoxblueMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periNSpox.NSzpoxblueMean';
              allRats(1).DSzpoxpurpleMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periDSpox.DSzpoxpurpleMean';
              allRats(1).NSzpoxpurpleMeanStage7FirstSes(1,:,subj)= currentSubj(allRats(1).stage7FirstSes(1,subj)).periNSpox.NSzpoxpurpleMean';
              
              allRats(1).DSzpoxblueMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periDSpox.DSzpoxblueMean';
              allRats(1).NSzpoxblueMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periNSpox.NSzpoxblueMean';
              allRats(1).DSzpoxpurpleMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periDSpox.DSzpoxpurpleMean';
              allRats(1).NSzpoxpurpleMeanStage7LastSes(1,:,subj)= currentSubj(allRats(1).stage7LastSes(1,subj)).periNSpox.NSzpoxpurpleMean';
           end
           
         end
           %condD 
        allRats(1).subjSessD(allRats(1).subjSessD==0)=nan; %if there's no data for this date just make it nan
        for ses = 1:size(allRats(1).subjSessD,1) %each row is a session           
           if ses==1 %retain the first and last stage 8 days (last is extinction for vp-vta-fpround2)
               allRats(1).stage8FirstSes(1,subj)= allRats(1).subjSessD(ses,subj);
               
              allRats(1).DSzpoxblueMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periDSpox.DSzpoxblueMean';
              allRats(1).NSzpoxblueMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periNSpox.NSzpoxblueMean';
              allRats(1).DSzpoxpurpleMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periDSpox.DSzpoxpurpleMean';
              allRats(1).NSzpoxpurpleMeanStage8FirstSes(1,:,subj)= currentSubj(allRats(1).stage8FirstSes(1,subj)).periNSpox.NSzpoxpurpleMean';
               
           end
         end
         
               %condE 
         allRats(1).subjSessE(allRats(1).subjSessE==0)=nan; %if there's no data for this date just make it nan
         for ses = 1:size(allRats(1).subjSessE,1) %each row is a session
           if ses==1 %retain the last extinction day
              allRats(1).extinctionLastSes(1,subj)= max(allRats(1).subjSessE(:,subj)); %critical step- get the right indices in case files are missing
               
              allRats(1).DSzpoxblueMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periDSpox.DSzpoxblueMean';
              allRats(1).NSzpoxblueMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periNSpox.NSzpoxblueMean';
              allRats(1).DSzpoxpurpleMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periDSpox.DSzpoxpurpleMean';
              allRats(1).NSzpoxpurpleMeanExtinctionLastSes(1,:,subj)= currentSubj(allRats(1).extinctionLastSes(1,subj)).periNSpox.NSzpoxpurpleMean';
               
           end
         end
         
end %end subj loop
         


 % now get mean & SEM of all rats for these transition sessions (each column is a training day , each 3d page is a subject)
       
    %stage 2
 allRats.grandMeanDSzpoxblueStage2FirstSes=nanmean(allRats.DSzpoxblueMeanStage2FirstSes,3);
 allRats.grandMeanDSzpoxpurpleStage2FirstSes=nanmean(allRats.DSzpoxpurpleMeanStage2FirstSes,3);
 
    %stage 5
allRats(1).grandMeanDSzpoxblueStage5FirstSes= nanmean(allRats.DSzpoxblueMeanStage5FirstSes,3);
allRats(1).grandMeanNSzpoxblueStage5FirstSes= nanmean(allRats.NSzpoxblueMeanStage5FirstSes,3);
allRats(1).grandMeanDSzpoxpurpleStage5FirstSes= nanmean(allRats.DSzpoxpurpleMeanStage5FirstSes,3);
allRats(1).grandMeanNSzpoxpurpleStage5FirstSes= nanmean(allRats.NSzpoxpurpleMeanStage5FirstSes,3);

allRats(1).grandMeanDSzpoxblueStage5LastSes= nanmean(allRats.DSzpoxblueMeanStage5LastSes,3);
allRats(1).grandMeanNSzpoxblueStage5LastSes= nanmean(allRats.NSzpoxblueMeanStage5LastSes,3);
allRats(1).grandMeanDSzpoxpurpleStage5LastSes= nanmean(allRats.DSzpoxpurpleMeanStage5LastSes,3);
allRats(1).grandMeanNSzpoxpurpleStage5LastSes= nanmean(allRats.NSzpoxpurpleMeanStage5LastSes,3);
    
    %stage 7
allRats(1).grandMeanDSzpoxblueStage7FirstSes= nanmean(allRats.DSzpoxblueMeanStage7FirstSes,3);
allRats(1).grandMeanNSzpoxblueStage7FirstSes= nanmean(allRats.NSzpoxblueMeanStage7FirstSes,3);
allRats(1).grandMeanDSzpoxpurpleStage7FirstSes= nanmean(allRats.DSzpoxpurpleMeanStage7FirstSes,3);
allRats(1).grandMeanNSzpoxpurpleStage7FirstSes= nanmean(allRats.NSzpoxpurpleMeanStage7FirstSes,3);

allRats(1).grandMeanDSzpoxblueStage7LastSes= nanmean(allRats.DSzpoxblueMeanStage7LastSes,3);
allRats(1).grandMeanNSzpoxblueStage7LastSes= nanmean(allRats.NSzpoxblueMeanStage7LastSes,3);
allRats(1).grandMeanDSzpoxpurpleStage7LastSes= nanmean(allRats.DSzpoxpurpleMeanStage7LastSes,3);
allRats(1).grandMeanNSzpoxpurpleStage7LastSes= nanmean(allRats.NSzpoxpurpleMeanStage7LastSes,3);    
 
    %stage 8
allRats(1).grandMeanDSzpoxblueStage8FirstSes= nanmean(allRats.DSzpoxblueMeanStage8FirstSes,3);
allRats(1).grandMeanNSzpoxblueStage8FirstSes= nanmean(allRats.NSzpoxblueMeanStage8FirstSes,3);
allRats(1).grandMeanDSzpoxpurpleStage8FirstSes= nanmean(allRats.DSzpoxpurpleMeanStage8FirstSes,3);
allRats(1).grandMeanNSzpoxpurpleStage8FirstSes= nanmean(allRats.NSzpoxpurpleMeanStage8FirstSes,3);

allRats(1).grandMeanDSzpoxblueExtinctionLastSes= nanmean(allRats.DSzpoxblueMeanExtinctionLastSes,3);
allRats(1).grandMeanNSzpoxblueExtinctionLastSes= nanmean(allRats.NSzpoxblueMeanExtinctionLastSes,3);
allRats(1).grandMeanDSzpoxpurpleExtinctionLastSes= nanmean(allRats.DSzpoxpurpleMeanExtinctionLastSes,3);
allRats(1).grandMeanNSzpoxpurpleExtinctionLastSes= nanmean(allRats.NSzpoxpurpleMeanExtinctionLastSes,3);  


 %also, get standard error (SEM)
    %should this be based on std of each animals avg from the between subj
    %avg(avg of all avgs)? then divided by the number of subjects?
allRats(1).grandStdDSzpoxblueStage2FirstSes= std(allRats.DSzpoxblueMeanStage2FirstSes,0,3);
allRats(1).grandSEMDSzpoxblueStage2FirstSes= allRats(1).grandStdDSzpoxblueStage2FirstSes/sqrt(numel(subjIncluded));
    

% Now, 2d plots 
figure(figureCount);
figureCount= figureCount+1;

sgtitle('Between subjects (n=5) avg response to FIRST PE after cue on transition days')

subplot(2,7,1);
title('DS stage 2 first day');
hold on;
plot(timeLock,allRats(1).grandMeanDSzpoxblueStage2FirstSes, 'b');
plot(timeLock,allRats(1).grandMeanDSzpoxpurpleStage2FirstSes, 'm');

plot(timeLock, allRats(1).grandMeanDSzpoxblueStage2FirstSes+allRats(1).grandSEMDSzpoxblueStage2FirstSes, 'k--');
plot(timeLock, allRats(1).grandMeanDSzpoxblueStage2FirstSes-allRats(1).grandSEMDSzpoxblueStage2FirstSes, 'k--');

subplot(2,7,2);
title('DS stage 5 first day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzpoxblueStage5FirstSes,'b');
plot(timeLock, allRats(1).grandMeanDSzpoxpurpleStage5FirstSes,'m');

subplot(2,7,3);
title('DS stage 5 last day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzpoxblueStage5LastSes,'b');
plot(timeLock, allRats(1).grandMeanDSzpoxpurpleStage5LastSes,'m');

subplot(2,7,4);
title('DS stage 7 first day (1s delay)');
hold on;
plot(timeLock, allRats(1).grandMeanDSzpoxblueStage7FirstSes,'b');
plot(timeLock, allRats(1).grandMeanDSzpoxpurpleStage7FirstSes,'m');

subplot(2,7,5);
title('DS stage 7 last day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzpoxblueStage7LastSes, 'b');
plot(timeLock, allRats(1).grandMeanDSzpoxpurpleStage7LastSes,'m');

subplot(2,7,6);
title('DS stage 8 first day (variable reward)');
hold on;
plot(timeLock, allRats(1).grandMeanDSzpoxblueStage8FirstSes, 'b');
plot(timeLock, allRats(1).grandMeanDSzpoxpurpleStage8FirstSes,'m');

subplot(2,7,7);
title('DS extinction last day');
hold on;
plot(timeLock, allRats(1).grandMeanDSzpoxblueExtinctionLastSes, 'b');
plot(timeLock, allRats(1).grandMeanDSzpoxpurpleExtinctionLastSes,'m');



subplot(2,7,8);
title('no NS on stage 2');
hold on;

subplot(2,7,9);
title('NS stage 5 first day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzpoxblueStage5FirstSes,'b');
plot(timeLock, allRats(1).grandMeanNSzpoxpurpleStage5FirstSes,'m');

subplot(2,7,10);
title('NS stage 5 last day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzpoxblueStage5LastSes,'b');
plot(timeLock, allRats(1).grandMeanNSzpoxpurpleStage5LastSes,'m');

subplot(2,7,11);
title('NS stage 7 first day (1s delay)');
hold on;
plot(timeLock, allRats(1).grandMeanNSzpoxblueStage7FirstSes,'b');
plot(timeLock, allRats(1).grandMeanNSzpoxpurpleStage7FirstSes,'m');

subplot(2,7,12);
title('NS stage 7 last day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzpoxblueStage7LastSes, 'b');
plot(timeLock, allRats(1).grandMeanNSzpoxpurpleStage7LastSes,'m');

subplot(2,7,13);
title('NS stage 8 first day (variable reward)');
hold on;
plot(timeLock, allRats(1).grandMeanNSzpoxblueStage8FirstSes, 'b');
plot(timeLock, allRats(1).grandMeanNSzpoxpurpleStage8FirstSes,'m');

subplot(2,7,14);
title('NS extinction last day');
hold on;
plot(timeLock, allRats(1).grandMeanNSzpoxblueExtinctionLastSes, 'b');
plot(timeLock, allRats(1).grandMeanNSzpoxpurpleExtinctionLastSes,'m');


%equalize the axes and link them together for examination
linkaxes;

set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen




%% ~~ Data vis- photometry & behavior ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Scatter of cue-elicited response vs. port entry probability (does cue elicited response predict PE?)

%first set parameters
cueResponseFrames=1*fs; %time after cue over which to take avg activity 
cueOnsetFrame= (periCueFrames-postCueFrames)+1;

for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    for session= 1:numel(currentSubj)

        for cue = 1:numel(currentSubj(session).behavior.poxDS)
            
        end
        
    end %end session loop
end %end subj loop
    
%% Scatter of cue-elicited response vs. port entry latency
%This only includes trials that had a valid PE

%first set parameters
cueResponseFrames=1*fs; %time after cue over which to take avg activity 
cueOnsetFrame= (periCueFrames-postCueFrames)+1;

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
    %initialize/clear arrays between subjects
    currentSubj(1).NSzblueAllTrials= [];
    currentSubj(1).NSzpurpleAllTrials= [];
    currentSubj(1).NSpeLatencyAllTrials= [];

    sesCountA= 1;
    sesCountB= 1;
    sesCountC= 1;
    sesCountD=1;

    subjSessA= [];
    subjSessB= [];
    subjSessC= [];
    subjSessD= [];
    
    trialAcount= 1;
    trialBcount=1;
    trialCcount=1;
    trialDcount=1;
    
    trialBNScount=1;
    trialCNScount=1;
    trialDNScount=1;
    
    DSloxAllTrialsA = [];
    DSloxAllTrialsB= [];
    DSloxAllTrialsC= [];
    DSloxAllTrialsD= [];
    
    NSloxAllTrialsA= [];
    NSloxAllTrialsB= [];
    NSloxAllTrialsC= [];
    NSloxAllTrialsD= [];
    
    for session = 1:numel(currentSubj) %for each training session this subject completed
       
        clear NSselected
        
        %We can only include trials that have a PE latency, so we need to
        %selectively extract these data first
        
            %get the DS cues
        DSselected= currentSubj(session).periDS.DS;  % all the DS cues

        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
            
        %We have to throw in an extra conditional in case we've excluded
        %cues in our peri cue analysis due to being too close to the
        %beginning or end. Otherwise, we can get an out of range error
        %because the inPortDS array doesn't exclude these cues.
        for inPortTrial = find(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS))
            if inPortTrial < numel(DSselected) 
                DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;
            end
        end
        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        
        %same here, we need an extra conditional in case cues were excluded
        for noPEtrial = find(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS))
            if noPEtrial < numel(DSselected)
                DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
            end
        end
        
        %this may create some zeros, so let's make those nan as well
        DSselected(DSselected==0) = nan;
        
        %lets convert this to an index of trials with a valid value 
        DSselected= find(~isnan(DSselected));
        
            %Repeat above for NS 
        if ~isempty(currentSubj(session).periNS.NS)
             NSselected= currentSubj(session).periNS.NS;  

            %First, let's exclude trials where animal was already in port
            %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
            %have a non-nan value and use these to exclude NS trials from this
            %analysis (we'll make them nan)

            NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

            %Then, let's exclude trials where animal didn't make a PE during
            %the cue epoch. To do so, get indices of empty cells in
            %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
            %happened during the cue epoch) and then use these to set that NS =
            %nan
            NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;

       
            %lets convert this to an index of trials with a valid value 
            NSselected= find(~isnan(NSselected));
        end %end NS conditional       
        
        %Condition A
            if currentSubj(session).trainStage <5
                if sesCountA== 1 
                    currentSubj(1).DSzblueAllTrialsA= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                    currentSubj(1).DSzpurpleAllTrialsA= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                    currentSubj(1).DSpeLatencyAllTrialsA= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                    
%                     currentSubj(1).DSloxAllTrialsA= currentSubj(session).behavior.loxDS{DSselected};
                    if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                        currentSubj(1).NSzblueAllTrialsA= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
                        currentSubj(1).NSzpurpleAllTrialsA= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
                        currentSubj(1).NSpeLatencyAllTrialsA= currentSubj(session).behavior.NSpeLatency(NSselected); 
                        
                     else
%                        continue %continue if no NS data
                     end
                else %add subsequent sessions using cat()
                    currentSubj(1).DSzblueAllTrialsA = cat(2, currentSubj.DSzblueAllTrialsA, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                    currentSubj(1).DSzpurpleAllTrialsA = cat(2, currentSubj.DSzpurpleAllTrialsA, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                    currentSubj(1).DSpeLatencyAllTrialsA = cat(2,currentSubj(1).DSpeLatencyAllTrialsA,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

%                     currentSubj(1).DSloxAllTrialsA= cat(2,currentSubj(1).DSloxAllTrialsA,currentSubj(session).behavior.loxDS{DSselected});

                    if ~isempty(currentSubj(session).periNS.NS)
                        currentSubj(1).NSzblueAllTrialsA = cat(2, currentSubj.NSzblueAllTrialsA, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                        currentSubj(1).NSzpurpleAllTrialsA = cat(2, currentSubj.NSzpurpleAllTrialsA, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                        currentSubj(1).NSpeLatencyAllTrialsA = cat(2,currentSubj(1).NSpeLatencyAllTrialsA,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                    else
%                         continue %continue if no NS data
                    end
                end %end sesCount conditional

                    % licks
                    currentSubj(1).DSloxAllTrialsA{sesCountA}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
                
                     %in order to sort licks according to trial by PE latency
                     %later, we need to reshape the lox cell array from nested
                     %{session}{cue} to just {cue}
                      for cue = 1:numel(currentSubj(1).DSloxAllTrialsA{session})
                          DSloxAllTrialsA{trialAcount} = currentSubj(1).DSloxAllTrialsA{session}{cue};
                          trialAcount=trialAcount+1;
                      end           

%                       trialAcount=1; %reset counter
%                       % NS licks
%                     currentSubj(1).NSloxAllTrialsA{session}= currentSubj(session).behavior.loxNSrel(NSselected);
%                     
%                     for cue= 1:numel(currentSubj(1).NSloxAllTrialsA{session})
%                         NSloxAllTrialsA{trialAcount}= currentSubj(1).NSloxAllTrialsA{session}{cue};
%                         trialAcount=trialAcount+1;
%                     end
%                         
                      
                sesCountA= sesCountA+1;
                subjSessA= cat(2, subjSessA, currentSubj(session).trainDay); %day count for y axis

            end %end Cond A
            
            %Condition B
                   if currentSubj(session).trainStage ==5
                        if sesCountB== 1 
                            currentSubj(1).DSzblueAllTrialsB= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                            currentSubj(1).DSzpurpleAllTrialsB= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                            currentSubj(1).DSpeLatencyAllTrialsB= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                             if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                                currentSubj(1).NSzblueAllTrialsB= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
                                currentSubj(1).NSzpurpleAllTrialsB= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
                                currentSubj(1).NSpeLatencyAllTrialsB= currentSubj(session).behavior.NSpeLatency(NSselected); 
                             else
%                                continue %continue if no NS data
                             end
                        else %add subsequent sessions using cat()
                            currentSubj(1).DSzblueAllTrialsB = cat(2, currentSubj.DSzblueAllTrialsB, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                            currentSubj(1).DSzpurpleAllTrialsB = cat(2, currentSubj.DSzpurpleAllTrialsB, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                            currentSubj(1).DSpeLatencyAllTrialsB = cat(2,currentSubj(1).DSpeLatencyAllTrialsB,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

                            if ~isempty(currentSubj(session).periNS.NS)
                                currentSubj(1).NSzblueAllTrialsB = cat(2, currentSubj.NSzblueAllTrialsB, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                                currentSubj(1).NSzpurpleAllTrialsB = cat(2, currentSubj.NSzpurpleAllTrialsB, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                                currentSubj(1).NSpeLatencyAllTrialsB = cat(2,currentSubj(1).NSpeLatencyAllTrialsB,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                            else
%                                 continue %continue if nos NS data
                            end
                        end %end sesCount conditional

                        
                         %licks
                        currentSubj(1).DSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset

                        currentSubj(1).NSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxNSrel(NSselected);

                        
                         %in order to sort licks according to trial by PE latency
                         %later, we need to reshape the lox cell array from nested
                         %{session}{cue} to just {cue}
                          for cue = 1:numel(currentSubj(1).DSloxAllTrialsB{sesCountB})
                              DSloxAllTrialsB{trialBcount} = currentSubj(1).DSloxAllTrialsB{sesCountB}{cue};
                              trialBcount=trialBcount+1;
                          end           
                                            
                        for cue= 1:numel(currentSubj(1).NSloxAllTrialsB{sesCountB})
                            NSloxAllTrialsB{trialBNScount}= currentSubj(1).NSloxAllTrialsB{sesCountB}{cue};
                            trialBNScount=trialBNScount+1;
                        end

                        
                        sesCountB= sesCountB+1;
                        subjSessB= cat(2, subjSessB, currentSubj(session).trainDay); %day count for y axis

                  end %end Cond B
                  
              %Condition C
               if currentSubj(session).trainStage== 6 || currentSubj(session).trainStage ==7
                   
                    if sesCountC== 1 
                        currentSubj(1).DSzblueAllTrialsC= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                        currentSubj(1).DSzpurpleAllTrialsC= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                        currentSubj(1).DSpeLatencyAllTrialsC= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                         if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                            currentSubj(1).NSzblueAllTrialsC= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
                            currentSubj(1).NSzpurpleAllTrialsC= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
                            currentSubj(1).NSpeLatencyAllTrialsC= currentSubj(session).behavior.NSpeLatency(NSselected); 
                         else
%                            continue %continue if no NS data
                         end
                    else %add subsequent sessions using cat()
                        currentSubj(1).DSzblueAllTrialsC = cat(2, currentSubj.DSzblueAllTrialsC, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSzpurpleAllTrialsC = cat(2, currentSubj.DSzpurpleAllTrialsC, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSpeLatencyAllTrialsC = cat(2, currentSubj(1).DSpeLatencyAllTrialsC, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

                        if ~isempty(currentSubj(session).periNS.NS)
                            currentSubj(1).NSzblueAllTrialsC = cat(2, currentSubj.NSzblueAllTrialsC, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                            currentSubj(1).NSzpurpleAllTrialsC = cat(2, currentSubj.NSzpurpleAllTrialsC, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                            currentSubj(1).NSpeLatencyAllTrialsC = cat(2,currentSubj(1).NSpeLatencyAllTrialsC,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                        else
%                             continue %continue if nos NS data
                        end
                    end %end sesCount conditional

                        %licks
                        currentSubj(1).DSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset

                        currentSubj(1).NSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxNSrel(NSselected);

                        
                         %in order to sort licks according to trial by PE latency
                         %later, we need to reshape the lox cell array from nested
                         %{session}{cue} to just {cue}
                          for cue = 1:numel(currentSubj(1).DSloxAllTrialsC{sesCountC})
                              DSloxAllTrialsC{trialCcount} = currentSubj(1).DSloxAllTrialsC{sesCountC}{cue};
                              trialCcount=trialCcount+1;
                          end           
                                            
                        for cue= 1:numel(currentSubj(1).NSloxAllTrialsC{sesCountC})
                            NSloxAllTrialsC{trialCNScount}= currentSubj(1).NSloxAllTrialsC{sesCountC}{cue};
                            trialCNScount=trialCNScount+1;
                        end

                    sesCountC= sesCountC+1;
                    subjSessC= cat(2, subjSessC, currentSubj(session).trainDay); %day count for y axis

              end %end Cond C
              
                     
              %Condition D
               if currentSubj(session).trainStage==8
                   
                    if sesCountD== 1 
                        currentSubj(1).DSzblueAllTrialsD= squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                        currentSubj(1).DSzpurpleAllTrialsD= squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected));
                        currentSubj(1).DSpeLatencyAllTrialsD= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                         if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                            currentSubj(1).NSzblueAllTrialsD= squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)); 
                            currentSubj(1).NSzpurpleAllTrialsD= squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected));
                            currentSubj(1).NSpeLatencyAllTrialsD= currentSubj(session).behavior.NSpeLatency(NSselected); 
                         else
%                            continue %continue if no NS data
                         end
                    else %add subsequent sessions using cat()
                        currentSubj(1).DSzblueAllTrialsD = cat(2, currentSubj.DSzblueAllTrialsD, (squeeze(currentSubj(session).periDS.DSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSzpurpleAllTrialsD = cat(2, currentSubj.DSzpurpleAllTrialsD, (squeeze(currentSubj(session).periDS.DSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSpeLatencyAllTrialsD = cat(2, currentSubj(1).DSpeLatencyAllTrialsD, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

                        if ~isempty(currentSubj(session).periNS.NS)
                            currentSubj(1).NSzblueAllTrialsD = cat(2, currentSubj.NSzblueAllTrialsD, (squeeze(currentSubj(session).periNS.NSzblue(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                            currentSubj(1).NSzpurpleAllTrialsD = cat(2, currentSubj.NSzpurpleAllTrialsD, (squeeze(currentSubj(session).periNS.NSzpurple(cueOnsetFrame:cueOnsetFrame+cueResponseFrames,:,NSselected)))); 
                            currentSubj(1).NSpeLatencyAllTrialsD = cat(2,currentSubj(1).NSpeLatencyAllTrialsD,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                        else
%                             continue %continue if nos NS data
                        end
                    end %end sesCount conditional

                        %licks
                        currentSubj(1).DSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset

                        currentSubj(1).NSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxNSrel(NSselected);

                        
                         %in order to sort licks according to trial by PE latency
                         %later, we need to reshape the lox cell array from nested
                         %{session}{cue} to just {cue}
                          for cue = 1:numel(currentSubj(1).DSloxAllTrialsD{sesCountD})
                              DSloxAllTrialsD{trialDcount} = currentSubj(1).DSloxAllTrialsD{sesCountD}{cue};
                              trialDcount=trialDcount+1;
                          end           
                                            
                        for cue= 1:numel(currentSubj(1).NSloxAllTrialsD{sesCountD})
                            NSloxAllTrialsD{trialDNScount}= currentSubj(1).NSloxAllTrialsD{sesCountD}{cue};
                            trialDNScount=trialDNScount+1;
                        end

                    sesCountD= sesCountD+1;
                    subjSessD= cat(2, subjSessD, currentSubj(session).trainDay); %day count for y axis

              end %end Cond D
             
   end %end session loop
   
   
   %now get the mean z value within the cueResponseFrames
        %cond A
   currentSubj(1).meanDSzblueResponseA= mean(currentSubj(1).DSzblueAllTrialsA,1);
   currentSubj(1).meanDSzpurpleResponseA= mean(currentSubj(1).DSzpurpleAllTrialsA,1);
   
        %cond B
   currentSubj(1).meanDSzblueResponseB= mean(currentSubj(1).DSzblueAllTrialsB,1);
   currentSubj(1).meanDSzpurpleResponseB= mean(currentSubj(1).DSzpurpleAllTrialsB,1);
   currentSubj(1).meanNSzblueResponseB= mean(currentSubj(1).NSzblueAllTrialsB,1);
   currentSubj(1).meanNSzpurpleResponseB= mean(currentSubj(1).NSzpurpleAllTrialsB,1);
        %cond C
   currentSubj(1).meanDSzblueResponseC= mean(currentSubj(1).DSzblueAllTrialsC,1);
   currentSubj(1).meanDSzpurpleResponseC= mean(currentSubj(1).DSzpurpleAllTrialsC,1);
   currentSubj(1).meanNSzblueResponseC= mean(currentSubj(1).NSzblueAllTrialsC,1);
   currentSubj(1).meanNSzpurpleResponseC= mean(currentSubj(1).NSzpurpleAllTrialsC,1);
        %cond D
   currentSubj(1).meanDSzblueResponseD= mean(currentSubj(1).DSzblueAllTrialsD,1);
   currentSubj(1).meanDSzpurpleResponseD= mean(currentSubj(1).DSzpurpleAllTrialsD,1);
   currentSubj(1).meanNSzblueResponseD= mean(currentSubj(1).NSzblueAllTrialsD,1);
   currentSubj(1).meanNSzpurpleResponseD= mean(currentSubj(1).NSzpurpleAllTrialsD,1);

   
   figure(figureCount);
   figureCount=figureCount+1;
 
   sgtitle(strcat('Rat #',num2str(currentSubj(1).rat),'PE latency by mean cue-evoked photometry response (within 1s)'));
   
   subplot(4,1,1); %cond A
   scatter(currentSubj(1).meanDSzblueResponseA, currentSubj(1).DSpeLatencyAllTrialsA);
   xlabel('465nm z score');
   ylabel('PE latency (s)');
   
   subplot(4,1,2); %cond B
   scatter(currentSubj(1).meanDSzblueResponseB, currentSubj(1).DSpeLatencyAllTrialsB);
   xlabel('z score');
   ylabel('PE latency (s)');
   
   subplot(4,1,3); %cond C
   scatter(currentSubj(1).meanDSzblueResponseC, currentSubj(1).DSpeLatencyAllTrialsC);
   xlabel('465nm z score');
   ylabel('PE latency (s)');
   
    
   subplot(4,1,4); %cond D
   scatter(currentSubj(1).meanDSzblueResponseD, currentSubj(1).DSpeLatencyAllTrialsD);
   xlabel('465nm z score');
   ylabel('PE latency (s)');
   
   set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

   
end %end subject loop




%% ~~~Behavioral plots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% %% PLOT PORT ENTRY COUNT ACROSS DAYS FOR ALL SUBJECTS - not very meaningful,  but good template for DS PE ratio or latency
% 
% %In this section, we'll loop through our subjData struct, extracting a port entry
% %count for each session. Then we'll plot # of port entries as training
% %progresses.
% 
% disp('plotting port entry counts')
% 
% figure(figureCount) %one figure with poxCount across sessions for all subjects
% 
% figureCount= figureCount+1; %iterate the figure count
% for subj= 1:numel(subjects) %for each subject
%     
%     %initialize
%     poxCount = [];
%     days = [];
%     
%    for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
%        
%        currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%       
%        %Plot number of port entries across all sessions
%        
%         poxCount(session)= numel(currentSubj(session).pox); %get the total number of port entries across days
%         days(session)= currentSubj(session).trainDay; %keep track of days to associate with poxCount
%    end
%    hold on;
%    plot(days, poxCount)
% end
% 
% title(strcat(currentSubj(session).experiment,' port entry count across days'));
% xlabel('training day');
% ylabel('port entry count');
% legend(subjects); %add rats to legend
% 
% %make figure full screen, save, and close this figure
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'port_entries_by_session','.fig'));
% %         close; %close 

%% PLOT AVERAGE PORT ENTRY COUNT BETWEEN DAYS FOR ALL ANIMALS

%In this section, we'll loop through our subjData struct to get a port
%entry count for each session. Then, we'll calculate an avg port entry
%count for each subject across sessions, along with an SEM for each subject
%with n= number of sessions. This information will be used to make a
%scatter plot of individual port entry counts by day, along with the mean +/- SEM.

clear poxCount; %used the same variable name as previous section, so clear it

disp('plotting avg port entry counts by animal');

%get the figure ready before starting subj loop
figure(figureCount) %one figure with avg poxCount for all subjects
figureCount= figureCount+1;
title(strcat(currentSubj(session).experiment,'avg port entry count by subject +/- SEM'));
xlabel('subject');
ylabel(' port entry count');

for subj= 1:numel(subjects) %for each subject
   for session = 1:numel(subjData.(subjects{subj})) %for each training session this subject completed
       
       
       %Get number of port entries for all sessions
       currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
       
       poxCount{1,subj}(session,1)= numel(currentSubj(session).pox);%get the total number of port entries across days %use a cell array in case # of sessions differs between subjects
       
       subjectLabel{1,subj}(session,1)= currentSubj(session).rat; %label each data point with a subject ID %use a cell array in case subjects have different # of sessions
       
   end %end session loop
   
   %Get the mean and SEM for each subject
   poxCountMean(1, subj)= mean(poxCount{1,subj}(:,1)); %calculate avg poxCount across sessions for each subject
   poxCountSEM(1,subj)= std(poxCount{1,subj}(:,1))/sqrt(numel(currentSubj)); %calculate SEM for each subject: standard deviation of number of port entries across sessions / number of sessions for this subject


   %now plot the data
   hold on;
   
   scatter(subjectLabel{1,subj}, poxCount{1,subj}(:,:)); %scatter daily port entry counts by subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj), poxCountMean(1,subj)], 'k'); %overlay mean of each subject
     
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)-poxCountSEM(1,subj), poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--');%overlay - sem of each subject
   plot([subjectLabel{1,subj}-.2,subjectLabel{1,subj}+.2] , [poxCountMean(1,subj)+poxCountSEM(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--');%overlay + sem of each subject
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [poxCountMean(1,subj),poxCountMean(1,subj)-poxCountSEM(1,subj)], 'k--'); %connect -SEM to mean
   plot([subjectLabel{1,subj}, subjectLabel{1,subj}], [ poxCountMean(1,subj), poxCountMean(1,subj)+poxCountSEM(1,subj)], 'k--'); %connect +SEM to mean
end

%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'average_port_entries_by_subject','.fig'));
%         close; %close 

%% PLOT DS & NS PE RATIO ACROSS DAYS

%In this section, we'll loop through our subjData struct, extracting a port entry
%count for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting port entry ratios')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
    
    %initialize
    days = []; 
    DSpeRatio= [];
    NSpeRatio= [];
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       
       currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE ratios
       
        DSpeRatio(session)= currentSubj(session).behavior.DSpeRatio; %get the DSpeRatio
       
        NSpeRatio(session)= currentSubj(session).behavior.NSpeRatio; %get NSpeRatio
   end
   subplot(2,1,1)
   hold on;
   h= plot(days, DSpeRatio); %save a handle so we can get the color of this plot and use it for NS
   
   %get this plot's color and x axis so we can use the same color for the NS plot
   c= get(h,'Color');
   x= xlim;
   y=[0,1];
   ylim(y);
   
   subplot(2,1,2)
   hold on;
   plot(days, NSpeRatio, 'Color', c, 'LineStyle','--');
   xlim(x);
   ylim(y);
   
end

subplot(2,1,1)
title(strcat(currentSubj(session).experiment,' DS PE Ratio across days'));
xlabel('training day');
ylabel('port entry ratio (# of trials with PE / total # of trials)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot

subplot(2,1,2)
title(strcat(currentSubj(session).experiment,' NS PE Ratio across days'));
xlabel('training day');
ylabel('port entry ratio (# of trials with PE / total # of trials)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot


%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'pe_ratio_by_session','.fig'));
%         close; %close 

%% PLOT AVG DS & NS PE LATENCY BY DAY

%In this section, we'll loop through our subjData struct, extracting an avg port entry
%latency for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting port entry latencies')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
    
    %initialize
    days = []; 
    meanDSpeLat= [];
    meanNSpeLat= [];
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       
       currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE lat
       
        meanDSpeLat(session)= nanmean(currentSubj(session).behavior.DSpeLatency); %get the mean DS PE lat
       
        meanNSpeLat(session)= nanmean(currentSubj(session).behavior.NSpeLatency); %get the mean NS PE lat
   end
   subplot(2,1,1)
   hold on;
   h= plot(days, meanDSpeLat); %save a handle so we can get the color of this plot and use it for NS
   
   %get this plot's color and x axis so we can use the same color for the NS plot
   c= get(h,'Color');
   x= xlim;
   y=ylim;
   
   subplot(2,1,2)
   hold on;
   plot(days, meanNSpeLat, 'Color', c, 'LineStyle','--');
   xlim(x);
%    ylim(y);
    ylim([0,30]);
   
end

subplot(2,1,1)
title(strcat(currentSubj(session).experiment,'Mean DS PE latency across days'));
xlabel('training day');
ylabel('mean latency to PE after cue onset (s)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot

subplot(2,1,2)
title(strcat(currentSubj(session).experiment,'Mean NS PE latency across days'));
xlabel('training day');
ylabel('mean latency to PE after cue onset (s)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot


%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'pe_latency_by_session','.fig'));
%         close; %close 

%% PLOT DS & NS LICKS ACROSS DAYS

%In this section, we'll loop through our subjData struct, extracting a port entry
%count for each session. Then we'll plot # of port entries as training
%progresses.

disp('plotting DS & NS licks')

figure(figureCount) %one figure with poxCount across sessions for all subjects

figureCount= figureCount+1; %iterate the figure count
for subj= 1:numel(subjects) %for each subject
    
    %initialize
    days = []; 
    DSlicks= [];
    NSlicks= [];
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       
       currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
      
       %Plot number of port entries across all sessions
       
        days(session)= currentSubj(session).trainDay; %keep track of days to associate with PE ratios
       
        
        %we have saved timestamps of each lick during the cue saved in
        %SubjDataAnalyzed.behavior. We'll use cellfun to get the length of
        %each cell (the number of licks in each cue presentation), then
        %we'll sum this to get a total lick count during cues in that
        %session
        DSlicks(session)= sum(cellfun('length', currentSubj(session).behavior.loxDS)); %get the DS licks
       
        if isempty(currentSubj(session).periNS.NS) %if this is a trial without NS data, make lick count nan (just makes plot nicer)
            NSlicks(session)=nan;
        else %otherwise, if there's valid NS data get the lick count
            NSlicks(session)= sum(cellfun('length',currentSubj(session).behavior.loxNS)); %get NS licks
        end   
        
        
   end
   subplot(2,1,1)
   hold on;
   h= plot(days, DSlicks); %save a handle so we can get the color of this plot and use it for NS
   
   %get this plot's color and x axis so we can use the same color for the NS plot
   c= get(h,'Color');
   x= xlim;
%    y=ylim;
   
   subplot(2,1,2)
   hold on;
   plot(days, NSlicks, 'Color', c, 'LineStyle','--');
   xlim(x);
%    ylim(y);
   
end

subplot(2,1,1)
title(strcat(currentSubj(session).experiment,' DS licks across days'));
xlabel('training day');
ylabel('# of licks in DS epoch (cue onset+ cue duration)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot

subplot(2,1,2)
title(strcat(currentSubj(session).experiment,' NS licks across days'));
xlabel('training day');
ylabel('# of licks in NS epoch (cue onset+ cue duration)');
legend(subjects, 'Location', 'eastoutside'); %add rats to legend, location outside of plot


%make figure full screen, save, and close this figure
set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
saveas(gcf, strcat(figPath, currentSubj(session).experiment,'_', subjects{subj},'cueLicks','.fig'));
%         close; %close 




%% ~~~Power analysis~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Try to estimate effect size. Effect we're looking at is the difference in
%z score 465nm(blue) response to DS cue vs. NS cue over some period of time. 
%In order to do so, we need to get an avg response to each cue across all subjects. Then, we'll 
%get an avg std of the response and use this to calculate pooledStd
%across subjects

%Need to define a timescale within which to look for cue-related effect
%Here, we will use a 1s time window after cue onset
effectDuration= 1; % Define a time window of interest after cue onset within which we will look for an effect

cueOnsetTime= periCueFrames-postCueFrames;

effectWindow= cueOnsetTime+1:cueOnsetTime+(effectDuration*fs); %Indices of the time window for the effect

%Because 405nm and 465nm signals are inversely related, looking for an
%effect between these signals doesn't seem appropriate. We could look for
%a difference between response to DS vs. response to NS. We could also look
%for a difference between cue-related response and 'spontaneous'
%activity during ITI. I think there must be some normalized metric between
%subjects to estimate an effect size (e.g. z score)
for subj= 1:numel(subjectsAnalyzed) %for each subject
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
   disp(strcat('working on effect size estimate for subj', num2str(subj), ' / ', num2str(numel(subjectsAnalyzed))));
   
   for session = 1:numel(subjDataAnalyzed.(subjectsAnalyzed{subj})) %for each training session this subject completed
       %raw blue and purple signals don't mean much as their value is arbitrary, can't really compare the two directly 
       %instead, need to look at change in signal over time
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue= currentSubj(session).DSblue(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple= currentSubj(session).DSpurple(effectWindow, 1, :);
%        subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurpleMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectDSpurple, 3)); %avg response throughout 1s,grand avg across all cues for that session
%        
       %Z score is a normalized metric which seems appropriate for analyzing this
       %type of data. While z score already incorporates within-subject std
       %into its calculation, we will use a pooledStd to incorporate
       %between-subject std.
       
       %get the z score values during the 'effect' time window
       %for now, interested in blue signal
       
       %Extract the blue z score response to cue in a specific time window of interest
       %for all DS cues (and then the avg response to all cues)...
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblue= currentSubj(session).periDS.DSzblue(effectWindow, 1, :);
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblue, 3)); %avg response throughout 1s,grand avg across all cues for that session
       %then calculate the std of this response to cues (and then the avg std of response to all cues)
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periDS.DSzblue(effectWindow,1,:)); %this gives us std of response to each cue
       subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueAvgStd= mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueStd); %this gives us the avg std of response to each cue
       
       %repeat above but for response to NS cue
       if isempty(currentSubj(session).periNS.NSzblue) %if there's no valid NS, there's no effect to look for
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean= [];
           
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd= [];
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd= [];
       else %if an NS is present, extract cue-related activity in the 'effect' time window
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue= currentSubj(session).periNS.NSzblue(effectWindow,1,:);
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean= mean(mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblue,3));
       
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd= std(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).periNS.NSzblue(effectWindow,1,:)); %this gives us std of response to each cue
           subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd= mean(subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueStd); %this gives us the avg std of response to each cue
       end
              
   end %end session loop
   
  %get a grand mean of 'effect' (here the z score in the blue channel) across all cues and all sessions for each subject
  grandMeanEffectDSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueMean));  
  grandMeanEffectNSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueMean));
   
  %get a grand avg std of the z score for each subject
  grandStdDSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowDSzblueAvgStd));  
  grandStdNSzblue(:,subj)= mean(cat(2,subjDataAnalyzed.(subjectsAnalyzed{subj})(session).effectSize.effectWindowNSzblueAvgStd));  

end %end subject loop

  %now avg everything across subjects; use nanmean since some NS dat   a may be nan
  grandMeanEffectDSzblueAllSubjects= nanmean(grandMeanEffectDSzblue); %avg response to DS
  grandMeanEffectNSzblueAllSubjects= nanmean(grandMeanEffectNSzblue); %avg response to NS

  grandStdDSzblueAllSubjects= nanmean(grandStdDSzblue); %avg std in response to DS
  grandStdNSzblueAllSubjects= nanmean(grandStdNSzblue); %avg std in response to NS
  
  
  %now, calculate a pooledStd between the DS and NS
  pooledStdAllSubjects= sqrt(((grandStdDSzblueAllSubjects^2)+(grandStdNSzblueAllSubjects^2))/2); 

 %now, estimate Cohen's D (mean1-mean2)/pooledStd
 
 cohensDzBlue= abs((grandMeanEffectDSzblueAllSubjects-grandMeanEffectNSzblueAllSubjects)/pooledStdAllSubjects)
 %May need to refine the time period over which to look for an effect (1s seems too broad, 
 %heatplots show response only ~500ms after cue). Could also look for a max
 %response and then use those instead of getting an avg response.
 
 %just for fun, what n would we need for .80 power given this effect size?
 nCuePresentationsNeeded = sampsizepwr('t',[grandMeanEffectDSzblueAllSubjects, pooledStdAllSubjects], grandMeanEffectNSzblueAllSubjects, .80,[])
  
 %VPFP-quantneuro: that's a lot of trials... 1398/30 per day ~ 47 days of training

 
 %lets save this too
for subj= 1:numel(subjectsAnalyzed) %for each subject
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.cohensDzBlue= cohensDzBlue;
   subjDataAnalyzed.(subjectsAnalyzed{subj})(1).effectSize.nCuePresentationsNeeded= nCuePresentationsNeeded;
end %end subject loop


%% ~~~Inferential stats~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% I think the data here will be parametric - at least in latter stages of
% training, there seem to be consistent cue responses 

% Since I'd like to see how the neural cue response changes with training, I would like to
% use n-way ANOVA to look at the main effect of cue, the main effect of session,
% and any interaction

%% ANOVA of blueZ in response to cue
% Trying to do N-way anova of blue z score response to DS vs. NS
% in a predefined time window of interest following the cue
%The time window is the same as in the power analysis above, and we'll pull
%from calculations made in the power analysis to get the avg. response to
%both cues
% For now, factors of interest: Cue, Subject, and Session (time)... and
% interactions

anovanSessionCount =1; %initialize an iterator for indexing

%Let's get our data into the right shape
%for simplicity, we'll loop through the data twice to get DS and NS data
for subj= 1:numel(subjectsAnalyzed) %for each subject
    
   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
   
    for session = 1:numel(currentSubj) %for each training session this subject completed

        %in order to make a comparison, we still need to select data only
        %from sessions that have both the DS and NS
        
        if ~isempty(currentSubj(session).effectSize.effectWindowNSzblueMean)
            anovanMeanZblue(anovanSessionCount,1)= currentSubj(session).effectSize.effectWindowDSzblueMean; %get mean blue z score response to DS
            anovanSessionLabel(anovanSessionCount,1)= currentSubj(session).trainDay;
            anovanSubjLabel(anovanSessionCount,1)= currentSubj(session).rat;
            anovanCueLabel(anovanSessionCount,1)= 1; %1 for DS

            anovanSessionCount= anovanSessionCount+1; %iterate the session count
        end
    end %end session loop  
end %end subject loop

%for simplicity, let's loop again through subjs/sessions for the NS data
for subj= 1:numel(subjectsAnalyzed)
    
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj});
    
    for session= 1:numel(currentSubj)
        if ~isempty(currentSubj(session).effectSize.effectWindowNSzblueMean) %only assign NS data if it's present
            anovanMeanZblue(anovanSessionCount,1)= currentSubj(session).effectSize.effectWindowNSzblueMean; %get mean blue z score response to NS
            anovanSessionLabel(anovanSessionCount,1)= currentSubj(session).trainDay;
            anovanSubjLabel(anovanSessionCount,1)= currentSubj(session).rat;
            anovanCueLabel(anovanSessionCount,1)= 2; %2 for NS
            
            anovanSessionCount= anovanSessionCount+1; %iterate the session count
        end        
    end %end session loop
end %end subject loop

%example 3 way anova
% y = [52.7 57.5 45.9 44.5 53.0 57.0 45.9 44.0]'; %raw data
% g1 = [1 2 1 2 1 2 1 2]; %label 1
% g2 = {'hi';'hi';'lo';'lo';'hi';'hi';'lo';'lo'}; %label 2
% g3 = {'may';'may';'may';'may';'june';'june';'june';'june'}; %label 3
% p = anovan(y,{g1,g2,g3})

[anovanP, anovanTbl, anovanStats]= anovan(anovanMeanZblue,{anovanCueLabel,anovanSubjLabel,anovanSessionLabel}, 'model', 'interaction', 'varnames', {'cue', 'subject', 'session'});


% disp(anovanTbl);

%% ~~~Artifact identification/elimination~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%Maybe we should just exclude extreme trials/ trials where artifacts are present
%Trying to visualize outliers here first
    
%% Histograms of individual trial z score response
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     
%     %histogram plot of the blue z score response to DS, #bins = # cue presentations
%     figure;
%     subplot(2,1,1);
%     histogram(currentSubj(1).periDS.DSzblueAllTrials, currentSubj(1).periDS.totalDScount(end), 'facecolor', 'b');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     %hist the purple z score response to DS #bins = # cue presentations
%     subplot(2,1,2)
%     histogram(currentSubj(1).periDS.DSzpurpleAllTrials, currentSubj(1).periDS.totalDScount(end) , 'facecolor', 'm');
%     xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
%     ylabel('# timestamps with this value');
%     title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS (n= ', num2str(currentSubj(1).periDS.totalDScount(end)), '*1601 timestamps)'));
%     xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%     
%     
% end

% % % HISTOGRAM OF RESPONSE OVER TIME
% % march through timestamps on button press
% % for subj= 1:numel(subjectsAnalyzed) %for each subject
% %     
% %     currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
% %     
% %     timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% %     
% %     histogram plot of the blue z score response to DS
% %     figure(figureCount);
% %     figureCount= figureCount+1;
% %     disp('***displaying histograms of z score response to cue thru time');
% %     for timestamp= 1:numel(timeStep)
% %             subplot(2,1,1);
% %             histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %         
% %             hist the purple z score response to DS 
% %             subplot(2,1,2)
% %             histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
% %             xlabel(strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue'));
% %             ylabel('# timestamps with this value');
% %             title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))));
% %             xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% %             pause(0.008); %this will automatically iterate (seconds); to wait for user input use pause()
% %     end
% %     close;
% % end

%% Looping histogram of z score DS response over time
% %TODO: save to movie
% timeStep= [1:fs:numel(timeLock)]; %create an array containing 1s "steps" in time around the cue (based on fs)
% 
% figure(figureCount);
% figureCount=figureCount+1;
% hold on;
% set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
% histTitle= sgtitle(strcat('z score in response to DS at T= ')); %add big title above all subplots
% 
% 
% % while 1 %infinite loop while true
%     disp('***displaying histograms of z score response to cue thru time, press key to stop');
%     
%     %loop through all timestamps, for each timestamp loop through subjects
%     %and plot the peri-cue z score values first in the blue channel then in
%     %the purple channel (looped twice in order to organize subplots so that
%     %blue is on top of purple for each subject)
%     
%     for timestamp= 1:numel(timeStep)
%         subplotCount= 1; %reset all the subplots between timestamps
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);   
%                 subplotCount=subplotCount+1;
%                 
%                 histogram(currentSubj(1).periDS.DSzblueAllTrials(:,timestamp), 'facecolor', 'b');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'blue z'));
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
% 
%         end
%         
%         
%         for subj= 1:numel(subjectsAnalyzed)
%             
%                histTitle.String= strcat('z score in response to DS at T= ', num2str(timeLock(timeStep(timestamp)))); %update the big title above all subplots, need to do it this way otherwise it draws over itself
%                 
%                 currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subjects within the struct
%             
%                 %hist the purple z score response to DS #bins = # cue presentations
%                 subplot(2, numel(subjectsAnalyzed), subplotCount);
%                 subplotCount=subplotCount+1;
%                 histogram(currentSubj(1).periDS.DSzpurpleAllTrials(:,timestamp), 'facecolor', 'm');
%                 xlabel(strcat('DS blue z-score'));
%                 ylabel('# trials');
%                 title(strcat('rat_', num2str(currentSubj(1).rat), 'purple z'));
%                 xlim([currentSubj(1).periDS.bottomAllShared,currentSubj(1).periDS.topAllShared]); %set a shared x axis for comparison
%         end
%         
%         pause(0.005); %this will automatically iterate (seconds); to wait for user input use pause()
% 
%     end
% % end
% 
% close;
    
%% Artifact elimination
% 
% %Artifacts should be considered fast deflections in both shannels in the same
% %direction, or we could just use the 405nm to keep it simple
% 
% %define a threshold criteria for the isosbestic channel based on std,
% %and discard frames where the isosbestic signal deviates above this threshold
% 
% %keep in mind that 405nm signal could vary with ca++ events
% 
% %this strategy seeems imperfect- good datapoints may be removed due to
% %bleaching and it doesn't capture all artifacts... instead of looking
% %at global std, need to do some kind of sliding calculation to look at
% %local std
%     
% for subj= 1:numel(subjects)
%     
%     currentSubj= subjData.(subjects{subj});
%     
%     disp(strcat('artifact elimination_', subjects{subj}));
%     
%     
%     figure(figureCount);
%     figureCount=figureCount+1;
%     sgtitle(strcat('Rat #',num2str(currentSubj(1).rat), 'artifact detection'));
%     
%     subplotCount=1;
% 
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%        artifactThreshold = std(currentSubj(session).repurple)*2;
%        
%        subjDataAnalyzed.(subjects{subj})(session).photometrySignals.artifactThreshold= artifactThreshold; %save this value
%       
%     for timestamp= 1:numel(currentSubj(session).repurple)
%         if timestamp== 1
%             currentSubj(session).dPurple(timestamp)= 0; %no change possible on the first timestamp
%         else
%             currentSubj(session).dPurple(timestamp) = currentSubj(session).repurple(timestamp)-currentSubj(session).repurple(timestamp-1);
%         end  
%     end
%     
%     dPurple= currentSubj(session).dPurple;
%     
%     %let's define a threshold beyond which we want to exclude data (noise)
%     dThreshold = std(currentSubj(session).dPurple)*8;
%     dMean= mean(currentSubj(session).dPurple);
%     
%     %identify points that exceed this threshold
%     dArtifactIndex= find(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     dArtifactsVals= dPurple(dPurple>dThreshold | dPurple<-dThreshold);
%     
%     subplot(numel(currentSubj),3,subplotCount);
%     subplotCount=subplotCount+1;
%     hold on;
%     plot(currentSubj(session).dPurple, 'm');
%     
%     title('dPurple');
%     %overlay threshold
%     plot([1,numel(currentSubj(session).dPurple)], [dMean - dThreshold, dMean - dThreshold], 'k--');
%     plot([1,numel(currentSubj(session).dPurple)], [dMean + dThreshold, dMean + dThreshold], 'k--');
%     %overlay points beyond threshold
%     scatter(dArtifactIndex, dArtifactsVals, 'rx')
%    
%     
%     % let's put these excluded timestamps over the raw purple trace to compare
%     
%        subplot(numel(currentSubj), 3, subplotCount);
%        subplotCount= subplotCount+1;
%        hold on;
%        plot(currentSubj(session).repurple, 'm'); %plot 405 signal
%        title('repurple, artifact timestamps calculated based on dPurple');
%        
%        %overlay + and - the threshold relative to the mean 405 signal
%        plot([1,numel(currentSubj(session).repurple)], [mean(currentSubj(session).repurple) + artifactThreshold, mean(currentSubj(session).repurple) + artifactThreshold], 'k--')
%        plot([1,numel(currentSubj(session).repurple)], [mean(currentSubj(session).repurple) - artifactThreshold, mean(currentSubj(session).repurple) - artifactThreshold], 'k--')
% 
%        scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+mean(currentSubj(session).repurple), 'rx'); 
%     
%        %plot blue too
%        plot(currentSubj(session).reblue);
%     
% 
%     
% 
%     %conservative threshold works well here- just looking for extreme
%     %artifacts- big, abrupt changes
%     
%     %seems to work for most trials, but @ threshold = 10 std trhis misses a pretty big case for
%     %VP-VTA-FP rat 9 trial 32
%     
%     %TODO: this is calculating dF timestamp by timestamp, but maybe we want to reject
%     %rapid increases over a specific time period or do some kind of sliding
%     %calculation
% 
%     %Let's actually remove the artifacts now
%     
%     cutTime= currentSubj(session).cutTime;
%     
%     %get the actual timestamp values to be excluded from cutTime
%     excludedTimestamps = cutTime(dArtifactIndex);
%         
%     %extract all timestmap values from cutTime that aren't equal to these
%     %excluded timestamps
%     
%     %make these excluded timestamps NaN
%     cutTime(dArtifactIndex)= NaN;
%     %extract timestamps that aren't NaN
%     timeNoArtifact= cutTime(~isnan(cutTime));
%     
% %     disp(strcat('excluded_', num2str(numel(excludedTimestamps)), ' timestamps w/ artifacts '));
%     
%     %now use the same strategy to extract photometry signals
%     reblueNoArtifact= currentSubj(session).reblue(~isnan(cutTime));
%     repurpleNoArtifact= currentSubj(session).repurple(~isnan(cutTime));
%     
%     
%    subplot(numel(currentSubj), 3, subplotCount);
%    subplotCount= subplotCount+1;
%    hold on;
%    plot(repurpleNoArtifact, 'm'); %plot 405 signal
%    title('artifacts removed- this method isnt working');
% 
%    scatter(dArtifactIndex, ones(numel(dArtifactIndex),1)*artifactThreshold+mean(currentSubj(session).repurple), 'rx'); 
% 
%    %plot blue too
%    plot(reblueNoArtifact, 'b');
% 
%    set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%    
%    %this method doesn't seem to work well enough- but at least we have
%    %decent timestamps of artifacts... we maybe we can use this to exclude TRIALS
%    %instead of trying to remove the artifacts themselves?
%    
%    %maybe it would be best to just exlucde trials with huge z scores
%    
%    %Maybe instead of excluding trials, change the baseline z score calc in
%    %some way (exclude timestamps?)
%    
%    %save the artifact indices for each session
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.dArtifactTimes= excludedTimestamps; %this is a list of the excluded timestamps
%    subjDataAnalyzed.(subjects{subj})(session).photometrySignals.cutTimeNoArtifacts= cutTime; %this is a time axis where timestamps with artifacts= NaN
% 
%    end %end session loop
%    
%     %save figure
% %    saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_ArtifactID','.tiff')); %save the current figure in fig format
% 
% end %end subj loop
   
%% HEAT PLOT WITH ARTIFACT TRIALS EXCLUDED
% 
% %Now that we have timestamps of 'artifacts', check if the peri-event window
% %includes an artifact. If so, exclude this trial.
% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
% currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%     for session = 1:numel(currentSubj) %for each training session this subject completed
% 
%         %go through each session and check to see if periDS window contains an
%         %excluded timestamp (due to artifact being detected)
%         DSincluded = size(currentSubj(session).periDS.periDSwindow,3);
% 
%         DSexcluded= []; %keep track of which cues were excluded for this session
% 
%             for cue = 1:DSincluded
%                 preEventTimeDS= currentSubj(session).periDS.periDSwindow(:,1,cue);
%                 postEventTimeDS= currentSubj(session).periDS.periDSwindow(:,end,cue);
% 
%                 for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                     %if artifact occurs between preEventTime and postEventTime
%                     if artifact>preEventTimeDS && artifact<postEventTimeDS
%                         disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding DS_', num2str(cue), ' from heat plot'))
%                         DSexcluded= [DSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                         continue; %if this cue has an artifact, we don't need to keep checking anymore
%                     end
%                 end
%             end
% 
%             currentSubj(session).periDS.DSexcludedArtifact= DSexcluded; %save list of excluded cues for each session
% 
%             %now that we have excluded cues, let's go in and extract only data
%             %from included cues
% 
%             for excludedTrial = DSexcluded
%                 %make all the dat in excluded trials = nan
%                 currentSubj(session).periDS.DSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                 currentSubj(session).periDS.DSzpurple(:,:,excludedTrial)=nan; 
%             end
% 
% 
%       %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single DS)
%             if session==1
%                 currentSubj(1).DSzblueAllTrials= squeeze(currentSubj(session).periDS.DSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                 currentSubj(1).DSzpurpleAllTrials= squeeze(currentSubj(session).periDS.DSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%             else
%                 currentSubj(1).DSzblueAllTrials = cat(2, currentSubj.DSzblueAllTrials, (squeeze(currentSubj(session).periDS.DSzblue))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%                 currentSubj(1).DSzpurpleAllTrials = cat(2, currentSubj.DSzpurpleAllTrials, (squeeze(currentSubj(session).periDS.DSzpurple))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
%             end
% 
%             %repeat above steps for NS
%             
%         if ~isempty(currentSubj(session).periNS.periNSwindow) %only run if there's NS data present
%             NSincluded = size(currentSubj(session).periNS.periNSwindow,3);
% 
%             NSexcluded= []; %keep track of which cues were excluded for this session
% 
%                 for cue = 1:NSincluded
%                     preEventTimeNS= currentSubj(session).periNS.periNSwindow(:,1,cue);
%                     postEventTimeNS= currentSubj(session).periNS.periNSwindow(:,end,cue);
% 
%                     for artifact= currentSubj(session).photometrySignals.dArtifactTimes
%                         %if artifact occurs between preEventTime and postEventTime
%                         if artifact>preEventTimeNS && artifact<postEventTimeNS
%                             disp(strcat('rat_ ', num2str(currentSubj(1).rat), ' session ', num2str(session), ' artifact detected, exluding NS_', num2str(cue), ' from heat plot'))
%                             NSexcluded= [NSexcluded, cue]; %add this cue to the list of excluded cues for this session
%                             continue; %if this cue has an artifact, we don't need to keep checking anymore
%                         end
%                     end
%                 end
% 
%                 currentSubj(session).periNS.NSexcludedArtifact= NSexcluded; %save list of excluded cues for each session
% 
%                 %now that we have excluded cues, let's go in and extract only data
%                 %from included cues
% 
%                 for excludedTrial = NSexcluded
%                     %make all the dat in excluded trials = nan
%                     currentSubj(session).periNS.NSzblue(:,:,excludedTrial)= nan; %first make all these values nan
%                     currentSubj(session).periNS.NSzpurple(:,:,excludedTrial)=nan; 
%                 end
% 
% 
%           %collect all z score responses to every single DS across all sessions (and the latency to PE in response to every single NS)
%                 if session==1
%                     currentSubj(1).NSzblueAllTrials= squeeze(currentSubj(session).periNS.NSzblue); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
%                     currentSubj(1).NSzpurpleAllTrials= squeeze(currentSubj(session).periNS.NSzpurple); %squeeze the 3d matrix into a 2d array, with each coumn containing response to 1 cue
% 
%                 else
%                     currentSubj(1).NSzblueAllTrials = cat(2, currentSubj.NSzblueAllTrials, (squeeze(currentSubj(session).periNS.NSzblue))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                     currentSubj(1).NSzpurpleAllTrials = cat(2, currentSubj.NSzpurpleAllTrials, (squeeze(currentSubj(session).periNS.NSzpurple))); %concatenate- this contains z score response to NS from every NS (should have #columns= ~30 cues x #sessions)
%                 end
%                  
%         else %if there's no NS data present
%             currentSubj(1).NSzblueAllTrials= [];
%             currentSubj(1).NSzpurpleAllTrials= [];    
%         end %end NS conditional
%         
%     end %end session loop
% 
%     %Transpose these data for readability
%     currentSubj(1).DSzblueAllTrials= currentSubj(1).DSzblueAllTrials';
%     currentSubj(1).DSzpurpleAllTrials= currentSubj(1).DSzpurpleAllTrials';
%    
%     if ~isempty(currentSubj(1).NSzblueAllTrials)
%         currentSubj(1).NSzblueAllTrials= currentSubj(1).NSzblueAllTrials';
%         currentSubj(1).NSzpurpleAllTrials= currentSubj(1).NSzpurpleAllTrials';
%     end
%      %Color axes   
%      
%      %First, we'll want to establish boundaries for our colormaps based on
%      %the std of the z score response. We want to have equidistant
%      %color axis max and min so that 0 sits directly in the middle
%      
%      %TODO: should this be a pooled std calculation (pooled blue & purple)?
%      
%      %define DS color axes
%      
%      %get the avg std in the blue and purple z score responses to all cues,
%      %get absolute value and then multiply this by some factor to define a color axis max and min
%      
%      stdFactor= 4;
%      
%      %need to use nanmean now bc we have nans on excluded trials
%      topDSzblue= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      topDSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%      bottomDSzblue = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%      bottomDSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrials, 0, 2))));
%      
%      %now choose the most extreme of these two (between blue and
%      %purple)to represent the color axis 
%      bottomAllDS= min(bottomDSzblue, bottomDSzpurple);
%      topAllDS= max(topDSzblue, topDSzpurple);
%      
%         %same defining color axes for NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %only run this if there's NS data
%         topNSzblue= stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSzpurple= stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSzblue= -stdFactor*abs(mean((std(currentSubj(1).NSzblueAllTrials, 0, 2))));
%         bottomNSzpurple= -stdFactor*abs(mean((std(currentSubj(1).NSzpurpleAllTrials, 0, 2))));
% 
%         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%         topAllNS= max(topNSzblue, topNSzpurple);
%     end
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is an NS
%         bottomAllShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topAllShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
%         bottomAllShared= bottomAllDS;
%         topAllShared= topAllDS;
%     end
%            
%     
%     %get a trial count to use for the heatplot ytick
%     currentSubj(1).totalDScount= 1:size(currentSubj(1).DSzblueAllTrials,1); 
%     currentSubj(1).totalNScount= 1:size(currentSubj(1).NSzblueAllTrials,1); 
% 
%     %save for later 
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.totalDScount= currentSubj(1).totalDScount;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.bottomAllShared= bottomAllShared;
%     subjDataAnalyzed.(subjectsAnalyzed{subj})(1).periDS.topAllShared= topAllShared;
%     
%     %TODO: split up yticks by session (this would show any clear differences between days)
%     
%      %Heatplots!       
%     %DS z plot
%     figure(figureCount);
%     hold on;
%     subplot(2,2,1); %subplot for shared colorbar
% 
%     %plot blue DS
% 
%     timeLock = [-periCueFrames:periCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
%     heatDSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzblueAllTrials);
%     title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
% 
%     %   plot purple DS (subplotted for shared colorbar)
%     subplot(2,2,3);
%     heatDSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalDScount,currentSubj(1).DSzpurpleAllTrials); 
% 
%     title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every DS- ARTIFACT TRIALS REMOVED ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%     xlabel('seconds from cue onset');
%     ylabel(strcat('DS trial (n= ', num2str(currentSubj(1).totalDScount(end)), ')'));
% 
% %     set(gca, 'ytick', currentSubj(1).totalDScount); %label trials appropriately
% 
%     caxis manual;
%     caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
%     
%     c= colorbar; %colorbar legend
%     c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%     set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%     saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials_ArtifactRemoved','.fig')); %save the current figure in fig format
% 
%       if ~isempty(currentSubj(1).NSzblueAllTrials) %if there is NS data
%         
%         %plot blue NS
%         subplot(2,2,2); %subplot for shared colorbar
% 
%         heatNSzblueAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzblueAllTrials);
%         title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' blue z score response surrounding every NS ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%         
%         
%            %   plot purple NS (subplotted for shared colorbar)
%         subplot(2,2,4);
%         heatNSzpurpleAllTrials= imagesc(timeLock,currentSubj(1).totalNScount,currentSubj(1).NSzpurpleAllTrials); 
% 
%         title(strcat(subjData.(subjects{subj})(1).experiment, ' : ', num2str(subjectsAnalyzed{subj}), ' purple z score response surrounding every NS ')) %'(n= ', num2str(unique(trialDSnum)),')')); 
%         xlabel('seconds from cue onset');
%         ylabel(strcat('NS trial (n= ', num2str(currentSubj(1).totalNScount(end)), ')'));
% 
%     %     set(gca, 'ytick', currentSubj(1).totalNScount); %label trials appropriately
% 
%         caxis manual;
%         caxis([bottomAllShared topAllShared]); %use a shared color axis to encompass all values
% 
%         c= colorbar; %colorbar legend
%         c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%         set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%         saveas(gcf, strcat(figPath, subjData.(subjects{subj})(1).experiment, '_', subjectsAnalyzed{subj}, '_periCueZ_AllTrials','.fig')); %save the current figure in fig format
%     end
%     
%     
%     
%     figureCount= figureCount+1;

% end%end subj loop

%% experimenting with nonlinear colormap

% 
% 
% for subj= 1:numel(subjectsAnalyzed) %for each subject
%     
%   currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct
%   
% % First, I�d pick an existing colormap, such as Parula. Specify the max and min values of your data (e.g. 34 and -350), and then select the value at which you would like more color variation (e.g. perhaps 34 or 0). You can play with the scaling intensity parameter to see what looks nice.
%   cMap = parula(256);
%   dataMax = topAllShared;
%   dataMin = bottomAllShared;
%   centerPoint = 1; %mean(mean(currentSubj(1).periDS.DSzpurpleAllTrials,1));
%   scalingIntensity = 1; %mean(std(currentSubj(1).periDS.DSzpurpleAllTrials));
% % Then perform some operations to create your colormap. I have done this by altering the indices �x� at which each existing color lives, and then interpolating to expand or shrink certain areas of the spectrum.
%   x = 1:length(cMap); 
%   x = x - (centerPoint-dataMin)*length(x)/(dataMax-dataMin);
%   x = scalingIntensity * x/max(abs(x));
% % Next, select some function or operations to transform the original linear indices into nonlinear. In the last line, I then use �interp1� to create the new colormap from the original colormap and the transformed indices.
%   x = sign(x).* exp(abs(x));
%   x = x - min(x); x = x*511/max(x)+1; 
%   newMap = interp1(x, cMap, 1:512);
% % Then plot! 
% %   figure; imagesc(X);
% %   figure; imagesc(X); colormap(newMap);
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colorbar; title(strcat('auto colormap rat_ ', num2str(currentSubj(1).rat)));
%   figure; imagesc(timeLock,currentSubj(1).periDS.totalDScount,currentSubj(1).periDS.DSzpurpleAllTrials); colormap(newMap); colorbar;
%   title(strcat('nonlinear colormap; center= ', num2str(centerPoint), '; scaling = ', num2str(scalingIntensity), '; rat_', num2str(currentSubj(1).rat)));
%  
%   
%     figureCount= figureCount+1;
% end %end subj loop

%% ~~~Dakota GPN poster retreat plots~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% stage 1-4 , 5, and 6+ session DS plots

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   
   
  sesCountA= 1;
  sesCountB= 1;
  sesCountC= 1;
  
  sesCountD= 1;
  
  subjSessA= [];
  subjSessB= [];
  subjSessC= [];
  
  subjSessD= [];

   for session = 1:numel(currentSubj) %for each training session this subject completed
              
       %compare avg response to cue for each session across stages
       
       %First get data from sessions on stages <5
       if currentSubj(session).trainStage <5
            if sesCountA ==1 %for the first session, get this sessions periDS blue z score response
                        currentSubj(1).DSzblueSessionMeanA= currentSubj(session).periDS.DSzblueMean; 
                        currentSubj(1).DSzpurpleSessionMeanA= currentSubj(session).periDS.DSzpurpleMean;
                else % add on periDS response for subsequent sessions
                        currentSubj(1).DSzblueSessionMeanA= cat(2, currentSubj(1).DSzblueSessionMeanA, currentSubj(session).periDS.DSzblueMean);
                        currentSubj(1).DSzpurpleSessionMeanA= cat(2, currentSubj(1).DSzpurpleSessionMeanA, currentSubj(session).periDS.DSzpurpleMean);
            end
            sesCountA= sesCountA+1;
            subjSessA= cat(2, subjSessA, currentSubj(session).trainDay); %day count for y axis
       end %end conditional A
       
       %now get data from sessions on stage 5
       if currentSubj(session).trainStage == 5
              if sesCountB ==1 %for the first session, get this sessions periDS blue z score response
                        currentSubj(1).DSzblueSessionMeanB= currentSubj(session).periDS.DSzblueMean; 
                        currentSubj(1).DSzpurpleSessionMeanB= currentSubj(session).periDS.DSzpurpleMean;
                        currentSubj(1).NSzblueSessionMeanB= currentSubj(session).periNS.NSzblueMean;
                        currentSubj(1).NSzpurpleSessionMeanB= currentSubj(session).periNS.NSzpurpleMean;
              else % add on periDS response for subsequent sessions
                        currentSubj(1).DSzblueSessionMeanB= cat(2, currentSubj(1).DSzblueSessionMeanB, currentSubj(session).periDS.DSzblueMean);
                        currentSubj(1).DSzpurpleSessionMeanB= cat(2, currentSubj(1).DSzpurpleSessionMeanB, currentSubj(session).periDS.DSzpurpleMean);
                        currentSubj(1).NSzblueSessionMeanB= cat(2, currentSubj(1).NSzblueSessionMeanB, currentSubj(session).periNS.NSzblueMean);
                        currentSubj(1).NSzpurpleSessionMeanB= cat(2, currentSubj(1).NSzpurpleSessionMeanB, currentSubj(session).periNS.NSzpurpleMean);
              end
              sesCountB= sesCountB+1;
              subjSessB= cat(2, subjSessB, currentSubj(session).trainDay); %day count for y axis

       end %end conditional B
       
       %now get data from sessions above stages 6-7 (where delay introduced)
       if currentSubj(session).trainStage==6 || currentSubj(session).trainStage==7
            if sesCountC ==1 %for the first session, get this sessions periDS blue z score response
                        currentSubj(1).DSzblueSessionMeanC= currentSubj(session).periDS.DSzblueMean; 
                        currentSubj(1).DSzpurpleSessionMeanC= currentSubj(session).periDS.DSzpurpleMean;
                        currentSubj(1).NSzblueSessionMeanC= currentSubj(session).periNS.NSzblueMean;
                        currentSubj(1).NSzpurpleSessionMeanC= currentSubj(session).periNS.NSzpurpleMean;
             else % add on periDS response for subsequent sessions
                        currentSubj(1).DSzblueSessionMeanC= cat(2, currentSubj(1).DSzblueSessionMeanC, currentSubj(session).periDS.DSzblueMean);
                        currentSubj(1).DSzpurpleSessionMeanC= cat(2, currentSubj(1).DSzpurpleSessionMeanC, currentSubj(session).periDS.DSzpurpleMean);
                        currentSubj(1).NSzblueSessionMeanC= cat(2, currentSubj(1).NSzblueSessionMeanC, currentSubj(session).periNS.NSzblueMean);
                        currentSubj(1).NSzpurpleSessionMeanC= cat(2, currentSubj(1).NSzpurpleSessionMeanC, currentSubj(session).periNS.NSzpurpleMean);
            end
            sesCountC= sesCountC+1;
            subjSessC= cat(2, subjSessC, currentSubj(session).trainDay); %day count for y axis

       end %end conditional C
       
       
       if currentSubj(session).trainStage == 8
           
           if sesCountD ==1 %for the first session, get this sessions periDS blue z score response
                        currentSubj(1).DSzblueSessionMeanD= currentSubj(session).periDS.DSzblueMean; 
                        currentSubj(1).DSzpurpleSessionMeanD= currentSubj(session).periDS.DSzpurpleMean;
                        currentSubj(1).NSzblueSessionMeanD= currentSubj(session).periNS.NSzblueMean;
                        currentSubj(1).NSzpurpleSessionMeanD= currentSubj(session).periNS.NSzpurpleMean;
             else % add on periDS response for subsequent sessions
                        currentSubj(1).DSzblueSessionMeanD= cat(2, currentSubj(1).DSzblueSessionMeanD, currentSubj(session).periDS.DSzblueMean);
                        currentSubj(1).DSzpurpleSessionMeanD= cat(2, currentSubj(1).DSzpurpleSessionMeanD, currentSubj(session).periDS.DSzpurpleMean);
                        currentSubj(1).NSzblueSessionMeanD= cat(2, currentSubj(1).NSzblueSessionMeanD, currentSubj(session).periNS.NSzblueMean);
                        currentSubj(1).NSzpurpleSessionMeanD= cat(2, currentSubj(1).NSzpurpleSessionMeanD, currentSubj(session).periNS.NSzpurpleMean);
            end
            sesCountD= sesCountD+1;
            subjSessD= cat(2, subjSessD, currentSubj(session).trainDay); %day count for y axis

       end %end conditional D
       
    end %end session loop
 
    
    %Transpose for readability
    currentSubj(1).DSzblueSessionMeanA= currentSubj(1).DSzblueSessionMeanA';
    currentSubj(1).DSzpurpleSessionMeanA= currentSubj(1).DSzpurpleSessionMeanA';
    
    currentSubj(1).DSzblueSessionMeanB= currentSubj(1).DSzblueSessionMeanB';
    currentSubj(1).DSzpurpleSessionMeanB= currentSubj(1).DSzpurpleSessionMeanB';
    currentSubj(1).NSzblueSessionMeanB= currentSubj(1).NSzblueSessionMeanB';
    currentSubj(1).NSzpurpleSessionMeanB= currentSubj(1).NSzpurpleSessionMeanB';
    
    currentSubj(1).DSzblueSessionMeanC= currentSubj(1).DSzblueSessionMeanC';
    currentSubj(1).DSzpurpleSessionMeanC= currentSubj(1).DSzpurpleSessionMeanC';
    currentSubj(1).NSzblueSessionMeanC= currentSubj(1).NSzblueSessionMeanC';
    currentSubj(1).NSzpurpleSessionMeanC= currentSubj(1).NSzpurpleSessionMeanC';
    
    
    currentSubj(1).DSzblueSessionMeanD= currentSubj(1).DSzblueSessionMeanD';
    currentSubj(1).DSzpurpleSessionMeanD= currentSubj(1).DSzpurpleSessionMeanD';
    currentSubj(1).NSzblueSessionMeanD= currentSubj(1).NSzblueSessionMeanD';
    currentSubj(1).NSzpurpleSessionMeanD= currentSubj(1).NSzpurpleSessionMeanD';
    

%     %get list of session days for heatplot y axis (transposed for readability)
%     subjTrial= cat(2, currentSubj.trainDay).'; %this is only training days for this subj

  
    
    %get list of session days for heatplot y axis
%     subjTrialNS=[]; %keep track of sessions that have valid NS trials
%     dateNS= [];
%     for session = 1:numel(currentSubj) %for each training session this subject completed
%         if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
% %              subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay); %old method based on trainDay
%                 dateNS= cat(2, dateNS, currentSubj(session).date);
%         end
%     end %end session loop
%     
%     %search NS dates for the appropriate index in allDates, then label it
%     %similar to subjTrial
%     for thisDate = 1:numel(dateNS) 
%         subjTrialNS(thisDate)= find(allDates==dateNS(thisDate)); %returns the index in allDates that matches the date of this NS session
%     end
     %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
    
     %define DS color axes
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
     %cond A
     topDSzblueA= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleA= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueA = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleA= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanA, 0, 2))));
     
     %cond b
     topDSzblueB= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleB= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueB = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleB= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanB, 0, 2))));
     
     %cond c
     topDSzblueC= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleC= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueC = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleC= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanC, 0, 2))));
     
     bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC];
     tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC];
     
     %cond D
     topDSzblueD= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleD= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueD = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueSessionMeanD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleD= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleSessionMeanD, 0, 2))));
     
     bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzblueD, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC, bottomDSzpurpleD];
     tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzblueD, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC, topDSzpurpleD];
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottoms);
     topAllDS= max(tops);
     
%     %same, but defining color axes for NS
%     if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
%         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
%         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));
% 
%         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%         topAllNS= max(topNSzblue, topNSzpurple);
%     end
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
%         bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
        bottomMeanShared= bottomAllDS;
        topMeanShared= topAllDS;
%     end
    
   

    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
% 
%         figure(figureCount);
%         figureCount= figureCount+1;
% 
%         sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, 'Avg response by session to DS across training stages')); %add big title above all subplots
% 
% 
%         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
%         
%             imagesc(timeLock,subjSessA,currentSubj(1).DSzblueSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg 465nm z score response surrounding DS- Stages 1-4')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,subjSessB,currentSubj(1).DSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg 465nm z score response surrounding DS- Stage 5')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
%             imagesc(timeLock,subjSessC,currentSubj(1).DSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg 465nm z score response surrounding DS- Stages 6-8')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
% 
%        subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
%             imagesc(timeLock,subjSessA,currentSubj(1).DSzpurpleSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg 405nm z score response surrounding DS- Stages 1-4')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%        subplot(2,3,5) %plot of stage 5 purple (cond B purple)
%             imagesc(timeLock,subjSessB,currentSubj(1).DSzpurpleSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg 405nm z score response surrounding DS- Stage 5')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%        subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
%             imagesc(timeLock,subjSessC,currentSubj(1).DSzpurpleSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('daily avg 405nm z score response surrounding DS- Stages 6-8')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%             
%             
%             
%             %NS plots ~~~~~
%             
%             figure(figureCount);
%             figureCount= figureCount+1;
% 
%             
%         sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, 'Avg response by session to NS across training stages')); %add big title above all subplots
% 
% 
%         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
%         
% %             imagesc(timeLock,subjSessA,currentSubj(1).NSzblueSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('daily avg 465nm z score response surrounding NS- Stages 1-4')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,subjSessB,currentSubj(1).NSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg 465nm z score response surrounding NS- Stage 5')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
%             imagesc(timeLock,subjSessC,currentSubj(1).NSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg 465nm z score response surrounding NS- Stages 6-8')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
% 
%        subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
% %             imagesc(timeLock,subjSessA,currentSubj(1).NSzpurpleSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('daily avg 405nm z score response surrounding NS- Stages 1-4')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('training day');
% %             set(gca, 'ytick', subjSessA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%        subplot(2,3,5) %plot of stage 5 purple (cond B purple)
%             imagesc(timeLock,subjSessB,currentSubj(1).NSzpurpleSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg 405nm z score response surrounding NS- Stage 5')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%        subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
%             imagesc(timeLock,subjSessC,currentSubj(1).NSzpurpleSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('daily avg 405nm z score response surrounding NS- Stages 6-8')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('training day');
%             set(gca, 'ytick', subjSessC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS 405nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
%             
%             
            
            
     % ~~~~~~~~~~ One figure with only Blue response to DS & NS ~~~~~~~
            
        figure(figureCount);
        figureCount= figureCount+1;

        sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, 'Avg response by session to DS or NS across training stages')); %add big title above all subplots


        subplot(2,4,1) %plot of stage 1-4 blue (cond A blue)
        
            imagesc(timeLock,subjSessA,currentSubj(1).DSzblueSessionMeanA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stages 1-4 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessA); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
            
            
        subplot(2,4,2) %plot of stage 5 blue (cond B blue)
            
            imagesc(timeLock,subjSessB,currentSubj(1).DSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stages 5 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessB); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
        
        subplot(2,4,3) %plot of stage 6-7 blue (cond C blue)
            imagesc(timeLock,subjSessC,currentSubj(1).DSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
        subplot(2,4,4) %plot of stage 8 blue (cond D blue)
            imagesc(timeLock,subjSessD,currentSubj(1).DSzblueSessionMeanD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessD); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
            
              
                   
        subplot(2,4,6) %plot of stage 5 blue (cond B blue)
            
            imagesc(timeLock,subjSessB,currentSubj(1).NSzblueSessionMeanB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
            title(strcat('daily avg NS response Stages 1-4 (465nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessB); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
        
        subplot(2,4,7) %plot of stage 6-8 blue (cond C blue)
            imagesc(timeLock,subjSessC,currentSubj(1).NSzblueSessionMeanC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
            title(strcat('daily avg NS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
            set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
            
            subplot(2,4,8) %plot of stage 6-8 blue (cond C blue)
            imagesc(timeLock,subjSessD,currentSubj(1).NSzblueSessionMeanD) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
            title(strcat('daily avg NS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', subjSessC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
            set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

            
end %end subject loop


%% Between subjects session avg by stage

%TODO: all pohtometry data is  more readable in (session, cue, subj)
%format, consider switching rest of code to this format
% subjIncluded= subjects(~ismember(subjects,'rat10')); %excluding VP-VTA-FP10

for subj= 1:numel(subjIncluded) %for each subject
       currentSubj= subjDataAnalyzed.(subjIncluded{subj}); %use this for easy indexing into the current subject within the struct

      %counter for sessions that meet each condition, reset between subjs
      sesCountA= 1;
      sesCountB= 1;
      sesCountC= 1;
      sesCountD= 1;

       for session = 1:numel(currentSubj) %for each training session this subject completed
            
           %cond A
           if currentSubj(session).trainStage <5 
               %save photometry data 
                allRats(1).DSzblueSessionMeanA(sesCountA,:,subj)= currentSubj(session).periDS.DSzblueMean; 
               %save training day label for this data 
                allRats(1).subjSessA(sesCountA,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountA= sesCountA+1;
           end %end conditional A

             %cond B
           if currentSubj(session).trainStage ==5 
               %save photometry data 
                allRats(1).DSzblueSessionMeanB(sesCountB,:,subj)= currentSubj(session).periDS.DSzblueMean; 
%                 allRats(1).DSzpurpleSessionMeanB(:,sesCountB,subj)= currentSubj(session).periDS.DSzpurpleMean;
                allRats(1).NSzblueSessionMeanB(sesCountB,:,subj)= currentSubj(session).periNS.NSzblueMean;
               %save training day label for this data 
                allRats(1).subjSessB(sesCountB,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountB= sesCountB+1;
           end %end conditional B
           
               %cond C
           if currentSubj(session).trainStage== 6 || currentSubj(session).trainStage==7 
               %save photometry data 
                allRats(1).DSzblueSessionMeanC(sesCountC,:,subj)= currentSubj(session).periDS.DSzblueMean; 
                allRats(1).NSzblueSessionMeanC(sesCountC,:,subj)= currentSubj(session).periNS.NSzblueMean;
               %save training day label for this data 
                allRats(1).subjSessC(sesCountC,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountC= sesCountC+1;
           end %end conditional C
           
                %cond D
           if currentSubj(session).trainStage ==8
               %save photometry data 
                allRats(1).DSzblueSessionMeanD(sesCountD,:,subj)= currentSubj(session).periDS.DSzblueMean; 
                allRats(1).NSzblueSessionMeanD(sesCountD,:,subj)= currentSubj(session).periNS.NSzblueMean;
               %save training day label for this data 
                allRats(1).subjSessD(sesCountD,subj)=currentSubj(session).trainDay; 
               %iterate the counter for sessions that meet this condition
                sesCountD= sesCountD+1;
           end %end conditional D
           

        end %end session loop
        
        
        %the above code filled in blank training dates with 0 (e.g. if 1 rat 
        %ran 12 days but others ran 9 days, the 3 days in between were 
        %filled with 0), let's make these = nan instead 
            %condA
        for ses = 1:size(allRats(1).subjSessA,1) %each row is a session
           if allRats(1).subjSessA(ses,subj)==0 %if there's no data for this date
              %make train day nan
              allRats(1).subjSessA(ses,subj)=nan;
              %make photometery data nan
              allRats(1).DSzblueSessionMeanA(ses,:,subj)=nan; 
           end
        end
            %condB
         for ses = 1:size(allRats(1).subjSessB,1) %each row is a session
           if allRats(1).subjSessB(ses,subj)==0 %if there's no data for this date
              %make train day nan
              allRats(1).subjSessB(ses,subj)=nan;
              %make photometery data nan
              allRats(1).DSzblueSessionMeanB(ses,:,subj)=nan; 
              allRats(1).NSzblueSessionMeanB(ses,:,subj)=nan;
           end
         end
           %condC
         for ses = 1:size(allRats(1).subjSessC,1) %each row is a session
           if allRats(1).subjSessC(ses,subj)==0 %if there's no data for this date
              %make train day nan
              allRats(1).subjSessC(ses,subj)=nan;
              %make photometery data nan
              allRats(1).DSzblueSessionMeanC(ses,:,subj)=nan; 
              allRats(1).NSzblueSessionMeanC(ses,:,subj)=nan;
           end
         end
           %condD
         for ses = 1:size(allRats(1).subjSessD,1) %each row is a session
           if allRats(1).subjSessD(ses,subj)==0 %if there's no data for this date
              %make train day nan`
              allRats(1).subjSessD(ses,subj)=nan;
              %make photometery data nan
              allRats(1).DSzblueSessionMeanD(ses,:,subj)=nan; 
              allRats(1).NSzblueSessionMeanD(ses,:,subj)=nan;
           end
        end
        
end



 % now get mean of all rats per training day ( each column is a training day , each 3d page is a subject)

 %cond A
 allRats.grandMeanDSzblueA=nanmean(allRats.DSzblueSessionMeanA,3);

 %cond B
  allRats.grandMeanDSzblueB=nanmean(allRats.DSzblueSessionMeanB,3);
  allRats.grandMeanNSzblueB= nanmean(allRats.NSzblueSessionMeanB,3);

 %cond C
  allRats.grandMeanDSzblueC=nanmean(allRats.DSzblueSessionMeanC,3);
  allRats.grandMeanNSzblueC= nanmean(allRats.NSzblueSessionMeanC,3);
  
 %cond D
  allRats.grandMeanDSzblueD=nanmean(allRats.DSzblueSessionMeanD,3);
  allRats.grandMeanNSzblueD= nanmean(allRats.NSzblueSessionMeanD,3);
  
  %let's get a simple day count for each condition to use as heatplot y axis
    sessA= 1:size(allRats(1).subjSessA,1);
    sessB= 1:size(allRats(1).subjSessB,1);
    sessC= 1:size(allRats(1).subjSessC,1);
    sessD= 1:size(allRats(1).subjSessD,1);

    %     %get list of session days for heatplot y axis (transposed for readability)
    %     subjTrial= cat(2, currentSubj.trainDay).'; %this is only training days for this subj



        %get list of session days for heatplot y axis
    %     subjTrialNS=[]; %keep track of sessions that have valid NS trials
    %     dateNS= [];
    %     for session = 1:numel(currentSubj) %for each training session this subject completed
    %         if ~isempty(currentSubj(session).periNS.NSzblueMean) %if there's an NS trial in this session, add it to the array that will mark the y axis
    % %              subjTrialNS= cat(2, subjTrialNS, currentSubj(session).trainDay); %old method based on trainDay
    %                 dateNS= cat(2, dateNS, currentSubj(session).date);
    %         end
    %     end %end session loop
    %     
    %     %search NS dates for the appropriate index in allDates, then label it
    %     %similar to subjTrial
    %     for thisDate = 1:numel(dateNS) 
    %         subjTrialNS(thisDate)= find(allDates==dateNS(thisDate)); %returns the index in allDates that matches the date of this NS session
    %     end
         %Color axes   

         %First, we'll want to establish boundaries for our colormaps based on
         %the std of the z score response. We want to have equidistant
         %color axis max and min so that 0 sits directly in the middle

         %TODO: should this be a pooled std calculation (pooled blue & purple)?

         %define DS color axes
         %get the avg std in the blue and purple z score responses to all cues,
         %get absolute value and then multiply this by some factor to define a color axis max and min

         stdFactor= 6; %multiplicative factor- how many stds away should we set our max & min color value? 

             %cond A
         topDSzblueA= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzblueA = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

            %cond b
         topDSzblueB= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzblueB = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

            %cond c
         topDSzblueC= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzblueC = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

            %cond D
         topDSzblueD= stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         bottomDSzblueD = -stdFactor*abs(nanmean((std(allRats(1).grandMeanDSzblueD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

         
         bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzblueD];
         tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzblueD];

       
         %now choose the most extreme values to represent the color axis
         bottomAllDS= min(bottoms);
         topAllDS= max(tops);

    %     %same, but defining color axes for NS
    %     if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
    %         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
    %         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
    % 
    %         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
    %         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));
    % 
    %         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
    %         topAllNS= max(topNSzblue, topNSzpurple);
    %     end
    %     %Establish a shared bottom and top for shared color axis of DS & NS
    %     if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
    %         bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
    %         topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
    %     else
            bottomMeanShared= bottomAllDS;
            topMeanShared= topAllDS;
    %     end



    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0
    % 

      % ~~~~~~~~~~ One figure with only Blue response to DS & NS ~~~~~~~
            
        figure(figureCount);
        figureCount= figureCount+1;

        sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' Avg response to DS or NS across 5 subjects')); %add big title above all subplots


        subplot(2,4,1) %plot of stage 1-4 blue (cond A blue)
        
            imagesc(timeLock, sessA,allRats(1).grandMeanDSzblueA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stages 1-4 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessA); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
            
        subplot(2,4,2) %plot of stage 1-4 blue (cond B blue)
        
            imagesc(timeLock, sessB,allRats(1).grandMeanDSzblueB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stage 5 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessB); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
        
     subplot(2,4,3) %plot of stage 1-4 blue (cond C blue)
        
            imagesc(timeLock, sessC,allRats(1).grandMeanDSzblueC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
       
    subplot(2,4,4) %plot of stage 1-4 blue (cond D blue)
        
            imagesc(timeLock, sessD,allRats(1).grandMeanDSzblueD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessD); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
          
                   
      subplot(2,4,6) %plot of NS stage 5 blue (cond B blue)
        
            imagesc(timeLock, sessB,allRats(1).grandMeanNSzblueB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg NS response Stage 5 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessB); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
        
       subplot(2,4,7) %plot of NS stage 6-7 blue (cond C blue)
        
            imagesc(timeLock, sessC,allRats(1).grandMeanNSzblueC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg NS response Stages 6-7 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
            
        subplot(2,4,8) %plot of NS stage 8 blue (cond D blue)
        
            imagesc(timeLock, sessD,allRats(1).grandMeanNSzblueD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('daily avg DS response Stage 8 (465nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('training day');
            set(gca, 'ytick', sessD); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS 465nm z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
            set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

    
%% stage 1-4, 5, 6+ trial DS plots latency sorted


%we'll pull from the subjDataAnalyzed struct to make our heatplots

for subj= 1:numel(subjectsAnalyzed) %for each subject
    currentSubj= subjDataAnalyzed.(subjectsAnalyzed{subj}); %use this for easy indexing into the current subject within the struct

    %initialize/clear arrays between subjects
    currentSubj(1).NSzblueAllTrials= [];
    currentSubj(1).NSzpurpleAllTrials= [];
    currentSubj(1).NSpeLatencyAllTrials= [];

    sesCountA= 1;
    sesCountB= 1;
    sesCountC= 1;
    sesCountD=1;

    subjSessA= [];
    subjSessB= [];
    subjSessC= [];
    subjSessD= [];
    
    trialAcount= 1;
    trialBcount=1;
    trialCcount=1;
    trialDcount=1;
    
    trialBNScount=1;
    trialCNScount=1;
    trialDNScount=1;
    
    DSloxAllTrialsA = [];
    DSloxAllTrialsB= [];
    DSloxAllTrialsC= [];
    DSloxAllTrialsD= [];
    
    NSloxAllTrialsA= [];
    NSloxAllTrialsB= [];
    NSloxAllTrialsC= [];
    NSloxAllTrialsD= [];
    
    for session = 1:numel(currentSubj) %for each training session this subject completed
       
        clear NSselected
        
        %We can only include trials that have a PE latency, so we need to
        %selectively extract these data first
        
            %get the DS cues
        DSselected= currentSubj(session).periDS.DS;  % all the DS cues

        %First, let's exclude trials where animal was already in port
        %to do so, find indices of subjDataAnalyzed.behavior.inPortDS that
        %have a non-nan value and use these to exclude DS trials from this
        %analysis (we'll make them nan)
            
        %We have to throw in an extra conditional in case we've excluded
        %cues in our peri cue analysis due to being too close to the
        %beginning or end. Otherwise, we can get an out of range error
        %because the inPortDS array doesn't exclude these cues.
        for inPortTrial = find(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS))
            if inPortTrial < numel(DSselected) 
                DSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortDS)) = nan;
            end
        end
        %Then, let's exclude trials where animal didn't make a PE during
        %the cue epoch. To do so, get indices of empty cells in
        %subjDataAnalyzed.behavior.poxDS (these are trials where no PE
        %happened during the cue epoch) and then use these to set that DS =
        %nan
        
        %same here, we need an extra conditional in case cues were excluded
        for noPEtrial = find(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS))
            if noPEtrial < numel(DSselected)
                DSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxDS)) = nan;
            end
        end
        
        %this may create some zeros, so let's make those nan as well
        DSselected(DSselected==0) = nan;
        
        %lets convert this to an index of trials with a valid value 
        DSselected= find(~isnan(DSselected));
        
            %Repeat above for NS 
        if ~isempty(currentSubj(session).periNS.NS)
             NSselected= currentSubj(session).periNS.NS;  

            %First, let's exclude trials where animal was already in port
            %to do so, find indices of subjDataAnalyzed.behavior.inPortNS that
            %have a non-nan value and use these to exclude NS trials from this
            %analysis (we'll make them nan)

            NSselected(~isnan(subjDataAnalyzed.(subjects{subj})(session).behavior.inPortNS)) = nan;

            %Then, let's exclude trials where animal didn't make a PE during
            %the cue epoch. To do so, get indices of empty cells in
            %subjDataAnalyzed.behavior.poxNS (these are trials where no PE
            %happened during the cue epoch) and then use these to set that NS =
            %nan
            NSselected(cellfun('isempty', subjDataAnalyzed.(subjects{subj})(session).behavior.poxNS)) = nan;

       
            %lets convert this to an index of trials with a valid value 
            NSselected= find(~isnan(NSselected));
        end %end NS conditional       
        
        %Condition A
            if currentSubj(session).trainStage <5
                if sesCountA== 1 
                    currentSubj(1).DSzblueAllTrialsA= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
                    currentSubj(1).DSzpurpleAllTrialsA= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
                    currentSubj(1).DSpeLatencyAllTrialsA= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                    
%                     currentSubj(1).DSloxAllTrialsA= currentSubj(session).behavior.loxDS{DSselected};
                    if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                        currentSubj(1).NSzblueAllTrialsA= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                        currentSubj(1).NSzpurpleAllTrialsA= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                        currentSubj(1).NSpeLatencyAllTrialsA= currentSubj(session).behavior.NSpeLatency(NSselected); 
                        
                     else
%                        continue %continue if no NS data
                     end
                else %add subsequent sessions using cat()
                    currentSubj(1).DSzblueAllTrialsA = cat(2, currentSubj.DSzblueAllTrialsA, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                    currentSubj(1).DSzpurpleAllTrialsA = cat(2, currentSubj.DSzpurpleAllTrialsA, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                    currentSubj(1).DSpeLatencyAllTrialsA = cat(2,currentSubj(1).DSpeLatencyAllTrialsA,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

%                     currentSubj(1).DSloxAllTrialsA= cat(2,currentSubj(1).DSloxAllTrialsA,currentSubj(session).behavior.loxDS{DSselected});

                    if ~isempty(currentSubj(session).periNS.NS)
                        currentSubj(1).NSzblueAllTrialsA = cat(2, currentSubj.NSzblueAllTrialsA, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                        currentSubj(1).NSzpurpleAllTrialsA = cat(2, currentSubj.NSzpurpleAllTrialsA, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                        currentSubj(1).NSpeLatencyAllTrialsA = cat(2,currentSubj(1).NSpeLatencyAllTrialsA,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                    else
%                         continue %continue if no NS data
                    end
                end %end sesCount conditional

                    % licks
                    currentSubj(1).DSloxAllTrialsA{sesCountA}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset
                
                     %in order to sort licks according to trial by PE latency
                     %later, we need to reshape the lox cell array from nested
                     %{session}{cue} to just {cue}
                      for cue = 1:numel(currentSubj(1).DSloxAllTrialsA{session})
                          DSloxAllTrialsA{trialAcount} = currentSubj(1).DSloxAllTrialsA{session}{cue};
                          trialAcount=trialAcount+1;
                      end           

%                       trialAcount=1; %reset counter
%                       % NS licks
%                     currentSubj(1).NSloxAllTrialsA{session}= currentSubj(session).behavior.loxNSrel(NSselected);
%                     
%                     for cue= 1:numel(currentSubj(1).NSloxAllTrialsA{session})
%                         NSloxAllTrialsA{trialAcount}= currentSubj(1).NSloxAllTrialsA{session}{cue};
%                         trialAcount=trialAcount+1;
%                     end
%                         
                      
                sesCountA= sesCountA+1;
                subjSessA= cat(2, subjSessA, currentSubj(session).trainDay); %day count for y axis

            end %end Cond A
            
            %Condition B
                   if currentSubj(session).trainStage ==5
                        if sesCountB== 1 
                            currentSubj(1).DSzblueAllTrialsB= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
                            currentSubj(1).DSzpurpleAllTrialsB= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
                            currentSubj(1).DSpeLatencyAllTrialsB= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                             if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                                currentSubj(1).NSzblueAllTrialsB= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                                currentSubj(1).NSzpurpleAllTrialsB= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                                currentSubj(1).NSpeLatencyAllTrialsB= currentSubj(session).behavior.NSpeLatency(NSselected); 
                             else
%                                continue %continue if no NS data
                             end
                        else %add subsequent sessions using cat()
                            currentSubj(1).DSzblueAllTrialsB = cat(2, currentSubj.DSzblueAllTrialsB, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                            currentSubj(1).DSzpurpleAllTrialsB = cat(2, currentSubj.DSzpurpleAllTrialsB, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                            currentSubj(1).DSpeLatencyAllTrialsB = cat(2,currentSubj(1).DSpeLatencyAllTrialsB,currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

                            if ~isempty(currentSubj(session).periNS.NS)
                                currentSubj(1).NSzblueAllTrialsB = cat(2, currentSubj.NSzblueAllTrialsB, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                                currentSubj(1).NSzpurpleAllTrialsB = cat(2, currentSubj.NSzpurpleAllTrialsB, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                                currentSubj(1).NSpeLatencyAllTrialsB = cat(2,currentSubj(1).NSpeLatencyAllTrialsB,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                            else
%                                 continue %continue if nos NS data
                            end
                        end %end sesCount conditional

                        
                         %licks
                        currentSubj(1).DSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset

                        currentSubj(1).NSloxAllTrialsB{sesCountB}= currentSubj(session).behavior.loxNSrel(NSselected);

                        
                         %in order to sort licks according to trial by PE latency
                         %later, we need to reshape the lox cell array from nested
                         %{session}{cue} to just {cue}
                          for cue = 1:numel(currentSubj(1).DSloxAllTrialsB{sesCountB})
                              DSloxAllTrialsB{trialBcount} = currentSubj(1).DSloxAllTrialsB{sesCountB}{cue};
                              trialBcount=trialBcount+1;
                          end           
                                            
                        for cue= 1:numel(currentSubj(1).NSloxAllTrialsB{sesCountB})
                            NSloxAllTrialsB{trialBNScount}= currentSubj(1).NSloxAllTrialsB{sesCountB}{cue};
                            trialBNScount=trialBNScount+1;
                        end

                        
                        sesCountB= sesCountB+1;
                        subjSessB= cat(2, subjSessB, currentSubj(session).trainDay); %day count for y axis

                  end %end Cond B
                  
              %Condition C
               if currentSubj(session).trainStage== 6 || currentSubj(session).trainStage ==7
                   
                    if sesCountC== 1 
                        currentSubj(1).DSzblueAllTrialsC= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
                        currentSubj(1).DSzpurpleAllTrialsC= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
                        currentSubj(1).DSpeLatencyAllTrialsC= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                         if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                            currentSubj(1).NSzblueAllTrialsC= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                            currentSubj(1).NSzpurpleAllTrialsC= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                            currentSubj(1).NSpeLatencyAllTrialsC= currentSubj(session).behavior.NSpeLatency(NSselected); 
                         else
%                            continue %continue if no NS data
                         end
                    else %add subsequent sessions using cat()
                        currentSubj(1).DSzblueAllTrialsC = cat(2, currentSubj.DSzblueAllTrialsC, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSzpurpleAllTrialsC = cat(2, currentSubj.DSzpurpleAllTrialsC, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSpeLatencyAllTrialsC = cat(2, currentSubj(1).DSpeLatencyAllTrialsC, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

                        if ~isempty(currentSubj(session).periNS.NS)
                            currentSubj(1).NSzblueAllTrialsC = cat(2, currentSubj.NSzblueAllTrialsC, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                            currentSubj(1).NSzpurpleAllTrialsC = cat(2, currentSubj.NSzpurpleAllTrialsC, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                            currentSubj(1).NSpeLatencyAllTrialsC = cat(2,currentSubj(1).NSpeLatencyAllTrialsC,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                        else
%                             continue %continue if nos NS data
                        end
                    end %end sesCount conditional

                        %licks
                        currentSubj(1).DSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset

                        currentSubj(1).NSloxAllTrialsC{sesCountC}= currentSubj(session).behavior.loxNSrel(NSselected);

                        
                         %in order to sort licks according to trial by PE latency
                         %later, we need to reshape the lox cell array from nested
                         %{session}{cue} to just {cue}
                          for cue = 1:numel(currentSubj(1).DSloxAllTrialsC{sesCountC})
                              DSloxAllTrialsC{trialCcount} = currentSubj(1).DSloxAllTrialsC{sesCountC}{cue};
                              trialCcount=trialCcount+1;
                          end           
                                            
                        for cue= 1:numel(currentSubj(1).NSloxAllTrialsC{sesCountC})
                            NSloxAllTrialsC{trialCNScount}= currentSubj(1).NSloxAllTrialsC{sesCountC}{cue};
                            trialCNScount=trialCNScount+1;
                        end

                    sesCountC= sesCountC+1;
                    subjSessC= cat(2, subjSessC, currentSubj(session).trainDay); %day count for y axis

              end %end Cond C
              
                     
              %Condition D
               if currentSubj(session).trainStage==8
                   
                    if sesCountD== 1 
                        currentSubj(1).DSzblueAllTrialsD= squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected));
                        currentSubj(1).DSzpurpleAllTrialsD= squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected));
                        currentSubj(1).DSpeLatencyAllTrialsD= currentSubj(session).behavior.DSpeLatency(DSselected); %collect all the 1st PE latency values from trials of interest
                         if ~isempty(currentSubj(session).periNS.NS) %if there's valid NS data
                            currentSubj(1).NSzblueAllTrialsD= squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)); 
                            currentSubj(1).NSzpurpleAllTrialsD= squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected));
                            currentSubj(1).NSpeLatencyAllTrialsD= currentSubj(session).behavior.NSpeLatency(NSselected); 
                         else
%                            continue %continue if no NS data
                         end
                    else %add subsequent sessions using cat()
                        currentSubj(1).DSzblueAllTrialsD = cat(2, currentSubj.DSzblueAllTrialsD, (squeeze(currentSubj(session).periDS.DSzblue(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSzpurpleAllTrialsD = cat(2, currentSubj.DSzpurpleAllTrialsD, (squeeze(currentSubj(session).periDS.DSzpurple(:,:,DSselected)))); %concatenate- this contains z score response to DS from every DS (should have #columns= ~30 cues x #sessions)
                        currentSubj(1).DSpeLatencyAllTrialsD = cat(2, currentSubj(1).DSpeLatencyAllTrialsD, currentSubj(session).behavior.DSpeLatency(DSselected)); %collect all of the DSpeLatencies for sorting between sessions

                        if ~isempty(currentSubj(session).periNS.NS)
                            currentSubj(1).NSzblueAllTrialsD = cat(2, currentSubj.NSzblueAllTrialsD, (squeeze(currentSubj(session).periNS.NSzblue(:,:,NSselected)))); 
                            currentSubj(1).NSzpurpleAllTrialsD = cat(2, currentSubj.NSzpurpleAllTrialsD, (squeeze(currentSubj(session).periNS.NSzpurple(:,:,NSselected)))); 
                            currentSubj(1).NSpeLatencyAllTrialsD = cat(2,currentSubj(1).NSpeLatencyAllTrialsD,currentSubj(session).behavior.NSpeLatency(NSselected)); %collect all of the NSpeLatencies for sorting between sessions
                        else
%                             continue %continue if nos NS data
                        end
                    end %end sesCount conditional

                        %licks
                        currentSubj(1).DSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxDSrel(DSselected); %note these timestamps are relative to cue onset

                        currentSubj(1).NSloxAllTrialsD{sesCountD}= currentSubj(session).behavior.loxNSrel(NSselected);

                        
                         %in order to sort licks according to trial by PE latency
                         %later, we need to reshape the lox cell array from nested
                         %{session}{cue} to just {cue}
                          for cue = 1:numel(currentSubj(1).DSloxAllTrialsD{sesCountD})
                              DSloxAllTrialsD{trialDcount} = currentSubj(1).DSloxAllTrialsD{sesCountD}{cue};
                              trialDcount=trialDcount+1;
                          end           
                                            
                        for cue= 1:numel(currentSubj(1).NSloxAllTrialsD{sesCountD})
                            NSloxAllTrialsD{trialDNScount}= currentSubj(1).NSloxAllTrialsD{sesCountD}{cue};
                            trialDNScount=trialDNScount+1;
                        end

                    sesCountD= sesCountD+1;
                    subjSessD= cat(2, subjSessD, currentSubj(session).trainDay); %day count for y axis

              end %end Cond D
              
              
              
    end %end session loop
    
    %Sort PE latencies and retrieve an index of the sorted order that
    %we'll use to sort the photometry data and other behavioralevents(licks)
    
        %cond a
    [DSpeLatencySortedA,DSsortIndA] = sort(currentSubj(1).DSpeLatencyAllTrialsA);       
%     [NSpeLatencySortedA,NSsortIndA] =  %stages before 5 have no ns %sort(currentSubj(1).NSpeLatencyAllTrialsA);

         %cond b
    [DSpeLatencySortedB,DSsortIndB] = sort(currentSubj(1).DSpeLatencyAllTrialsB);       
    [NSpeLatencySortedB,NSsortIndB] = sort(currentSubj(1).NSpeLatencyAllTrialsB);
        %cond c
    [DSpeLatencySortedC,DSsortIndC] = sort(currentSubj(1).DSpeLatencyAllTrialsC);       
    [NSpeLatencySortedC,NSsortIndC] = sort(currentSubj(1).NSpeLatencyAllTrialsC);
       %cond D
    [DSpeLatencySortedD,DSsortIndD] = sort(currentSubj(1).DSpeLatencyAllTrialsD);       
    [NSpeLatencySortedD,NSsortIndD] = sort(currentSubj(1).NSpeLatencyAllTrialsD);
    
    
    %Sort all trials by PE latency
        %cond a
    currentSubj(1).DSzblueAllTrialsA= currentSubj(1).DSzblueAllTrialsA(:,DSsortIndA);
    currentSubj(1).DSzpurpleAllTrialsA= currentSubj(1).DSzpurpleAllTrialsA(:,DSsortIndA);
%     currentSubj(1).NSzblueAllTrialsA = currentSubj(1).NSzblueAllTrialsA(:,NSsortIndA);
%     currentSubj(1).NSzpurpleAllTrialsA= currentSubj(1).NSzpurpleAllTrialsA(:,NSsortIndA);

             % sort licks
             currentSubj(1).DSloxAllTrialsA= DSloxAllTrialsA;
             currentSubj(1).DSloxAllTrialsA= currentSubj(1).DSloxAllTrialsA(:,DSsortIndA);


         %cond b
    currentSubj(1).DSzblueAllTrialsB= currentSubj(1).DSzblueAllTrialsB(:,DSsortIndB);
    currentSubj(1).DSzpurpleAllTrialsB= currentSubj(1).DSzpurpleAllTrialsB(:,DSsortIndB);
    currentSubj(1).NSzblueAllTrialsB = currentSubj(1).NSzblueAllTrialsB(:,NSsortIndB);
    currentSubj(1).NSzpurpleAllTrialsB= currentSubj(1).NSzpurpleAllTrialsB(:,NSsortIndB);
    
             % sort licks
             currentSubj(1).DSloxAllTrialsB= DSloxAllTrialsB;
             currentSubj(1).DSloxAllTrialsB= currentSubj(1).DSloxAllTrialsB(:,DSsortIndB);
             
             currentSubj(1).NSloxAllTrialsB= NSloxAllTrialsB;
             currentSubj(1).NSloxAllTrialsB= currentSubj(1).NSloxAllTrialsB(:,NSsortIndB);

          %cond C
    currentSubj(1).DSzblueAllTrialsC= currentSubj(1).DSzblueAllTrialsC(:,DSsortIndC);
    currentSubj(1).DSzpurpleAllTrialsC= currentSubj(1).DSzpurpleAllTrialsC(:,DSsortIndC);
    currentSubj(1).NSzblueAllTrialsC = currentSubj(1).NSzblueAllTrialsC(:,NSsortIndC);
    currentSubj(1).NSzpurpleAllTrialsC= currentSubj(1).NSzpurpleAllTrialsC(:,NSsortIndC);
               % sort licks
             currentSubj(1).DSloxAllTrialsC= DSloxAllTrialsC;
             currentSubj(1).DSloxAllTrialsC= currentSubj(1).DSloxAllTrialsC(:,DSsortIndC);
             
             currentSubj(1).NSloxAllTrialsC= NSloxAllTrialsC;
             currentSubj(1).NSloxAllTrialsC= currentSubj(1).NSloxAllTrialsC(:,NSsortIndC);
             
      %cond D
    currentSubj(1).DSzblueAllTrialsD= currentSubj(1).DSzblueAllTrialsD(:,DSsortIndD);
    currentSubj(1).DSzpurpleAllTrialsD= currentSubj(1).DSzpurpleAllTrialsD(:,DSsortIndD);
    currentSubj(1).NSzblueAllTrialsD = currentSubj(1).NSzblueAllTrialsD(:,NSsortIndD);
    currentSubj(1).NSzpurpleAllTrialsD= currentSubj(1).NSzpurpleAllTrialsD(:,NSsortIndD);
               % sort licks
             currentSubj(1).DSloxAllTrialsD= DSloxAllTrialsD;
             currentSubj(1).DSloxAllTrialsD= currentSubj(1).DSloxAllTrialsD(:,DSsortIndD);
             
             currentSubj(1).NSloxAllTrialsD= NSloxAllTrialsD;
             currentSubj(1).NSloxAllTrialsD= currentSubj(1).NSloxAllTrialsD(:,NSsortIndD);



    %Transpose these data for readability
        %cond a
    currentSubj(1).DSzblueAllTrialsA= currentSubj(1).DSzblueAllTrialsA';
    currentSubj(1).DSzpurpleAllTrialsA= currentSubj(1).DSzpurpleAllTrialsA';    
%     currentSubj(1).NSzblueAllTrialsA= currentSubj(1).NSzblueAllTrialsA';
%     currentSubj(1).NSzpurpleAllTrialsA= currentSubj(1).NSzpurpleAllTrialsA';
        %cond b
    currentSubj(1).DSzblueAllTrialsB= currentSubj(1).DSzblueAllTrialsB';
    currentSubj(1).DSzpurpleAllTrialsB= currentSubj(1).DSzpurpleAllTrialsB';    
    currentSubj(1).NSzblueAllTrialsB= currentSubj(1).NSzblueAllTrialsB';
    currentSubj(1).NSzpurpleAllTrialsB= currentSubj(1).NSzpurpleAllTrialsB';
        %cond c
    currentSubj(1).DSzblueAllTrialsC= currentSubj(1).DSzblueAllTrialsC';
    currentSubj(1).DSzpurpleAllTrialsC= currentSubj(1).DSzpurpleAllTrialsC';    
    currentSubj(1).NSzblueAllTrialsC= currentSubj(1).NSzblueAllTrialsC';
    currentSubj(1).NSzpurpleAllTrialsC= currentSubj(1).NSzpurpleAllTrialsC';
        %cond D
    currentSubj(1).DSzblueAllTrialsD= currentSubj(1).DSzblueAllTrialsD';
    currentSubj(1).DSzpurpleAllTrialsD= currentSubj(1).DSzpurpleAllTrialsD';    
    currentSubj(1).NSzblueAllTrialsD= currentSubj(1).NSzblueAllTrialsD';
    currentSubj(1).NSzpurpleAllTrialsD= currentSubj(1).NSzpurpleAllTrialsD';
    
    
       
       %get trial count for y axis of heatplot
   currentSubj(1).totalDScountA= 1:size(currentSubj(1).DSzblueAllTrialsA,1); 
   currentSubj(1).totalDScountB= 1:size(currentSubj(1).DSzblueAllTrialsB,1); 
   currentSubj(1).totalDScountC= 1:size(currentSubj(1).DSzblueAllTrialsC,1);
   currentSubj(1).totalDScountD= 1:size(currentSubj(1).DSzblueAllTrialsD,1);

   
%    currentSubj(1).totalNScountA= 1:size(currentSubj(1).NSzblueAllTrialsA,1); 
   currentSubj(1).totalNScountB= 1:size(currentSubj(1).NSzblueAllTrialsB,1); 
   currentSubj(1).totalNScountC= 1:size(currentSubj(1).NSzblueAllTrialsC,1);
   currentSubj(1).totalNScountD= 1:size(currentSubj(1).NSzblueAllTrialsD,1);




    
       %Color axes   
     
     %First, we'll want to establish boundaries for our colormaps based on
     %the std of the z score response. We want to have equidistant
     %color axis max and min so that 0 sits directly in the middle
     
     %TODO: should this be a pooled std calculation (pooled blue & purple)?
    
     %define DS color axes
     %get the avg std in the blue and purple z score responses to all cues,
     %get absolute value and then multiply this by some factor to define a color axis max and min
     
     stdFactor= 4; %multiplicative factor- how many stds away should we set our max & min color value? 
     
        %cond A
     topDSzblueA= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleA= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueA = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsA, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleA= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsA, 0, 2))));
     
        %cond B
     topDSzblueB= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleB= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueB = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsB, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleB= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsB, 0, 2))));
        %cond c
     topDSzblueC= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleC= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueC = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsC, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleC= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsC, 0, 2))));
     
     bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC];
     tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC];
     
       %cond D
     topDSzblueD= stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     topDSzpurpleD= stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor

     bottomDSzblueD = -stdFactor*abs(nanmean((std(currentSubj(1).DSzblueAllTrialsD, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
     bottomDSzpurpleD= -stdFactor*abs(nanmean((std(currentSubj(1).DSzpurpleAllTrialsD, 0, 2))));
     
     bottoms= [bottomDSzblueA, bottomDSzblueB, bottomDSzblueC, bottomDSzblueD, bottomDSzpurpleA, bottomDSzpurpleB, bottomDSzpurpleC, bottomDSzpurpleD];
     tops= [topDSzblueA, topDSzblueB, topDSzblueC, topDSzblueD, topDSzpurpleA, topDSzpurpleB, topDSzpurpleC, topDSzpurpleD];
     
     %now choose the most extreme of these two (between blue and
     %purple)to represent the color axis 
     bottomAllDS= min(bottoms);
     topAllDS= max(tops);
     
%     %same, but defining color axes for NS
%     if ~isempty(currentSubj(1).NSzblueSessionMean) %only run this if there's NS data
%         topNSzblue= stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
%         topNSzpurple= stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));%std calculated for each cue (across all timestamps), then averaged, absolute valued, then multiplied by factor
% 
%         bottomNSzblue= -stdFactor*abs(nanmean((std(currentSubj(1).NSzblueSessionMean, 0, 2))));
%         bottomNSzpurple= -stdFactor*abs(nanmean((std(currentSubj(1).NSzpurpleSessionMean, 0, 2))));
% 
%         bottomAllNS= min(bottomNSzblue, bottomNSzpurple);
%         topAllNS= max(topNSzblue, topNSzpurple);
%     end
%     %Establish a shared bottom and top for shared color axis of DS & NS
%     if ~isempty(currentSubj(1).NSzblueSessionMean) %if there is an NS
%         bottomMeanShared= min(bottomAllDS, bottomAllNS); %find the absolute min value
%         topMeanShared= max(topAllDS, topAllNS); %find the absolute min value
%     else
        bottomMeanShared= bottomAllDS;
        topMeanShared= topAllDS;
%     end
    
   

    timeLock = [-preCueFrames:postCueFrames]/fs;  %define a shared common time axis, timeLock, where cue onset =0

%     %Plots!
%     
%         figure(figureCount);
%         figureCount= figureCount+1;
% 
%            sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, ' response to DS across training stages- trials sorted by PE latency')); %add big title above all subplots
% 
% 
%         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
%         
%             imagesc(timeLock,currentSubj(1).totalDScountA,currentSubj(1).DSzblueAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 1-4 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,currentSubj(1).totalDScountB,currentSubj(1).DSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 5 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
%             imagesc(timeLock,currentSubj(1).totalDScountC,currentSubj(1).DSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 6-8 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
% 
%       subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
%         
%             imagesc(timeLock,currentSubj(1).totalDScountA,currentSubj(1).DSzpurpleAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
%             title(strcat('Stage 1-4 DS response (405nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountA); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,3,5) %plot of stage 5 purple (cond B purple)
%             
%             imagesc(timeLock,currentSubj(1).totalDScountB,currentSubj(1).DSzpurpleAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).DSzpurpleSessionMean));
%             title(strcat('Stage 5 DS response (405nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
%             imagesc(timeLock,currentSubj(1).totalDScountC,currentSubj(1).DSzpurpleAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).DSzpurpleSessionMean));
%             title(strcat(' Stage 6-8 DS response (405nm)')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('DS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
% 
%   %Overlay scatter of PE latency
%    subplot(2,3,1) %condA DS blue 
%    hold on
%    scatter(DSpeLatencySortedA,currentSubj(1).totalDScountA', 'm.');
%    
%    subplot(2,3,2) %condB DS blue 
%    hold on
%    scatter(DSpeLatencySortedB,currentSubj(1).totalDScountB', 'm.');
%       
%    subplot(2,3,3) %condC DS blue 
%    hold on
%    scatter(DSpeLatencySortedC,currentSubj(1).totalDScountC', 'm.');
%    
%    subplot(2,3,4) %cond A DS purple
%    hold on
%    scatter(DSpeLatencySortedA,currentSubj(1).totalDScountA', 'm.');
%    
%    subplot(2,3,5) %cond B DS purple
%    hold on
%    scatter(DSpeLatencySortedB,currentSubj(1).totalDScountB', 'm.');
%    
%    subplot(2,3,6) %cond C DS purple
%    hold on
%    scatter(DSpeLatencySortedC,currentSubj(1).totalDScountC', 'm.');
%    
%    
%     %overlay scatter of Licks- 
%        licksToPlot= 3;
%        lickAlpha= 0.15;
%     
%        subplot(2,3,1) %condA DS blue 
%        hold on
%        for trial= (currentSubj(1).totalDScountA)
%            %scatter all licks
% %                s= scatter(currentSubj(1).DSloxAllTrialsA{trial},ones(numel(currentSubj(1).DSloxAllTrialsA{trial}),1)*currentSubj(1).totalDScountA(trial), 'k.');
%            %scatter # of licksToPlot
%            if numel(currentSubj(1).DSloxAllTrialsA{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).DSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountA(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%     
%        subplot(2,3,2) %condB DS blue 
%        hold on
%        for trial= (currentSubj(1).totalDScountB)
%                %scatter # of licksToPlot
%            if numel(currentSubj(1).DSloxAllTrialsB{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).DSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountB(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%        
%        subplot(2,3,3) %condC DS blue 
%        hold on
%        for trial= (currentSubj(1).totalDScountC)
%                 %scatter # of licksToPlot
%            if numel(currentSubj(1).DSloxAllTrialsC{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).DSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountC(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%     
%        subplot(2,3,4) %condA DS purple 
%        hold on
%        for trial= (currentSubj(1).totalDScountA)
%                %scatter # of licksToPlot
%            if numel(currentSubj(1).DSloxAllTrialsA{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).DSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountA(trial), 'k.');
%                 s.MarkerEdgeAlpha= 0.3; %make transparent
%            end
%        end
%        
%        subplot(2,3,5) %condB DS purple 
%        hold on
%        for trial= (currentSubj(1).totalDScountB)
%                %scatter # of licksToPlot
%            if numel(currentSubj(1).DSloxAllTrialsB{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).DSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountB(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%        
%        subplot(2,3,6) %condC DS purple 
%        hold on
%        for trial= (currentSubj(1).totalDScountC)
%               %scatter # of licksToPlot
%            if numel(currentSubj(1).DSloxAllTrialsC{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).DSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountC(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%        
%        
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%     
%     
%     %NS plots!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% 
%        figure(figureCount);
%        figureCount= figureCount+1;
% 
%        sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, ' response to NS across training stages- trials sorted by PE latency')); %add big title above all subplots
% 
% 
%         subplot(2,3,1) %plot of stage 1-4 blue (cond A blue)
%         
% %             imagesc(timeLock,currentSubj(1).totalNScountA,currentSubj(1).NSzblueAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('Stage 1-4 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalNScountA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%             
%             
%         subplot(2,3,2) %plot of stage 5 blue (cond B blue)
%             
%             imagesc(timeLock,currentSubj(1).totalNScountB,currentSubj(1).NSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('Stage 5 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,3,3) %plot of stage 6-8 blue (cond C blue)
%             imagesc(timeLock,currentSubj(1).totalNScountC,currentSubj(1).NSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
%             title(strcat('Stage 6-8 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
% 
%       subplot(2,3,4) %plot of stage 1-4 purple (cond A purple)
% %         
% %             imagesc(timeLock,currentSubj(1).totalNScountA,currentSubj(1).NSzpurpleAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
% %             title(strcat('Stage 1-4 NS response (405nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
% %             xlabel('seconds from cue onset');
% %             ylabel('trial (latency sorted)');
% % %             set(gca, 'ytick', currentSubj(1).totalNScountA); %label trials appropriately
% %             caxis manual;
% %             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% % 
% %             c= colorbar; %colorbar legend
% %             c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% %               
%             
%             
%         subplot(2,3,5) %plot of stage 5 purple (cond B purple)
%             
%             imagesc(timeLock,currentSubj(1).totalNScountB,currentSubj(1).NSzpurpleAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).NSzpurpleSessionMean));
%             title(strcat('Stage 5 NS response (405nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountB); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
%               
%         
%         subplot(2,3,6) %plot of stage 6-8 purple (cond C purple)
%             imagesc(timeLock,currentSubj(1).totalNScountC,currentSubj(1).NSzpurpleAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).NSzpurpleSessionMean));
%             title(strcat(' Stage 6-8 NS response (405nm)')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
%             xlabel('seconds from cue onset');
%             ylabel('trial (latency sorted)');
% %             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
%             caxis manual;
%             caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values
% 
%             c= colorbar; %colorbar legend
%             c.Label.String= strcat('NS purple z-score calculated from', num2str(slideTime/fs), 's preceding cue');
% 
%             
%             
%             %Overlay scatter of PE latency
%    subplot(2,3,1) %condA NS blue 
%    hold on
% %    scatter(NSpeLatencySortedA,currentSubj(1).totalNScountA', 'm.');
%    
%    subplot(2,3,2) %condB NS blue 
%    hold on
%    scatter(NSpeLatencySortedB,currentSubj(1).totalNScountB', 'm.');
%       
%    subplot(2,3,3) %condC NS blue 
%    hold on
%    scatter(NSpeLatencySortedC,currentSubj(1).totalNScountC', 'm.');
%    
%    subplot(2,3,4) %cond A NS purple
%    hold on
% %    scatter(NSpeLatencySortedA,currentSubj(1).totalNScountA', 'm.');
%    
%    subplot(2,3,5) %cond B NS purple
%    hold on
%    scatter(NSpeLatencySortedB,currentSubj(1).totalNScountB', 'm.');
%    
%    subplot(2,3,6) %cond C NS purple
%    hold on
%    scatter(NSpeLatencySortedC,currentSubj(1).totalNScountC', 'm.');
%    
%             
%      %overlay scatter of Licks- 
%        licksToPlot= 3;
%       lickAlpha= 0.35;
% 
%     
%        subplot(2,3,1) %condA NS blue 
% %        hold on
% %        for trial= (currentSubj(1).totalNScountA)
%            %scatter all licks
% %                s= scatter(currentSubj(1).NSloxAllTrialsA{trial},ones(numel(currentSubj(1).NSloxAllTrialsA{trial}),1)*currentSubj(1).totalNScountA(trial), 'k.');
%            %scatter # of licksToPlot
% %            if numel(currentSubj(1).NSloxAllTrialsA{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).NSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountA(trial), 'k.');
% %                 s.MarkerEdgeAlpha= 0.3; %make transparent
% %            end
% %        end
%     
%        subplot(2,3,2) %condB NS blue 
%        hold on
%        for trial= (currentSubj(1).totalNScountB)
%                %scatter # of licksToPlot
%            if numel(currentSubj(1).NSloxAllTrialsB{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).NSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountB(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%        
%        subplot(2,3,3) %condC NS blue 
%        hold on
%        for trial= (currentSubj(1).totalNScountC)
%                 %scatter # of licksToPlot
%            if numel(currentSubj(1).NSloxAllTrialsC{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).NSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountC(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%     
%        subplot(2,3,4) %condA NS purple 
% %        hold on
% %        for trial= (currentSubj(1).totalNScountA)
% %                %scatter # of licksToPlot
% %            if numel(currentSubj(1).NSloxAllTrialsA{trial}) >= licksToPlot
% %                 s= scatter(currentSubj(1).NSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountA(trial), 'k.');
% %                 s.MarkerEdgeAlpha= 0.3; %make transparent
% %            end
%        
%        subplot(2,3,5) %condB NS purple 
%        hold on
%        for trial= (currentSubj(1).totalNScountB)
%                %scatter # of licksToPlot
%            if numel(currentSubj(1).NSloxAllTrialsB{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).NSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountB(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%        
%        subplot(2,3,6) %condC NS purple 
%        hold on
%        for trial= (currentSubj(1).totalNScountC)
%               %scatter # of licksToPlot
%            if numel(currentSubj(1).NSloxAllTrialsC{trial}) >= licksToPlot
%                 s= scatter(currentSubj(1).NSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountC(trial), 'k.');
%                 s.MarkerEdgeAlpha= lickAlpha; %make transparent
%            end
%        end
%             
%             
%             set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving
% 
%             
            
    % ~~~~ One figure with only Blue response to both DS & NS ~~~~~~~~~~~~~~~~~~~~
            
              figure(figureCount);
        figureCount= figureCount+1;

           sgtitle(strcat(subjData.(subjects{subj})(1).experiment, ' ', subjects{subj}, ' response to DS or NS across training stages- trials sorted by PE latency')); %add big title above all subplots


        subplot(2,4,1) %plot of stage 1-4 blue (cond A blue)
        
            imagesc(timeLock,currentSubj(1).totalDScountA,currentSubj(1).DSzblueAllTrialsA) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('Stage 1-4 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalDScountA); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
            
            
        subplot(2,4,2) %plot of stage 5 blue (cond B blue)
            
            imagesc(timeLock,currentSubj(1).totalDScountB,currentSubj(1).DSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('Stage 5 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalDScountB); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
        
        subplot(2,4,3) %plot of stage 6-7 blue (cond C blue)
            imagesc(timeLock,currentSubj(1).totalDScountC,currentSubj(1).DSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('Stage 6-7 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
         subplot(2,4,4) %plot of stage 8 blue (cond D blue)
            imagesc(timeLock,currentSubj(1).totalDScountD,currentSubj(1).DSzblueAllTrialsD) %, 'AlphaData', ~isnan(currentSubj(1).DSzblueSessionMean));
            title(strcat('Stage 8 DS response (465nm) ')); %'(n= ', num2str(unique(trialDSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalDScountC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('DS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
            
        subplot(2,4,6) %plot of stage 5 blue (cond B blue)
            
            imagesc(timeLock,currentSubj(1).totalNScountB,currentSubj(1).NSzblueAllTrialsB) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
            title(strcat('Stage 5 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalNScountB); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
              
        
        subplot(2,4,7) %plot of stage 6-7 blue (cond C blue)
            imagesc(timeLock,currentSubj(1).totalNScountC,currentSubj(1).NSzblueAllTrialsC) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
            title(strcat('Stage 6-7 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            
            
        subplot(2,4,8) %plot of stage 8 blue (cond D blue)
            imagesc(timeLock,currentSubj(1).totalNScountD,currentSubj(1).NSzblueAllTrialsD) %, 'AlphaData', ~isnan(currentSubj(1).NSzblueSessionMean));
            title(strcat('Stage 8 NS response (465nm) ')); %'(n= ', num2str(unique(trialNSnum)),')')); %display the possible number of cues in a session (this is why we used unique())
            xlabel('seconds from cue onset');
            ylabel('trial (latency sorted)');
%             set(gca, 'ytick', currentSubj(1).totalNScountC); %label trials appropriately
            caxis manual;
            caxis([bottomMeanShared topMeanShared]); %use a shared color axis to encompass all values

            c= colorbar; %colorbar legend
            c.Label.String= strcat('NS blue z-score calculated from', num2str(slideTime/fs), 's preceding cue');
            

      %Overlay scatter of PE latency
           subplot(2,4,1) %condA DS blue 
           hold on
           scatter(DSpeLatencySortedA,currentSubj(1).totalDScountA', 'm.');

           subplot(2,4,2) %condB DS blue 
           hold on
           scatter(DSpeLatencySortedB,currentSubj(1).totalDScountB', 'm.');

           subplot(2,4,3) %condC DS blue 
           hold on
           scatter(DSpeLatencySortedC,currentSubj(1).totalDScountC', 'm.');
                 
           subplot(2,4,4) %condD DS blue 
           hold on
           scatter(DSpeLatencySortedD,currentSubj(1).totalDScountD', 'm.');
           
           subplot(2,4,6) %condB NS blue 
           hold on
           scatter(NSpeLatencySortedB,currentSubj(1).totalNScountB', 'm.');

           subplot(2,4,7) %condC NS blue 
           hold on
           scatter(NSpeLatencySortedC,currentSubj(1).totalNScountC', 'm.');
           
           subplot(2,4,8) %condC NS blue 
           hold on
           scatter(NSpeLatencySortedD,currentSubj(1).totalNScountD', 'm.');
%             
%     %overlay scatter of Licks- 
%            licksToPlot= 3;
%            lickAlpha= 0.15;
% 
%            subplot(2,4,1) %condA DS blue 
%            hold on
%            for trial= (currentSubj(1).totalDScountA)
%                %scatter all licks
%                    s= scatter(currentSubj(1).DSloxAllTrialsA{trial},ones(numel(currentSubj(1).DSloxAllTrialsA{trial}),1)*currentSubj(1).totalDScountA(trial), 'k.');
%                %scatter # of licksToPlot
% %                if numel(currentSubj(1).DSloxAllTrialsA{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).DSloxAllTrialsA{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountA(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
% 
%            subplot(2,4,2) %condB DS blue 
%            hold on
%            for trial= (currentSubj(1).totalDScountB)
%                %scatter all licks
%                s= scatter(currentSubj(1).DSloxAllTrialsB{trial},ones(numel(currentSubj(1).DSloxAllTrialsB{trial}),1)*currentSubj(1).totalDScountB(trial), 'k.');
% 
%                    %scatter # of licksToPlot
% %                if numel(currentSubj(1).DSloxAllTrialsB{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).DSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountB(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
% 
%            subplot(2,4,3) %condC DS blue 
%            hold on
%            for trial= (currentSubj(1).totalDScountC)
%                %scatter all licks
%                s= scatter(currentSubj(1).DSloxAllTrialsC{trial},ones(numel(currentSubj(1).DSloxAllTrialsC{trial}),1)*currentSubj(1).totalDScountC(trial), 'k.');
% 
%                     %scatter # of licksToPlot
% %                if numel(currentSubj(1).DSloxAllTrialsC{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).DSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountC(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
% 
%           subplot(2,4,4) %condD DS blue 
%            hold on
%            for trial= (currentSubj(1).totalDScountD)
%                %scatter all licks
%                s= scatter(currentSubj(1).DSloxAllTrialsD{trial},ones(numel(currentSubj(1).DSloxAllTrialsD{trial}),1)*currentSubj(1).totalDScountD(trial), 'k.');
% 
%                     %scatter # of licksToPlot
% %                if numel(currentSubj(1).DSloxAllTrialsD{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).DSloxAllTrialsD{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalDScountD(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
% 
%            
%            
%            subplot(2,4,6) %condB NS blue 
%            hold on
%            for trial= (currentSubj(1).totalNScountB)
%               
%                %scatter all licks
%                s= scatter(currentSubj(1).NSloxAllTrialsB{trial},ones(numel(currentSubj(1).NSloxAllTrialsB{trial}),1)*currentSubj(1).totalNScountB(trial), 'k.');
% 
%                
%                    %scatter # of licksToPlot
% %                if numel(currentSubj(1).NSloxAllTrialsB{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).NSloxAllTrialsB{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountB(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
% 
%            subplot(2,4,7) %condC NS blue 
%            hold on
%            for trial= (currentSubj(1).totalNScountC)
%                 %scatter all licks
%                s= scatter(currentSubj(1).NSloxAllTrialsC{trial},ones(numel(currentSubj(1).NSloxAllTrialsC{trial}),1)*currentSubj(1).totalNScountC(trial), 'k.');
% 
%                
%                     %scatter # of licksToPlot
% %                if numel(currentSubj(1).NSloxAllTrialsC{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).NSloxAllTrialsC{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountC(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
%            
%            subplot(2,4,8) %condD NS blue 
%            hold on
%            for trial= (currentSubj(1).totalNScountD)
%                
%                    %scatter all licks
%                s= scatter(currentSubj(1).NSloxAllTrialsD{trial},ones(numel(currentSubj(1).NSloxAllTrialsD{trial}),1)*currentSubj(1).totalNScountD(trial), 'k.');
% 
%                     %scatter # of licksToPlot
% %                if numel(currentSubj(1).NSloxAllTrialsD{trial}) >= licksToPlot
% %                     s= scatter(currentSubj(1).NSloxAllTrialsD{trial}(1:licksToPlot), ones(licksToPlot,1)*currentSubj(1).totalNScountD(trial), 'k.');
%                     s.MarkerEdgeAlpha= lickAlpha; %make transparent
% %                end
%            end
%            
           set(gcf,'Position', get(0, 'Screensize')); %make the figure full screen before saving

           
end%end subj loop

%% ~~~ End~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Save the analyzed data 
%save the subjDataAnalyzed struct for later analysis
save(strcat(experimentName,'-', allDates, 'subjDataAnalyzed'), 'subjDataAnalyzed'); %the second argument here is the variable being saved, the first is the filename

disp(strcat('all done, expect ', num2str(figureCount-1), ' figures'));
figureCount=1;

%%  Speed test /optimizing

profile viewer;
% %things that should be optimized:


%% Example structure of loop through subjects and sessions 
% for subj= 1:numel(subjects) %for each subject
%    currentSubj= subjData.(subjects{subj}); %use this for easy indexing into the current subject within the struct
%    for session = 1:numel(currentSubj) %for each training session this subject completed
%    end %end session loop
% end %end subject loop


