%% Trying deconvolution

%Assume that total fluorescence = Sum(event evoked fluorescence + noise)
%Assume that event evoked fluorescence is consistent (doesn't vary between trials)


clear;
close all;
clc;

%% first load data
load(uigetfile('*.mat')); %load subjDataAnalyzed.mat generated by fpAnalyzeData.m

%initialize variables 
subjects= fieldnames(subjDataAnalyzed);
flagThreshold= 0.2; %t in seconds to flag shifted event timestamps (since we shift event timestamps to make them match the downsampled time window) 
fs=40; %sampling frequency
%% Exclude data
for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    excludedSessions= [];
    for session= 1:numel(currentSubj)
        if currentSubj(session).trainStage ~= 7 %only include stage 7 days
           excludedSessions= cat(2,excludedSessions,session);
        end
    end%end session loop
   subjDataAnalyzed.(subjects{subj})(excludedSessions)= []; 
   
   currentSubj= subjDataAnalyzed.(subjects{subj});
   excludedSessions= [];
   for session= 1:numel(currentSubj) %loop through again and get rid of all except final stage 7 day
       if session<numel(currentSubj)
           excludedSessions= cat(2,excludedSessions,session);
       end
   end%end session loop 2
   
   subjDataAnalyzed.(subjects{subj})(excludedSessions)= []; 
   
end %end subj loop

%% Exclude trials (e.g. if animal in port or no PE)
for subj= 1:numel(subjects)
    currentSubj= subjDataAnalyzed.(subjects{subj});
    for session = 1:numel(currentSubj)
        
        DSselected= [];
        DSselected= currentSubj(session).periDS.DS;  %select all the DS cues by default, then exclude based on criteria
             %exclude trials where in port (just fill w nan)
                %We have to throw in an extra conditional in case we've excluded
                %cues in our peri cue analysis due to being too close to the
                %beginning or end.
                for inPortTrial = find(~isnan(currentSubj(session).behavior.inPortDS))
                    if inPortTrial < numel(DSselected) 
                        DSselected(~isnan(currentSubj(session).behavior.inPortDS)) = nan;
                    end
                end
            %Then, let's exclude trials where animal did not make a PE during
                %the cue epoch. (cellfun('isempty'))
                for PEtrial = find(cellfun('isempty', currentSubj(session).behavior.poxDS))
                    if PEtrial < numel(DSselected)  %same here, we need an extra conditional in case cues were excluded
                        DSselected(cellfun('isempty', currentSubj(session).behavior.poxDS)) = nan;
                    end
                end
                
           for excludedTrial= find(isnan(DSselected))
               subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.DSrelShifted(excludedTrial)= nan;
               subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.poxDSrelTrialShifted{excludedTrial}= [];
               subjDataAnalyzed.(subjects{subj})(session).periDS.trialShift.loxDSrelTrialShifted{excludedTrial}= [];
           end
                
                
    end %end session loop
end %end subj loop


%% get timestamps of events and photometry data from all trials   

%get total trial count to establish dimensions of matrices
% trialCount=0;
% DStrialCount= 0;
% NStrialCount= 0;
% for subj= 1:numel(subjects) %for each subject
%     currentSubj= subjDataAnalyzed.(subjects{subj});
%     for session = 1:numel(currentSubj)
%         for cue= 1:numel(currentSubj(session).periDS.trialShift.DSrelShifted)
%             trialCount= trialCount+1;
%             DStrialCount= DStrialCount+1;
%         end
%         
%         for cue = 1:numel(currentSubj(session).periNS.NS)
%             trialCount= trialCount+1;
%             NStrialCount= NStrialCount+1;
%         end
%     end
% end

for subj= 1:numel(subjects) %for each subject
   currentSubj= subjDataAnalyzed.(subjects{subj}); %use this for easy indexing into the current subject within the struct
   
   clearvars -except currentSubj excludedSessions flagThreshold fs session subj subjDataAnalyzed subjects %clear all btwn subjs

   %initialize
   eventMaskCue = [];
   eventMaskFirstPox= [];
   eventMaskFirstLox= [];
   
   
   %get total trial count to establish dimensions of matrices
    trialCount=0;
    DStrialCount= 0;
    NStrialCount= 0;
    for session = 1:numel(currentSubj)
        for cue= 1:numel(currentSubj(session).periDS.trialShift.DSrelShifted)
            trialCount= trialCount+1;
            DStrialCount= DStrialCount+1;
        end
        
        for cue = 1:numel(currentSubj(session).periNS.NS)
            trialCount= trialCount+1;
            NStrialCount= NStrialCount+1;
        end
    end
   
     %save # of events, timestamps, & trials for ensuring correct shape of
     %matrices. M= # trials, K= # event types, T= # timestamps (letters used here are same as Ghazidadeh et al 2010 paper) 
    timeLock= currentSubj(session).periDS.trialShift.trialShiftTimeLock; %assume timeLock is concsistent among events
 
    K= 3; %# event types
    T= size(timeLock,2); % # timestamps
    M= trialCount; % # trials

%initialize matrices with correct dimensions
eventMaskBcue= zeros(M*T,T); %row for every timestamp in every trial, column for each timestamp in timeLock; will be binary coded
eventMaskBfirstPox= zeros(M*T,T); 
eventMaskBfirstLox= zeros(M*T,T);


trialCount= 0; %counter for total number of trials (used for indexing)
DStrialCount=0;
NStrialCount=0;
   for session = 1:numel(currentSubj) %for each training session this subject completed
       for cue= 1:numel(currentSubj(session).periDS.trialShift.DSrelShifted) %for each cue (trial) in this session
                     
           trialCount=trialCount+1; %count all trials between sessions & subjects 
           DStrialCount= DStrialCount+1; %specifically count DS trials so that we can match them up with timestamps
           
          %for indexing rows easily as we build the eventMask, keep track 
          %of timestamps (ts) that correspond to this trial 
          if trialCount==1
            tsThisTrial= 1:numel(timeLock);
          else
            tsThisTrial= tsThisTrial(end)+1:tsThisTrial(end)+numel(timeLock); 
          end
          
        %Also save the timestamps so that we can later separate DS vs. NS
        %trial types easily
        tsThisDStrial(DStrialCount,:)= tsThisTrial;
           
       %Get cue timestamp relative to trialStart (= 0+trialTimeShift)
          DStrialShifted= interp1(timeLock,timeLock, currentSubj(session).periDS.trialShift.DSrelShifted, 'nearest'); %shift the event timestamp to the nearest in cutTime;

       
           eventMaskCue(trialCount,:)=zeros(size(timeLock));
           
           if ~isnan(DStrialShifted(cue)) %only run for non-excluded trials
               eventMaskCue(trialCount, find(timeLock==DStrialShifted(cue)))= 1;
                              
               
           
                %cue onset where timeLock==0           
               eventIndCue(trialCount)= find(timeLock(1,:)==DStrialShifted(cue));

               eventMaskBcue(tsThisTrial(eventIndCue(trialCount)), eventIndCue(trialCount))= 1; %replace 0 with 1 where timestamp in timeLock(column) intersects with timestamp on this trial(row) 
           else
               eventIndCue(trialCount)= nan;
               
          end

           
       %Get PE timestamps
           if ~isempty(currentSubj(session).periDS.trialShift.poxDSrelTrialShifted{cue}) %only run if PE during this cue
               if currentSubj(session).periDS.trialShift.poxDSrelTrialShifted{cue} < max(timeLock) %since poxDS & loxDS are defined as DSonset+cueLength (not trialStart+cueLength), possible that out of range error will occur
                   poxDS{trialCount,:}= currentSubj(session).periDS.trialShift.poxDSrelTrialShifted{cue}; %get timestamps of PEs relative to DS
               else
                   %if pox happened after timeLock, include only pox within timeLock
                   poxDS{trialCount,:}=  currentSubj(session).periDS.trialShift.poxDSrelTrialShifted{cue}(currentSubj(session).periDS.trialShift.poxDSrelTrialShifted{cue} < max(timeLock));
                   disp('pox outside of timeLock, removing');
               end
           else
               poxDS{trialCount,:}= []; %if no pe during this trial, make empty
           end
           
           eventMaskFirstPox(trialCount,:)= zeros(size(timeLock));
           
           
           %Important step! Shifting event timestamp to match timeLock
          poxDS{trialCount,:}= interp1(timeLock,timeLock, poxDS{trialCount,:}, 'nearest'); %shift the event timestamp to the nearest in cutTime;
            
          %fill eventMask with 1 where event occurs
           if ~isempty(poxDS{trialCount,:}) %only run if there's a valid pe on this trial
              eventIndPox(trialCount)= find(timeLock(1,:)==poxDS{trialCount,:}(1)); %get index of timestamp corresponding to this event
              eventMaskFirstPox(trialCount,eventIndPox(trialCount))= 1;  %replace 0s with 1s for first pe on this trial
              
              eventMaskBfirstPox(tsThisTrial(eventIndPox(trialCount)), eventIndPox(trialCount))= 1; %replace 0 with 1 where timestamp in timeLock(column) intersects with timestamp on this trial(row) 
                           
              %debug, this should always return True
              if eventIndPox(trialCount)~=find(eventMaskBfirstPox(tsThisTrial,eventIndPox(trialCount))==1) %search for the timestamp that ==1 within eventInd column, and make sure it matches the relative eventInd timestamp for that trial (just matching row with column) 
                warning('eventMaskBfirstPox index doesnt match: subj %s DS %s',num2str(subj),num2str(cue));
              end
      
              %flag event timestamps that have shifted too much- this was done in fpAnalyzeData.m
                timeShift(trialCount)= abs(poxDS{trialCount,:}(1)-currentSubj(session).periDS.trialShift.poxDSrelTrialShifted{cue}(1));
                if abs(timeShift(trialCount)) >flagThreshold %this will flag cues whose time shift deviates above a threshold (in seconds)
                    disp(strcat('>>Error *big pox time shift_', num2str(timeShift(trialCount)), '; subj_', num2str(subj), '; sess_', num2str(session), '; cue_',num2str(cue)));
                end 
                
           else %make eventInd nan if no pox on this trial
               eventIndPox(trialCount)= nan;
           end
           
            %Get lick timestamps
           if ~isempty(currentSubj(session).periDS.trialShift.loxDSrelTrialShifted{cue}) %only run if PE during this cue
                if currentSubj(session).periDS.trialShift.loxDSrelTrialShifted{cue} < max(timeLock) %since poxDS & loxDS are defined as DSonset+cueLength (not trialStart+cueLength), possible that out of range error will occur
                   loxDS{trialCount,:}= currentSubj(session).periDS.trialShift.loxDSrelTrialShifted{cue}; %get timestamps of lox relative to DS
                else
                   %if lox happened after timeLock, include only lox within timeLock
                   loxDS{trialCount,:}=  currentSubj(session).periDS.trialShift.loxDSrelTrialShifted{cue}(currentSubj(session).periDS.trialShift.loxDSrelTrialShifted{cue} < max(timeLock)); 
                   disp('removed some lox beyond timeLock');
               end
           else
               loxDS{trialCount,:}= []; %if no lox during this trial, make empty
           end
           
           eventMaskFirstLox(trialCount,:)= zeros(size(timeLock));
           
           %Important step!! Shifting event timestamp to match timeLock
          loxDS{trialCount,:}= interp1(timeLock,timeLock, loxDS{trialCount,:}, 'nearest'); %shift the event timestamp to the nearest in cutTime;
            
           if ~isempty(loxDS{trialCount,:}) %only run if there's a valid pe on this trial
              eventIndLox(trialCount)= find(timeLock(1,:)==loxDS{trialCount,:}(1)); %get index of timestamp corresponding to this event
              eventMaskFirstLox(trialCount,eventIndLox(trialCount))= 1;  %replace 0s with 1s for first pe on this trial
              
              eventMaskBfirstLox(tsThisTrial(eventIndLox(trialCount)), eventIndLox(trialCount))= 1; %replace 0 with 1 where timestamp in timeLock(column) intersects with timestamp on this trial(row) 

                            
              %flag event timestamps that have shifted too much %this was
              %done in fpAnalyzeData.m
                timeShift(trialCount)= abs(loxDS{trialCount,:}(1)-currentSubj(session).periDS.trialShift.loxDSrelTrialShifted{cue}(1));
                if abs(timeShift(trialCount)) >flagThreshold %this will flag cues whose time shift deviates above a threshold (in seconds)
                    disp(strcat('>>Error *big lox time shift_', num2str(timeShift(trialCount)), '; subj_', num2str(subj), '; sess_', num2str(session), '; cue_',num2str(cue)));
                end
           else  %make eventInd nan if no pox on this trial
               eventIndLox(trialCount)= nan;
           end
           
           %flag trials where Lox precedes Pox
           if ~isnan(eventIndLox(trialCount))
               if eventIndLox(trialCount) <= eventIndPox(trialCount) || isnan(eventIndPox(trialCount))
                   disp(strcat('>>Warning: lox before pox- Subj_ ', num2str(subj), '_session_',num2str(session),'_DS_',num2str(cue)));
               end
           end
           
          %Get z score of 465nm photometry signal- timelocked to every event
          periTrialBlueAllTrials(:,trialCount)= currentSubj(session).periDS.trialShift.trialShiftDSzblue(:,:,cue); %timelock to arbitrary trial start
          periCueBlueAllTrials(:,trialCount)= currentSubj(session).periDS.DSzblue(:,:,cue);
          periPoxBlueAllTrials(:,trialCount)= currentSubj(session).periDSpox.DSzpoxblue(:,:,cue);
          periLoxBlueAllTrials(:,trialCount)= currentSubj(session).periDSlox.DSzloxblue(:,:,cue);
          
          %Get z score of 405nm photometry signal- timelocked to every event
          periTrialPurpleAllTrials(:,trialCount)= currentSubj(session).periDS.trialShift.trialShiftDSzpurple(:,:,cue); %timelock to arbitrary trial start
          periCuePurpleAllTrials(:, trialCount)= currentSubj(session).periDS.DSzpurple(:,:,cue);
          periPoxPurpleAllTrials(:,trialCount)= currentSubj(session).periDSpox.DSzpoxpurple(:,:,cue);
          periLoxPurpleAllTrials(:,trialCount)= currentSubj(session).periDSlox.DSzloxpurple(:,:,cue);
          
          
          %Add subj label for this trial
          subjLabel(:,trialCount)= ones(size(timeLock))'*subj;
           
          %Add trial type label for this trial
          trialTypeLabel(:,trialCount)= ones(size(timeLock))'; %1 for DS
          
          %keep track of timestamps              
          timeToCue(:,trialCount)= timeLock;

       end %end DS cue (trial) loop
       
       %Now repeat for NS
       for cue= 1:numel(currentSubj(session).periNS.NS) %for each cue (trial) in this session
           trialCount=trialCount+1; %count all trials between sessions & subjects 
           NStrialCount= NStrialCount+1;
           
              %for indexing rows easily as we build the eventMask, keep track 
              %of timestamps (ts) that correspond to this trial 
              if trialCount==1
                tsThisTrial= 1:numel(timeLock);
              else
                 tsThisTrial= tsThisTrial(end)+1:tsThisTrial(end)+numel(timeLock); 
              end
           
              tsThisNSTrial(NStrialCount,:)= tsThisTrial;
              
       %Get cue timestamp TODO: change definition of trial start time to
       %introduce variability
           eventMaskCue(trialCount,:)=zeros(size(timeLock));
           eventMaskCue(trialCount, find(timeLock==0))= 1;
           
       %cue onset where timeLock==0           
           eventIndCue(trialCount)= find(timeLock==0);
           
           eventMaskBcue(tsThisTrial(eventIndCue(trialCount)), eventIndCue(trialCount))= 1; %replace 0 with 1 where timestamp in timeLock(column) intersects with timestamp on this trial(row) 

           
       %Get PE timestamps
           if ~isempty(currentSubj(session).behavior.poxNS{cue}) %only run if PE during this cue
               poxNS{trialCount,:}= currentSubj(session).behavior.poxNS{cue}-currentSubj(session).periNS.NS(cue); %get timestamps of PEs relative to NS
           else
               poxNS{trialCount,:}= []; %if no pe during this trial, make empty
           end
           
           eventMaskFirstPox(trialCount,:)= zeros(size(timeLock));
           
           %Important step!! Shifting event timestamp to match timeLock
          poxNS{trialCount,:}= interp1(timeLock,timeLock, poxNS{trialCount,:}, 'nearest'); %shift the event timestamp to the nearest in cutTime;
            
           if ~isempty(poxNS{trialCount,:}) %only run if there's a valid pe on this trial
              eventIndPox(trialCount)= find(timeLock(1,:)==poxNS{trialCount,:}(1)); %get index of timestamp corresponding to this event
              eventMaskFirstPox(trialCount,eventIndPox(trialCount))= 1;  %replace 0s with 1s for first pe on this trial
                            
           
              eventMaskBfirstPox(tsThisTrial(eventIndPox(trialCount)), eventIndPox(trialCount))= 1; %replace 0 with 1 where timestamp in timeLock(column) intersects with timestamp on this trial(row) 
                           
              %debug, this should always return True
              if eventIndPox(trialCount)~=find(eventMaskBfirstPox(tsThisTrial,eventIndPox(trialCount))==1) %search for the timestamp that ==1 within eventInd column, and make sure it matches the relative eventInd timestamp for that trial (just matching row with column) 
                warning('eventMaskBfirstPox index doesnt match: subj %s NS %s',num2str(subj),num2str(cue));
              end
                  
              
              %flag event timestamps that have shifted too much
                timeShift(trialCount)= abs(poxNS{trialCount,:}(1)-currentSubj(session).behavior.NSpeLatency(cue));
                if abs(timeShift(trialCount)) >flagThreshold %this will flag cues whose time shift deviates above a threshold (in seconNS)
                    disp(strcat('>>Error *big pox time shift_', num2str(timeShift(trialCount)), '; subj_', num2str(subj), '; sess_', num2str(session), '; cue_',num2str(cue)));
                end
           else %make eventInd nan if no pox on this trial
               eventIndPox(trialCount)= nan;
           end
           
            %Get lick timestamps
           if ~isempty(currentSubj(session).behavior.loxNS{cue}) %only run if PE during this cue
               loxNS{trialCount,:}= currentSubj(session).behavior.loxNS{cue}-currentSubj(session).periNS.NS(cue); %get timestamps of PEs relative to NS
           else
               loxNS{trialCount,:}= []; %if no pe during this trial, make empty
           end
           
           eventMaskFirstLox(trialCount,:)= zeros(size(timeLock));
           
           
           %Important step!! Shifting event timestamp to match timeLock
          loxNS{trialCount,:}= interp1(timeLock,timeLock, loxNS{trialCount,:}, 'nearest'); %shift the event timestamp to the nearest in cutTime;
            
           if ~isempty(loxNS{trialCount,:}) %only run if there's a valid pe on this trial
              eventIndLox(trialCount)= find(timeLock(1,:)==loxNS{trialCount,:}(1)); %get index of timestamp corresponding to this event
              eventMaskFirstLox(trialCount,eventIndLox(trialCount))= 1;  %replace 0s with 1s for first pe on this trial
                        
              eventMaskBfirstLox(tsThisTrial(eventIndLox(trialCount)), eventIndLox(trialCount))= 1; %replace 0 with 1 where timestamp in timeLock(column) intersects with timestamp on this trial(row) 

              %flag event timestamps that have shifted too much
                timeShift(trialCount)= abs(loxNS{trialCount,:}(1)-currentSubj(session).behavior.loxNSrel{cue}(1));
                if abs(timeShift(trialCount)) >flagThreshold %this will flag cues whose time shift deviates above a threshold (in seconNS)
                    disp(strcat('>>Error *big lox time shift_', num2str(timeShift(trialCount)), '; subj_', num2str(subj), '; sess_', num2str(session), '; cue_',num2str(cue)));
                end
           else %make eventInd nan if no pox on this trial
               eventIndLox(trialCount)= nan;
           end
           
             %flag trials where Lox precedes Pox
           if ~isnan(eventIndLox(trialCount))
               if eventIndLox(trialCount) <= eventIndPox(trialCount) || isnan(eventIndPox(trialCount))
                   disp(strcat('>>Warning: lox before pox- Subj_ ', num2str(subj), '_session_',num2str(session),'_NS_',num2str(cue)));
               end
           end
           
           if ~isempty(currentSubj(session).periNS.NS) %only run if NS present
              %Get z score of 465nm photometry signal- timelocked to every event
              periCueBlueAllTrials(:,trialCount)= currentSubj(session).periNS.NSzblue(:,:,cue);
              periPoxBlueAllTrials(:,trialCount)= currentSubj(session).periNSpox.NSzpoxblue(:,:,cue);
              periLoxBlueAllTrials(:,trialCount)= currentSubj(session).periNSlox.NSzloxblue(:,:,cue);

              %Get z score of 405nm photometry signal- timelocked to every event
              periCuePurpleAllTrials(:, trialCount)= currentSubj(session).periNS.NSzpurple(:,:,cue);
              periPoxPurpleAllTrials(:,trialCount)= currentSubj(session).periNSpox.NSzpoxpurple(:,:,cue);
              periLoxPurpleAllTrials(:,trialCount)= currentSubj(session).periNSlox.NSzloxpurple(:,:,cue);

           else
%                periCueBlueAllTrials(:,trialCount)= nan(size(timeLock))';
%                periCuePurpleAllTrials(:,trialCount)=  nan(size(timeLock))';
%                
%                periPoxBlueAllTrials(:,trialCount)= nan(size(timeLock))';
%                periPoxPurpleAllTrials(:,trialCount)=  nan(size(timeLock))';
%                
%                periPoxBlueAllTrials(:,trialCount)= nan(size(timeLock))';
%                periPoxPurpleAllTrials(:,trialCount)=  nan(size(timeLock))';
           end
           
              %Add subj label for this trial
              subjLabel(:,trialCount)= ones(size(timeLock))'*subj;

              %Add trial type label for this trial
              trialTypeLabel(:,trialCount)= zeros(size(timeLock))'; %0 for NS
           
              %keep track of timestamps
              timeToCue(:,trialCount)= timeLock;
              
       end %end NS cue (trial) loop
                  
   end %end session loop
% end %end subject loop

% %% visualization- just checking if event timestamp mask looks appropriate (should be no negative PE timestamps etc.)
% %really slow bc scattering in a loop
% 
% figure;
% hold on; 
% for trial= 1:trialCount
%     if ~isempty(find(eventMaskFirstPox(trial,:)==1))
%     %     scatter(timeLock(find(eventMaskFirstPox(trial,:)==1)), ones(1,numel(eventMaskFirstPox(eventMaskFirstPox(trial,:)==1))));
%     end
% end
% 
% for trial= 1:trialCount
%     if ~isempty(find(eventMaskFirstLox(trial,:)==1))
% %         scatter(timeLock(find(eventMaskFirstLox(trial,:)==1)), ones(1,numel(eventMaskFirstLox(eventMaskFirstLox(trial,:)==1))));
%     end
% end

% %% Visualization - making sure eventMaskB timestamps look correct
figure; %cue onset visualization
plot(eventIndCue,'k.'); title(strcat('subj-', subjects{subj},'-eventInd')); xlabel('trial'); ylabel('timestamp');
hold on; 

%overlay PE visualization
plot(eventIndPox,'.')

%overlay lox visualization
plot(eventIndLox,'.');

legend('cue onset', 'first PE', 'first lick');


%Transpose event masks into (timestamp, trial) format
eventMaskCue= eventMaskCue';
eventMaskFirstLox= eventMaskFirstLox';
eventMaskFirstPox= eventMaskFirstPox';


%% Get relative timestamps of events (instead of binary mask)
timeToPox= nan(size(eventMaskFirstPox));
timeToLox= nan(size(eventMaskFirstPox));

for trial= 1:size(eventMaskFirstPox,2)
    eventInd= find(eventMaskFirstPox(:,trial)==1);
    timeToPox(eventInd,trial)= 0; %0 = time of pe
    timeToPox(1:eventInd-1,trial)= flip(-[1:eventInd-1]/fs); %fill timestamps preceding event
    timeToPox(eventInd+1:end,trial)= [1:size(timeToPox,1)-eventInd]/fs; %fill timestamps following event
end 

for trial= 1:size(eventMaskFirstLox,2)
    eventInd= find(eventMaskFirstLox(:,trial)==1);
    timeToLox(eventInd,trial)= 0; %0 = time of pe
    timeToLox(1:eventInd-1,trial)= flip(-[1:eventInd-1]/fs); %fill timestamps preceding event
    timeToLox(eventInd+1:end,trial)= [1:size(timeToLox,1)-eventInd]/fs; %fill timestamps following event
end 

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%% Iterative deconvolution model based on (Ghazidadeh, Fields, & Ambroggi 2010)

%Equation 2 from this paper is illutrative: F= ZH+N ; where F=Bulk fluorescence, Z= Event timings, H= Event related fluorescence, N= Noise... all column vectors 
%Goal in this section will be to use Equation 3 to calculate Hbar

%initialize
F= []; %bulk fluorescence from all timestamps and all trials; column vector
Z= []; %binary coded event timings (1=event) ; MKxKT matrix (where M= # trials, K= # event types, T= # timestamps)
H= []; %event-related fluorescence; column  vector
N=[];%noise; column vector

DStrialCount= 0; %counters for trials of each type
NStrialCount= 0; 

%let's come up with a "Noise" distribution to sample from and estimate
%noise... we'll base it off of fluorescence before cue onset
noiseEst= periCueBlueAllTrials(1:4*fs,:);  
noiseDistroBlue= fitdist(noiseEst(:), 'Normal'); %construct a normal distro based from first 2s in peri-cue period

%Get DS trial data
for trial= 1:trialCount
    if trialTypeLabel(:,trial)==1
        DStrialCount= DStrialCount+1;
        
        %for indexing rows easily as we build the eventMask, keep track 
          %of timestamps (ts) that correspond to this trial 
          if DStrialCount==1
            tsThisTrial= 1:numel(timeLock);
          else
            tsThisTrial= tsThisTrial(end)+1:tsThisTrial(end)+numel(timeLock); 
          end
        
        periTrialBlueDSTrials(:,DStrialCount)= periTrialBlueAllTrials(:,trial);
        
%         eventMaskDS(:,DStrialCount)= eventMaskCue(:,trial); %old code,  misshaped eventMasks
%         eventMaskFirstPoxDStrials(:,DStrialCount)= eventMaskFirstPox(:,trial);
%         eventMaskFirstLoxDStrials(:,DStrialCount)= eventMaskFirstLox(:,trial);

        %MTxK binary coded matrix for each event type
        eventMaskDS(tsThisTrial,:)= eventMaskBcue(tsThisDStrial(DStrialCount,:),:);
        eventMaskFirstPoxDStrials(tsThisTrial,:)= eventMaskBfirstPox(tsThisDStrial(DStrialCount,:),:);
        eventMaskFirstLoxDStrials(tsThisTrial,:)= eventMaskBfirstLox(tsThisDStrial(DStrialCount,:),:);
        
        eventIndPoxDStrials(:,DStrialCount)= eventIndPox(:,trial);
        
        periCueBlueDStrials(:,DStrialCount)= periCueBlueAllTrials(:,trial);
        periPoxBlueDStrials(:,DStrialCount)= periPoxBlueAllTrials(:,trial);
        periLoxBlueDStrials(:,DStrialCount)= periLoxBlueAllTrials(:,trial);
    end
end %end all trial loop

 %Update # of events, timestamps, & trials for ensuring correct shape of
  %matrices. M= # trials, K= # event types, T= # timestamps (letters used here are same as Ghazidadeh et al 2010 paper) 
    timeLock= currentSubj(session).periDS.timeLock; %assume timeLock is concsistent among events
 
    K= 3; %# events
    T= size(timeLock,2); % # timestamps
    M= DStrialCount; % # trials
    
    F= periTrialBlueDSTrials(:); %vectorize for single column vector with fluorescence for every timestamp for every DS trial

%     N=  random(noiseDistroBlue, size(F)); %single column vector with noise; randomly sample values from noise distribution constructed above; same size as F (noise for every timestamp)
   %maybe constant single noise estimate (mean) for each ts more appropriate, discarding std for now
   N= ones(size(F))*noiseDistroBlue.mu; 
    
    figure; plot(N, '.'); title('estimated noise (N)'); %visualize estimated "noise"

    %Binary coded event timestamps in (timestamp, event type) format; size MTxKT
    %according to paper... we've already got a separate MT x K matrix from
    %the above code for every event type. Let's just combine them together
    %into 1 matrix, Z
    
    Z= [eventMaskDS, eventMaskFirstPoxDStrials, eventMaskFirstLoxDStrials];
    
    
    %This resulted in an MTxK matrix
%     Z(:,1)= eventMaskDS(:); %cue timestamps
%     Z(:,2)= eventMaskFirstPoxDStrials(:); %first PE timestamps
%     Z(:,3)= eventMaskFirstLoxDStrials (:); %first lick timestamps
    
% Equation 3 from this paper: take equation 2, multiply by Zt and divide by # trials M
% Hbar = (1/M)*VH + (1/M)*Z*N ; where Hbar = peri event histogram, M= #
% trials,Z= binary coded event times, V= "convolution matrix" size KTxKT equivalent to Z'*Z that 'maps the K
% event related fluorescence to the corresponding K PETHs', H= actual event
% related fluorescence,
    %initialize

    %multiplication step to calculate V memory intensive bc result is very
    %large matrix. To workaround, use a sparse matrix... This will work because we're using
    %binary coding for event timestamps (so most elements will be==0)

%     V=zeros(K*T) %545gb 
%     V=zeros(K*T, 'uint8') %68.1gb 
%     V= spalloc(K*T,K*T,K*T); %6.49mb %KTxKT matrix with some reserved spots for 1s


    %convert Z to a sparse matrix before multiplication
    Z= sparse(Z);

    %get convolution matrix V
    V= Z'*Z; % 'convolution matrix' , sparse due to very large KTxKT dimensions and binary coding
    
    
        
    Hbar= []; %raw peri event z score, raw PETH for all events, KTx1 column vector
    
    %could manually assign Hbar as mean response timelocked to events- unclear what they did in the paper but this contradicts equation 3? 
    %Hbar= [nanmean(periCueBlueDStrials,2); nanmean(periPoxBlueDStrials,2); nanmean(periLoxBlueDStrials,2)];%append peri-event fluorescence into single column vector 
        
    
    Hbar=(1/M)*Z'*F; %Equation 3; Hbar is a KTx1 vector with PETHs for all events... V is used to map PETHs onto ERFs (H)
%         this works, but because multiplying by Z (mostly 0)- most
%         timestamps end up being 0

%     Hbar2= (1/M)*(V*H) + (1/M)*Z'*N %eq 3 restated... results in matrix multiplication error for V*H because H is unknown
%could use this to calculate H?    

%% Equation 4 from this paper- find inverse of V using Neumann series... note that this really is a 
%'series' in the mathematical sense, with an infinite number of loops (we can define some max # of iterations though)
% we might also want to apply some test of convergence.. also note that
% this equation uses the normalized version of V (1/MS*V) in order for the
% series to converge
    
    I = eye(size(V,1)); %I = identity matrix with size = #rows in matrix V ; Not explicitly defined in the paper but conventional notation


    %Establish S, scaling factor any real + number less than half of the "largest eigenvalue
    %of (1/M)V" used to normalize H and V
    S= abs(max(eigs((1/M)*V))/2)*4; %arbitrarily choosing to multiply largest eigenvalue/2 by 4 here so that it's guranteed to be more than half
   
   %Equation 4- not sure if necessary, seems folded into Eq 6
   numIterations= 10; %number of iterations to complete

    %this loop takes awhile; not actually necessary but maybe worth revisiting
%    sums=  nan(numIterations,1); 
   for iter= 1:numIterations
           Vinverse=  (I-((1/M*S)*V))^iter; %eq 4 normalized?
%            Vinverse= (I-V)^iter; %eq 4
%            mean(mean(Vinverse==((1/M*S)*V)))
%            
%            mean(mean(V*Vinverse==I)) %This should always return true? why is it returning false? Is Vinverse incorrect??????? %looks like it's returning the of the Identity matrix but diagonal zeros instead of 1s
%                                         %maybe "hollow matrix" bc sparse-
%                                         %nope, full() looks same
%            sums(iter)= sum(sum(Vinverse)); %just trying to see if the matrix is changing over iterations to test "convergence"
   end

%    scatter(1:numIterations,sums);
   
%Equation 5 from this paper- seems to be
%normalized form of equation 3
    

%     HbarS= (1/(M*S))*V*H+ (1/(M*S)) *Z'*N % Equation 5 from paper, error because H is unkown  
    
%% Equation 6- Iterative deconvolution in time
    %define a number of itereations (or maybe use a while loop with some
    %convergence criteria) 
    for iter= 1:numIterations 
        %Equation 6a outputs unbiased estimator of ERFs, Hhat
        %3 components to this equation: iteration 0 = Hbar/S + previous
        %non-zero iterations + current iteration
        
           prevIterTerm= zeros(K*T,1); %start at 0 and build with each previous iteration
           for prevIter = 1:iter-1 %equation builds with each iteration (maybe bc neumann series?);
               prevIterTerm = prevIterTerm+ (I- (1/M*S)*V)^prevIter *(Hbar/S);
           end
               Hhat(:,iter)= (Hbar/S) + prevIterTerm + (I- (1/M*S)*V)^iter*(Hbar/S); %+ (I- (1/M*S)*V)^iter * (Hbar/S); % equation 6a

        %Equation 6b- Estimate of deconvolution error (E)
            %not sure what lowercase n should be!
                 
%         E(:,iter)=  ((1/M*S) * ((I- (1/M*S))^iter) * Z'*N) - ((1/M*S) * (I-(1/(M*S))^iter) * V*H); %first equation under 6B, H unknown
        E(:,iter)= Vinverse * Z' * N; %2nd equation under 6B %maybe not appropriate to use because N is just an estimate?
    end
    
%Now that we have Hhat (KxT x #iterations), extract deconvolved response to each event type  
for eventType= 1:K   %for each event type, loop through to get correct timestamps %%NOTE NEED TO MATCH ORDER OF EVENTS 
     if eventType==1
        tsThisEvent= 1:numel(timeLock);     
        
        ERFcue = Hhat(tsThisEvent,:); %deconvolved ERF
        ERFerrorCue= E(tsThisEvent,:); %estimated error from eq 6b 
        
        HbarCue= Hbar(tsThisEvent,:); %visualizing
     else
         tsThisEvent= tsThisEvent(end)+1:tsThisEvent(end)+numel(timeLock); 
         
         if eventType==2
             ERFfirstPE= Hhat(tsThisEvent,:);  
             ERFerrorFirstPE= E(tsThisEvent,:);
             
             HbarFirstPE= Hbar(tsThisEvent,:); %visualizing 

         elseif eventType==3
             ERFfirstLick= Hhat(tsThisEvent,:);
             ERFerrorFirstLick= E(tsThisEvent,:);
             
             HbarFirstLick= Hbar(tsThisEvent,:); %visualizing

         end
     end    
end
  
 %visualize- plotting final iteration for now (:,end)
     figure; hold on; sgtitle(strcat('subj-', subjects{subj}, '-DS trials only; deconvolved event response (Hhat)'))
     subplot(3,1,1); hold on;
     title('DS');
     plot(timeLock,ERFcue(:,end));
%      plot(timeLock,ERFcue(:,end)+ERFerrorCue(:,end), 'k');
%      plot(timeLock, ERFcue(:,end)-ERFerrorCue(:,end),'k');
     subplot(3,1,2);
     title('first PE');
     plot(timeLock,ERFfirstPE(:,end)); 
     subplot(3,1,3);
     title('first lick');
     plot(timeLock,ERFfirstLick(:,end)); %legend('Cue','firstPE','firstLick');
     
      %visualize- plotting final iteration for now (:,end)
%      figure; hold on; sgtitle(strcat('subj-', subjects{subj}, '-DS trials only; ERFb (Hbar-Hhat)'))
%      subplot(3,1,1); hold on;
%      title('DS');
%      plot(timeLock,ERFcueB(:,end));
%      plot(timeLock,ERFcueB(:,end)+ERFerrorCue(:,end), 'k');
%      plot(timeLock, ERFcueB(:,end)-ERFerrorCue(:,end),'k');
%      subplot(3,1,2);
%      title('first PE');
%      plot(timeLock,ERFfirstPEb(:,end)); 
%      subplot(3,1,3);
%      title('first lick');
%      plot(timeLock,ERFfirstLickB(:,end)); %legend('Cue','firstPE','firstLick');
     
     
%      figure; plot(timeLock,periTrialBlueDSTrials); title('trial 465nm');

%since Hbar supposed to be == raw PETH, compare
figure; sgtitle('timelocked 465 vs Hbar')
subplot (3,1,1); title('DS')
hold on;
plot(timeLock,periCueBlueDStrials, 'b');
plot(timeLock,HbarCue, 'r'); legend('timelock','Hbar');
subplot(3,1,2); title('first PE'); hold on;
plot(timeLock,periPoxBlueDStrials, 'b');
plot(timeLock, HbarFirstPE, 'r');
subplot(3,1,3); title('first Lick'); hold on;
plot(timeLock, periLoxBlueDStrials, 'b');
plot(timeLock, HbarFirstLick, 'r');
    
end %end subj loop
%% Cross-validation 
    

     
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% OLD- Trying other regression based models
% 
% %% Get data into proper table format for model
% %Each column= variable (including response variable y, predictive variables x, and grouping variables g)
% %Each row= observation ); %vectorize into 1 column
% % eventMaskDSpox= eventMaskDSpox(:); %vectorize into 1 column
% periCueBlueAllTrials= periCueBlueAllTrials(:); %vectorize into 1 column
% periCuePurpleAllTrials= periCuePurpleAllTrials(:);%vectorize into 1 column
% eventMaskFirstPox= eventMaskFirstPox(:); %vectorize into 1 column
% eventMaskFirstLox= eventMaskFirstLox(:); %vectorize into 1 column
% trialTypeLabel= trialTypeLabel(:); %vectorize into 1 column
% timeToCue= timeToCue(:); %vectorize into 1 column
% subjLabel= subjLabel(:); %vectorize
% timeToPox= timeToPox(:); %vectorize
% timeToLox= timeToLox(:); %vectorize
% 
% 
% %trying only DS trials
% blueDStrials= periCueBlueAllTrials(find(trialTypeLabel==1));
% purpleDStrials= periCuePurpleAllTrials(find(trialTypeLabel==1));
% eventMaskFirstPoxDStrials= eventMaskFirstPox(find(trialTypeLabel==1));
% eventMaskFirstLoxDStrials= eventMaskFirstLox(find(trialTypeLabel==1));
% timeToCueDStrials= timeToCue(find(trialTypeLabel==1));
% subjLabelDStrials= subjLabel(find(trialTypeLabel==1));
% timeToPoxDStrials= timeToPox(find(trialTypeLabel==1));
% timeToLoxDStrials= timeToLox(find(trialTypeLabel==1));
% 
% 
% 
% %% Convolution- doesn't seem necessary
% 
% %convolution of event mask and photometry z score
% poxConvDStrials= conv(eventMaskFirstPoxDStrials, blueDStrials);
% loxConvDStrials= conv(eventMaskFirstLoxDStrials, blueDStrials);
% 
% %convolution of event mask and time series
% % poxConvDStrials= conv(eventMaskFirstPoxDStrials, timeToCueDStrials);
% % loxConvDStrials= conv(eventMaskFirstLoxDStrials, timeToCueDStrials);
% 
% %use padarray() to pad other variables with values to match size of conv result
% % blueDStrialsConv= padarray(blueDStrials, size(poxConvDStrials), nan);
% % blueDStrialsConv(:,1)= []; blueDStrialsConv(:,2)=[]; %this function pads in all dimensions, so delete new empty columns
% 
% %adjust for size of convolution (length convolution = length(kernel)+length(data)-1)
% blueDStrialsConv= nan([size(poxConvDStrials,1),1]); %make empty array matching size of conv result
% blueDStrialsConv(1:size(blueDStrials,1),1)= blueDStrials; %fill empty array with values in appropriate spots
% 
% timeToCueDStrialsConv= nan([size(poxConvDStrials,1),1]); %make empty array matching size of conv result
% timeToCueDStrialsConv(1:size(timeToCueDStrials,1),1)= timeToCueDStrials; %fill empty array with values in appropriate spots
% 
% 
% %% Generate and visualize models
% 
% predictors= [eventMaskFirstPox, eventMaskFirstLox, trialTypeLabel, timeToCue];
% 
% predictorsDS= [eventMaskFirstPoxDStrials, eventMaskFirstLoxDStrials, timeToCueDStrials];
% 
% predictorsDSconv= [poxConvDStrials, loxConvDStrials,timeToCueDStrialsConv];
% 
% predictorsDSrel = [timeToPoxDStrials, timeToLoxDStrials, timeToCueDStrials];
% 
% % %stepwise() may be useful in determining useful predictors
% % stepwiseModelBlue= stepwise(predictors, periCueBlueAllTrials);
% % stepwiseModelBlueDSconv= stepwise(predictorsDSconv, blueDStrialsConv);
% 
% modelTableBlue= table(timeToCue,trialTypeLabel,periCueBlueAllTrials); %all trials
% 
% modelTableDSblue= table(timeToCueDStrials, eventMaskFirstPoxDStrials, eventMaskFirstLoxDStrials, blueDStrials); %DS trials
% 
% modelTableDSblueConv= table(poxConvDStrials, loxConvDStrials, timeToCueDStrialsConv, blueDStrialsConv); %DS trial convs
% 
% modelTableDSblueRel= table(timeToPoxDStrials, timeToLoxDStrials, timeToCueDStrials, blueDStrials);
% 
% %Try LASSO
% lassoDS= lasso(predictorsDS, blueDStrials);
% % figure;
% % hold on;
% % scatter(eventMaskFirstPoxDStrials, blueDStrials);
% % plot(eventMaskFirstPoxDStrials, eventMaskFirstPoxDStrials*lassoDS(1,:))
% 
% %generate linear model
% % linearModelBlue= fitlm(modelTableBlue);
% 
% linearModelBlue= fitlm(modelTableBlue, 'periCueBlueAllTrials~timeToCue*trialTypeLabel');
% 
% figure;
% plot(linearModelBlue);
% 
% linearModelDSblue= fitlm(modelTableDSblue, 'blueDStrials~eventMaskFirstPoxDStrials*timeToCueDStrials+eventMaskFirstLoxDStrials*timeToCueDStrials');
% figure;
% plot(linearModelDSblue);
% 
% linearModelDSblueConv= fitlm(modelTableDSblueConv, 'blueDStrialsConv~timeToCueDStrialsConv*poxConvDStrials');
% figure;
% plot(linearModelDSblueConv);
% 
% linearModelDSblueRel= fitlm(modelTableDSblueRel, 'blueDStrials~timeToPoxDStrials+timeToLoxDStrials');
% figure;
% plot(linearModelDSblueRel);
% 
% % linearModelBlueCategorical= fitlm(periCueBlueAllTrials, predictors, 'Categorical', [1, 2, 3]);
% 
% % Try mixed effects model
% meTableDSblue= table(timeToCueDStrials, eventMaskFirstPoxDStrials, eventMaskFirstLoxDStrials, subjLabelDStrials, purpleDStrials, blueDStrials);
% 
% 
% mixedEffectsModelDSblue= fitlme(meTableDSblue, 'blueDStrials~timeToCueDStrials+eventMaskFirstPoxDStrials+eventMaskFirstLoxDStrials+purpleDStrials +(1|subjLabelDStrials)');
% figure;
% plotResiduals(mixedEffectsModelDSblue, 'fitted');
% 
% %gscatter
% 
% % figure;
% % gscatter(timeToCue,periCueBlueAllTrials,trialTypeLabel,'bgr','x.o');
% % x= linspace(min(timeLock),max(timeLock));
% % % line(x, feval(linearModelBlue,x,'0'),'Color','b');
% 
% % compute coefficients of predictor variables (events) using regress()
% % function
% 
% [regressBlue.coefficient, regressBlue.CI, regressBlue.residuals, regressBlue.stats]= regress(periCueBlueAllTrials, predictors);
% 
% [regressBlueDS.coefficient, regressBlueDS.CI, regressBlueDS.residuals, regressBlueDS.stats]= regress(blueDStrials, predictorsDS);
% 
% % for ts= 1:numel(eventMaskFirstPoxDStrials) %for each timestamp, let's model fluorescence given coefficients above
% %     bluePoxKernelDS(ts,1)= eventMaskFirstPoxDStrials(ts)*regressBlueDS.coefficient(1);
% % end
% 
% %% compare against data- making sure labels are right
% % figure;
% % hold on;
% % for subj= 1:numel(subjects)
% %     currentSubj= subjDataAnalyzed.(subjects{subj})
% %     for session = 1:numel(currentSubj)
% %         for cue= 1:size(currentSubj(session).periDS.DSzblue,3)
% %             scatter(timeLock,currentSubj(session).periDS.DSzblue(:,:,cue), 'g', '.')
% %         end
% %     end %end session loop
% % end %end subj loop